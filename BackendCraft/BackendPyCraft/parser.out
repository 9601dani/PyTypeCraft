Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    L_CORCHETE
    NULL
    R_CORCHETE

Grammar

Rule 0     S' -> init
Rule 1     init -> instrucciones
Rule 2     instrucciones -> instrucciones instruccion
Rule 3     instrucciones -> instruccion
Rule 4     instruccion -> console_pro sc
Rule 5     instruccion -> declaration_instruction sc
Rule 6     instruccion -> assig_pro sc
Rule 7     instruccion -> if_pro sc
Rule 8     instruccion -> while_pro sc
Rule 9     instruccion -> for_pro sc
Rule 10    instruccion -> for_each_pro sc
Rule 11    instruccion -> interface_pro sc
Rule 12    instruccion -> continue_pro sc
Rule 13    instruccion -> break_pro sc
Rule 14    instruccion -> return_pro sc
Rule 15    instruccion -> function_pro sc
Rule 16    instruccion -> sumadores sc
Rule 17    sc -> SEMI_COLON
Rule 18    sc -> <empty>
Rule 19    function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 20    function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 21    parameters_pro -> parameters_pro COMA parameter_pro
Rule 22    parameters_pro -> parameter_pro
Rule 23    parameter_pro -> LITERAL COLON type
Rule 24    parameter_pro -> LITERAL
Rule 25    continue_pro -> CONTINUE
Rule 26    break_pro -> BREAK
Rule 27    return_pro -> RETURN
Rule 28    return_pro -> RETURN a
Rule 29    interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
Rule 30    interface_atributos -> interface_atributos interface_atributo sc
Rule 31    interface_atributos -> <empty>
Rule 32    interface_atributo -> LITERAL COLON type
Rule 33    interface_atributo -> LITERAL
Rule 34    declaration_instruction -> LET declaracion_list
Rule 35    declaracion_list -> declaracion_list COMA assignacion_instruction
Rule 36    declaracion_list -> assignacion_instruction
Rule 37    assignacion_instruction -> LITERAL COLON type IGUAL a
Rule 38    assignacion_instruction -> LITERAL COLON type
Rule 39    assignacion_instruction -> LITERAL IGUAL a
Rule 40    type -> NUMBER
Rule 41    type -> STRING
Rule 42    type -> BOOLEAN
Rule 43    type -> ANY
Rule 44    type -> LITERAL
Rule 45    assig_pro -> LITERAL IGUAL a
Rule 46    if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
Rule 47    else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
Rule 48    else_pro -> ELSE L_LLAVE instrucciones R_LLAVE
Rule 49    else_pro -> <empty>
Rule 50    while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 51    for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 52    for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 53    for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 54    for_each_dec -> LET LITERAL OF a
Rule 55    for_each_dec -> LET LITERAL COLON type OF a
Rule 56    console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
Rule 57    expresion -> expresion COMA a
Rule 58    expresion -> a
Rule 59    a -> a OR b
Rule 60    a -> b
Rule 61    b -> b AND c
Rule 62    b -> c
Rule 63    c -> NOT d
Rule 64    c -> d
Rule 65    d -> d DISTINTO_QUE e
Rule 66    d -> d MENOR_QUE e
Rule 67    d -> d MENOR_IGUAL_QUE e
Rule 68    d -> d MAYOR_QUE e
Rule 69    d -> d MAYOR_IGUAL_QUE e
Rule 70    d -> d TRIPLE_IGUAL e
Rule 71    d -> e
Rule 72    e -> e MAS f
Rule 73    e -> e MENOS f
Rule 74    e -> f
Rule 75    f -> f TIMES g
Rule 76    f -> f DIVIDE g
Rule 77    f -> f MOD g
Rule 78    f -> f POTENCIA g
Rule 79    f -> g
Rule 80    f -> g PUNTO nativeFun L_PAREN expresion R_PAREN
Rule 81    g -> ENTERO
Rule 82    g -> DECIMAL
Rule 83    g -> CADENA
Rule 84    g -> LITERAL
Rule 85    g -> interface_assi
Rule 86    g -> L_PAREN a R_PAREN
Rule 87    sumadores -> LITERAL MAS MAS
Rule 88    sumadores -> LITERAL MENOS MENOS
Rule 89    interface_assi -> L_LLAVE atributos_assi R_LLAVE
Rule 90    atributos_assi -> atributos_assi COMA LITERAL COLON a
Rule 91    atributos_assi -> LITERAL COLON a
Rule 92    nativeFun -> TOSTRING
Rule 93    nativeFun -> TOFIXED
Rule 94    nativeFun -> TOEXPONENTIAL
Rule 95    nativeFun -> TOLOWERCASE
Rule 96    nativeFun -> TOUPPERCASE
Rule 97    nativeFun -> SPLIT
Rule 98    nativeFun -> CONCAT

Terminals, with rules where they appear

AND                  : 61
ANY                  : 43
BOOLEAN              : 42
BREAK                : 26
CADENA               : 83
COLON                : 23 32 37 38 55 90 91
COMA                 : 21 35 57 90
CONCAT               : 98
CONSOLE              : 56
CONTINUE             : 25
DECIMAL              : 82
DISTINTO_QUE         : 65
DIVIDE               : 76
ELSE                 : 47 48
ENTERO               : 81
FOR                  : 51 52 53
FUNCTION             : 19 20
IF                   : 46 47
IGUAL                : 37 39 45
INTERFACE            : 29
LET                  : 34 54 55
LITERAL              : 19 20 23 24 29 32 33 37 38 39 44 45 54 55 84 87 88 90 91
LOG                  : 56
L_CORCHETE           : 
L_LLAVE              : 19 20 29 46 47 48 50 51 52 53 89
L_PAREN              : 19 20 46 47 50 51 52 53 56 80 86
MAS                  : 72 87 87
MAYOR_IGUAL_QUE      : 69
MAYOR_QUE            : 68
MENOR_IGUAL_QUE      : 67
MENOR_QUE            : 66
MENOS                : 73 88 88
MOD                  : 77
NOT                  : 63
NULL                 : 
NUMBER               : 40
OF                   : 54 55
OR                   : 59
POTENCIA             : 78
PUNTO                : 56 80
RETURN               : 27 28
R_CORCHETE           : 
R_LLAVE              : 19 20 29 46 47 48 50 51 52 53 89
R_PAREN              : 19 20 46 47 50 51 52 53 56 80 86
SEMI_COLON           : 17 51 51 52 52
SPLIT                : 97
STRING               : 41
TIMES                : 75
TOEXPONENTIAL        : 94
TOFIXED              : 93
TOLOWERCASE          : 95
TOSTRING             : 92
TOUPPERCASE          : 96
TRIPLE_IGUAL         : 70
WHILE                : 50
error                : 

Nonterminals, with rules where they appear

a                    : 28 37 39 45 46 47 50 51 52 54 55 57 58 59 86 90 91
assig_pro            : 6 51 52 52
assignacion_instruction : 35 36
atributos_assi       : 89 90
b                    : 59 60 61
break_pro            : 13
c                    : 61 62
console_pro          : 4
continue_pro         : 12
d                    : 63 64 65 66 67 68 69 70
declaracion_list     : 34 35
declaration_instruction : 5 51
e                    : 65 66 67 68 69 70 71 72 73
else_pro             : 46 47
expresion            : 56 57 80
f                    : 72 73 74 75 76 77 78
for_each_dec         : 53
for_each_pro         : 10
for_pro              : 9
function_pro         : 15
g                    : 75 76 77 78 79 80
if_pro               : 7
init                 : 0
instruccion          : 2 3
instrucciones        : 1 2 19 20 46 47 48 50 51 52 53
interface_assi       : 85
interface_atributo   : 30
interface_atributos  : 29 30
interface_pro        : 11
nativeFun            : 80
parameter_pro        : 21 22
parameters_pro       : 19 21
return_pro           : 14
sc                   : 4 5 6 7 8 9 10 11 12 13 14 15 16 30
sumadores            : 16
type                 : 23 32 37 38 55
while_pro            : 8

Parsing method: LALR

state 0

    (0) S' -> . init
    (1) init -> . instrucciones
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . sumadores sc
    (56) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (34) declaration_instruction -> . LET declaracion_list
    (45) assig_pro -> . LITERAL IGUAL a
    (46) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (50) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (51) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (52) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (53) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (29) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (25) continue_pro -> . CONTINUE
    (26) break_pro -> . BREAK
    (27) return_pro -> . RETURN
    (28) return_pro -> . RETURN a
    (19) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (20) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (87) sumadores -> . LITERAL MAS MAS
    (88) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 17
    LET             shift and go to state 18
    LITERAL         shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    INTERFACE       shift and go to state 23
    CONTINUE        shift and go to state 24
    BREAK           shift and go to state 25
    RETURN          shift and go to state 26
    FUNCTION        shift and go to state 27

    init                           shift and go to state 1
    instrucciones                  shift and go to state 2
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    sumadores                      shift and go to state 16

state 1

    (0) S' -> init .



state 2

    (1) init -> instrucciones .
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . sumadores sc
    (56) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (34) declaration_instruction -> . LET declaracion_list
    (45) assig_pro -> . LITERAL IGUAL a
    (46) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (50) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (51) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (52) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (53) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (29) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (25) continue_pro -> . CONTINUE
    (26) break_pro -> . BREAK
    (27) return_pro -> . RETURN
    (28) return_pro -> . RETURN a
    (19) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (20) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (87) sumadores -> . LITERAL MAS MAS
    (88) sumadores -> . LITERAL MENOS MENOS

    $end            reduce using rule 1 (init -> instrucciones .)
    CONSOLE         shift and go to state 17
    LET             shift and go to state 18
    LITERAL         shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    INTERFACE       shift and go to state 23
    CONTINUE        shift and go to state 24
    BREAK           shift and go to state 25
    RETURN          shift and go to state 26
    FUNCTION        shift and go to state 27

    instruccion                    shift and go to state 28
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    sumadores                      shift and go to state 16

state 3

    (3) instrucciones -> instruccion .

    CONSOLE         reduce using rule 3 (instrucciones -> instruccion .)
    LET             reduce using rule 3 (instrucciones -> instruccion .)
    LITERAL         reduce using rule 3 (instrucciones -> instruccion .)
    IF              reduce using rule 3 (instrucciones -> instruccion .)
    WHILE           reduce using rule 3 (instrucciones -> instruccion .)
    FOR             reduce using rule 3 (instrucciones -> instruccion .)
    INTERFACE       reduce using rule 3 (instrucciones -> instruccion .)
    CONTINUE        reduce using rule 3 (instrucciones -> instruccion .)
    BREAK           reduce using rule 3 (instrucciones -> instruccion .)
    RETURN          reduce using rule 3 (instrucciones -> instruccion .)
    FUNCTION        reduce using rule 3 (instrucciones -> instruccion .)
    $end            reduce using rule 3 (instrucciones -> instruccion .)
    R_LLAVE         reduce using rule 3 (instrucciones -> instruccion .)


state 4

    (4) instruccion -> console_pro . sc
    (17) sc -> . SEMI_COLON
    (18) sc -> .

    SEMI_COLON      shift and go to state 30
    CONSOLE         reduce using rule 18 (sc -> .)
    LET             reduce using rule 18 (sc -> .)
    LITERAL         reduce using rule 18 (sc -> .)
    IF              reduce using rule 18 (sc -> .)
    WHILE           reduce using rule 18 (sc -> .)
    FOR             reduce using rule 18 (sc -> .)
    INTERFACE       reduce using rule 18 (sc -> .)
    CONTINUE        reduce using rule 18 (sc -> .)
    BREAK           reduce using rule 18 (sc -> .)
    RETURN          reduce using rule 18 (sc -> .)
    FUNCTION        reduce using rule 18 (sc -> .)
    $end            reduce using rule 18 (sc -> .)
    R_LLAVE         reduce using rule 18 (sc -> .)

    sc                             shift and go to state 29

state 5

    (5) instruccion -> declaration_instruction . sc
    (17) sc -> . SEMI_COLON
    (18) sc -> .

    SEMI_COLON      shift and go to state 30
    CONSOLE         reduce using rule 18 (sc -> .)
    LET             reduce using rule 18 (sc -> .)
    LITERAL         reduce using rule 18 (sc -> .)
    IF              reduce using rule 18 (sc -> .)
    WHILE           reduce using rule 18 (sc -> .)
    FOR             reduce using rule 18 (sc -> .)
    INTERFACE       reduce using rule 18 (sc -> .)
    CONTINUE        reduce using rule 18 (sc -> .)
    BREAK           reduce using rule 18 (sc -> .)
    RETURN          reduce using rule 18 (sc -> .)
    FUNCTION        reduce using rule 18 (sc -> .)
    $end            reduce using rule 18 (sc -> .)
    R_LLAVE         reduce using rule 18 (sc -> .)

    sc                             shift and go to state 31

state 6

    (6) instruccion -> assig_pro . sc
    (17) sc -> . SEMI_COLON
    (18) sc -> .

    SEMI_COLON      shift and go to state 30
    CONSOLE         reduce using rule 18 (sc -> .)
    LET             reduce using rule 18 (sc -> .)
    LITERAL         reduce using rule 18 (sc -> .)
    IF              reduce using rule 18 (sc -> .)
    WHILE           reduce using rule 18 (sc -> .)
    FOR             reduce using rule 18 (sc -> .)
    INTERFACE       reduce using rule 18 (sc -> .)
    CONTINUE        reduce using rule 18 (sc -> .)
    BREAK           reduce using rule 18 (sc -> .)
    RETURN          reduce using rule 18 (sc -> .)
    FUNCTION        reduce using rule 18 (sc -> .)
    $end            reduce using rule 18 (sc -> .)
    R_LLAVE         reduce using rule 18 (sc -> .)

    sc                             shift and go to state 32

state 7

    (7) instruccion -> if_pro . sc
    (17) sc -> . SEMI_COLON
    (18) sc -> .

    SEMI_COLON      shift and go to state 30
    CONSOLE         reduce using rule 18 (sc -> .)
    LET             reduce using rule 18 (sc -> .)
    LITERAL         reduce using rule 18 (sc -> .)
    IF              reduce using rule 18 (sc -> .)
    WHILE           reduce using rule 18 (sc -> .)
    FOR             reduce using rule 18 (sc -> .)
    INTERFACE       reduce using rule 18 (sc -> .)
    CONTINUE        reduce using rule 18 (sc -> .)
    BREAK           reduce using rule 18 (sc -> .)
    RETURN          reduce using rule 18 (sc -> .)
    FUNCTION        reduce using rule 18 (sc -> .)
    $end            reduce using rule 18 (sc -> .)
    R_LLAVE         reduce using rule 18 (sc -> .)

    sc                             shift and go to state 33

state 8

    (8) instruccion -> while_pro . sc
    (17) sc -> . SEMI_COLON
    (18) sc -> .

    SEMI_COLON      shift and go to state 30
    CONSOLE         reduce using rule 18 (sc -> .)
    LET             reduce using rule 18 (sc -> .)
    LITERAL         reduce using rule 18 (sc -> .)
    IF              reduce using rule 18 (sc -> .)
    WHILE           reduce using rule 18 (sc -> .)
    FOR             reduce using rule 18 (sc -> .)
    INTERFACE       reduce using rule 18 (sc -> .)
    CONTINUE        reduce using rule 18 (sc -> .)
    BREAK           reduce using rule 18 (sc -> .)
    RETURN          reduce using rule 18 (sc -> .)
    FUNCTION        reduce using rule 18 (sc -> .)
    $end            reduce using rule 18 (sc -> .)
    R_LLAVE         reduce using rule 18 (sc -> .)

    sc                             shift and go to state 34

state 9

    (9) instruccion -> for_pro . sc
    (17) sc -> . SEMI_COLON
    (18) sc -> .

    SEMI_COLON      shift and go to state 30
    CONSOLE         reduce using rule 18 (sc -> .)
    LET             reduce using rule 18 (sc -> .)
    LITERAL         reduce using rule 18 (sc -> .)
    IF              reduce using rule 18 (sc -> .)
    WHILE           reduce using rule 18 (sc -> .)
    FOR             reduce using rule 18 (sc -> .)
    INTERFACE       reduce using rule 18 (sc -> .)
    CONTINUE        reduce using rule 18 (sc -> .)
    BREAK           reduce using rule 18 (sc -> .)
    RETURN          reduce using rule 18 (sc -> .)
    FUNCTION        reduce using rule 18 (sc -> .)
    $end            reduce using rule 18 (sc -> .)
    R_LLAVE         reduce using rule 18 (sc -> .)

    sc                             shift and go to state 35

state 10

    (10) instruccion -> for_each_pro . sc
    (17) sc -> . SEMI_COLON
    (18) sc -> .

    SEMI_COLON      shift and go to state 30
    CONSOLE         reduce using rule 18 (sc -> .)
    LET             reduce using rule 18 (sc -> .)
    LITERAL         reduce using rule 18 (sc -> .)
    IF              reduce using rule 18 (sc -> .)
    WHILE           reduce using rule 18 (sc -> .)
    FOR             reduce using rule 18 (sc -> .)
    INTERFACE       reduce using rule 18 (sc -> .)
    CONTINUE        reduce using rule 18 (sc -> .)
    BREAK           reduce using rule 18 (sc -> .)
    RETURN          reduce using rule 18 (sc -> .)
    FUNCTION        reduce using rule 18 (sc -> .)
    $end            reduce using rule 18 (sc -> .)
    R_LLAVE         reduce using rule 18 (sc -> .)

    sc                             shift and go to state 36

state 11

    (11) instruccion -> interface_pro . sc
    (17) sc -> . SEMI_COLON
    (18) sc -> .

    SEMI_COLON      shift and go to state 30
    CONSOLE         reduce using rule 18 (sc -> .)
    LET             reduce using rule 18 (sc -> .)
    LITERAL         reduce using rule 18 (sc -> .)
    IF              reduce using rule 18 (sc -> .)
    WHILE           reduce using rule 18 (sc -> .)
    FOR             reduce using rule 18 (sc -> .)
    INTERFACE       reduce using rule 18 (sc -> .)
    CONTINUE        reduce using rule 18 (sc -> .)
    BREAK           reduce using rule 18 (sc -> .)
    RETURN          reduce using rule 18 (sc -> .)
    FUNCTION        reduce using rule 18 (sc -> .)
    $end            reduce using rule 18 (sc -> .)
    R_LLAVE         reduce using rule 18 (sc -> .)

    sc                             shift and go to state 37

state 12

    (12) instruccion -> continue_pro . sc
    (17) sc -> . SEMI_COLON
    (18) sc -> .

    SEMI_COLON      shift and go to state 30
    CONSOLE         reduce using rule 18 (sc -> .)
    LET             reduce using rule 18 (sc -> .)
    LITERAL         reduce using rule 18 (sc -> .)
    IF              reduce using rule 18 (sc -> .)
    WHILE           reduce using rule 18 (sc -> .)
    FOR             reduce using rule 18 (sc -> .)
    INTERFACE       reduce using rule 18 (sc -> .)
    CONTINUE        reduce using rule 18 (sc -> .)
    BREAK           reduce using rule 18 (sc -> .)
    RETURN          reduce using rule 18 (sc -> .)
    FUNCTION        reduce using rule 18 (sc -> .)
    $end            reduce using rule 18 (sc -> .)
    R_LLAVE         reduce using rule 18 (sc -> .)

    sc                             shift and go to state 38

state 13

    (13) instruccion -> break_pro . sc
    (17) sc -> . SEMI_COLON
    (18) sc -> .

    SEMI_COLON      shift and go to state 30
    CONSOLE         reduce using rule 18 (sc -> .)
    LET             reduce using rule 18 (sc -> .)
    LITERAL         reduce using rule 18 (sc -> .)
    IF              reduce using rule 18 (sc -> .)
    WHILE           reduce using rule 18 (sc -> .)
    FOR             reduce using rule 18 (sc -> .)
    INTERFACE       reduce using rule 18 (sc -> .)
    CONTINUE        reduce using rule 18 (sc -> .)
    BREAK           reduce using rule 18 (sc -> .)
    RETURN          reduce using rule 18 (sc -> .)
    FUNCTION        reduce using rule 18 (sc -> .)
    $end            reduce using rule 18 (sc -> .)
    R_LLAVE         reduce using rule 18 (sc -> .)

    sc                             shift and go to state 39

state 14

    (14) instruccion -> return_pro . sc
    (17) sc -> . SEMI_COLON
    (18) sc -> .

    SEMI_COLON      shift and go to state 30
    CONSOLE         reduce using rule 18 (sc -> .)
    LET             reduce using rule 18 (sc -> .)
    LITERAL         reduce using rule 18 (sc -> .)
    IF              reduce using rule 18 (sc -> .)
    WHILE           reduce using rule 18 (sc -> .)
    FOR             reduce using rule 18 (sc -> .)
    INTERFACE       reduce using rule 18 (sc -> .)
    CONTINUE        reduce using rule 18 (sc -> .)
    BREAK           reduce using rule 18 (sc -> .)
    RETURN          reduce using rule 18 (sc -> .)
    FUNCTION        reduce using rule 18 (sc -> .)
    $end            reduce using rule 18 (sc -> .)
    R_LLAVE         reduce using rule 18 (sc -> .)

    sc                             shift and go to state 40

state 15

    (15) instruccion -> function_pro . sc
    (17) sc -> . SEMI_COLON
    (18) sc -> .

    SEMI_COLON      shift and go to state 30
    CONSOLE         reduce using rule 18 (sc -> .)
    LET             reduce using rule 18 (sc -> .)
    LITERAL         reduce using rule 18 (sc -> .)
    IF              reduce using rule 18 (sc -> .)
    WHILE           reduce using rule 18 (sc -> .)
    FOR             reduce using rule 18 (sc -> .)
    INTERFACE       reduce using rule 18 (sc -> .)
    CONTINUE        reduce using rule 18 (sc -> .)
    BREAK           reduce using rule 18 (sc -> .)
    RETURN          reduce using rule 18 (sc -> .)
    FUNCTION        reduce using rule 18 (sc -> .)
    $end            reduce using rule 18 (sc -> .)
    R_LLAVE         reduce using rule 18 (sc -> .)

    sc                             shift and go to state 41

state 16

    (16) instruccion -> sumadores . sc
    (17) sc -> . SEMI_COLON
    (18) sc -> .

    SEMI_COLON      shift and go to state 30
    CONSOLE         reduce using rule 18 (sc -> .)
    LET             reduce using rule 18 (sc -> .)
    LITERAL         reduce using rule 18 (sc -> .)
    IF              reduce using rule 18 (sc -> .)
    WHILE           reduce using rule 18 (sc -> .)
    FOR             reduce using rule 18 (sc -> .)
    INTERFACE       reduce using rule 18 (sc -> .)
    CONTINUE        reduce using rule 18 (sc -> .)
    BREAK           reduce using rule 18 (sc -> .)
    RETURN          reduce using rule 18 (sc -> .)
    FUNCTION        reduce using rule 18 (sc -> .)
    $end            reduce using rule 18 (sc -> .)
    R_LLAVE         reduce using rule 18 (sc -> .)

    sc                             shift and go to state 42

state 17

    (56) console_pro -> CONSOLE . PUNTO LOG L_PAREN expresion R_PAREN

    PUNTO           shift and go to state 43


state 18

    (34) declaration_instruction -> LET . declaracion_list
    (35) declaracion_list -> . declaracion_list COMA assignacion_instruction
    (36) declaracion_list -> . assignacion_instruction
    (37) assignacion_instruction -> . LITERAL COLON type IGUAL a
    (38) assignacion_instruction -> . LITERAL COLON type
    (39) assignacion_instruction -> . LITERAL IGUAL a

    LITERAL         shift and go to state 46

    declaracion_list               shift and go to state 44
    assignacion_instruction        shift and go to state 45

state 19

    (45) assig_pro -> LITERAL . IGUAL a
    (87) sumadores -> LITERAL . MAS MAS
    (88) sumadores -> LITERAL . MENOS MENOS

    IGUAL           shift and go to state 47
    MAS             shift and go to state 48
    MENOS           shift and go to state 49


state 20

    (46) if_pro -> IF . L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro

    L_PAREN         shift and go to state 50


state 21

    (50) while_pro -> WHILE . L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE

    L_PAREN         shift and go to state 51


state 22

    (51) for_pro -> FOR . L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (52) for_pro -> FOR . L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (53) for_each_pro -> FOR . L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE

    L_PAREN         shift and go to state 52


state 23

    (29) interface_pro -> INTERFACE . LITERAL L_LLAVE interface_atributos R_LLAVE

    LITERAL         shift and go to state 53


state 24

    (25) continue_pro -> CONTINUE .

    SEMI_COLON      reduce using rule 25 (continue_pro -> CONTINUE .)
    CONSOLE         reduce using rule 25 (continue_pro -> CONTINUE .)
    LET             reduce using rule 25 (continue_pro -> CONTINUE .)
    LITERAL         reduce using rule 25 (continue_pro -> CONTINUE .)
    IF              reduce using rule 25 (continue_pro -> CONTINUE .)
    WHILE           reduce using rule 25 (continue_pro -> CONTINUE .)
    FOR             reduce using rule 25 (continue_pro -> CONTINUE .)
    INTERFACE       reduce using rule 25 (continue_pro -> CONTINUE .)
    CONTINUE        reduce using rule 25 (continue_pro -> CONTINUE .)
    BREAK           reduce using rule 25 (continue_pro -> CONTINUE .)
    RETURN          reduce using rule 25 (continue_pro -> CONTINUE .)
    FUNCTION        reduce using rule 25 (continue_pro -> CONTINUE .)
    $end            reduce using rule 25 (continue_pro -> CONTINUE .)
    R_LLAVE         reduce using rule 25 (continue_pro -> CONTINUE .)


state 25

    (26) break_pro -> BREAK .

    SEMI_COLON      reduce using rule 26 (break_pro -> BREAK .)
    CONSOLE         reduce using rule 26 (break_pro -> BREAK .)
    LET             reduce using rule 26 (break_pro -> BREAK .)
    LITERAL         reduce using rule 26 (break_pro -> BREAK .)
    IF              reduce using rule 26 (break_pro -> BREAK .)
    WHILE           reduce using rule 26 (break_pro -> BREAK .)
    FOR             reduce using rule 26 (break_pro -> BREAK .)
    INTERFACE       reduce using rule 26 (break_pro -> BREAK .)
    CONTINUE        reduce using rule 26 (break_pro -> BREAK .)
    BREAK           reduce using rule 26 (break_pro -> BREAK .)
    RETURN          reduce using rule 26 (break_pro -> BREAK .)
    FUNCTION        reduce using rule 26 (break_pro -> BREAK .)
    $end            reduce using rule 26 (break_pro -> BREAK .)
    R_LLAVE         reduce using rule 26 (break_pro -> BREAK .)


state 26

    (27) return_pro -> RETURN .
    (28) return_pro -> RETURN . a
    (59) a -> . a OR b
    (60) a -> . b
    (61) b -> . b AND c
    (62) b -> . c
    (63) c -> . NOT d
    (64) c -> . d
    (65) d -> . d DISTINTO_QUE e
    (66) d -> . d MENOR_QUE e
    (67) d -> . d MENOR_IGUAL_QUE e
    (68) d -> . d MAYOR_QUE e
    (69) d -> . d MAYOR_IGUAL_QUE e
    (70) d -> . d TRIPLE_IGUAL e
    (71) d -> . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

  ! shift/reduce conflict for LITERAL resolved as shift
    SEMI_COLON      reduce using rule 27 (return_pro -> RETURN .)
    CONSOLE         reduce using rule 27 (return_pro -> RETURN .)
    LET             reduce using rule 27 (return_pro -> RETURN .)
    IF              reduce using rule 27 (return_pro -> RETURN .)
    WHILE           reduce using rule 27 (return_pro -> RETURN .)
    FOR             reduce using rule 27 (return_pro -> RETURN .)
    INTERFACE       reduce using rule 27 (return_pro -> RETURN .)
    CONTINUE        reduce using rule 27 (return_pro -> RETURN .)
    BREAK           reduce using rule 27 (return_pro -> RETURN .)
    RETURN          reduce using rule 27 (return_pro -> RETURN .)
    FUNCTION        reduce using rule 27 (return_pro -> RETURN .)
    $end            reduce using rule 27 (return_pro -> RETURN .)
    R_LLAVE         reduce using rule 27 (return_pro -> RETURN .)
    NOT             shift and go to state 57
    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

  ! LITERAL         [ reduce using rule 27 (return_pro -> RETURN .) ]

    a                              shift and go to state 54
    b                              shift and go to state 55
    c                              shift and go to state 56
    d                              shift and go to state 58
    e                              shift and go to state 59
    f                              shift and go to state 60
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 27

    (19) function_pro -> FUNCTION . LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (20) function_pro -> FUNCTION . LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE

    LITERAL         shift and go to state 69


state 28

    (2) instrucciones -> instrucciones instruccion .

    CONSOLE         reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    LET             reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    LITERAL         reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    IF              reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    WHILE           reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    FOR             reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    INTERFACE       reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    CONTINUE        reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    BREAK           reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    RETURN          reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    FUNCTION        reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    $end            reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    R_LLAVE         reduce using rule 2 (instrucciones -> instrucciones instruccion .)


state 29

    (4) instruccion -> console_pro sc .

    CONSOLE         reduce using rule 4 (instruccion -> console_pro sc .)
    LET             reduce using rule 4 (instruccion -> console_pro sc .)
    LITERAL         reduce using rule 4 (instruccion -> console_pro sc .)
    IF              reduce using rule 4 (instruccion -> console_pro sc .)
    WHILE           reduce using rule 4 (instruccion -> console_pro sc .)
    FOR             reduce using rule 4 (instruccion -> console_pro sc .)
    INTERFACE       reduce using rule 4 (instruccion -> console_pro sc .)
    CONTINUE        reduce using rule 4 (instruccion -> console_pro sc .)
    BREAK           reduce using rule 4 (instruccion -> console_pro sc .)
    RETURN          reduce using rule 4 (instruccion -> console_pro sc .)
    FUNCTION        reduce using rule 4 (instruccion -> console_pro sc .)
    $end            reduce using rule 4 (instruccion -> console_pro sc .)
    R_LLAVE         reduce using rule 4 (instruccion -> console_pro sc .)


state 30

    (17) sc -> SEMI_COLON .

    CONSOLE         reduce using rule 17 (sc -> SEMI_COLON .)
    LET             reduce using rule 17 (sc -> SEMI_COLON .)
    LITERAL         reduce using rule 17 (sc -> SEMI_COLON .)
    IF              reduce using rule 17 (sc -> SEMI_COLON .)
    WHILE           reduce using rule 17 (sc -> SEMI_COLON .)
    FOR             reduce using rule 17 (sc -> SEMI_COLON .)
    INTERFACE       reduce using rule 17 (sc -> SEMI_COLON .)
    CONTINUE        reduce using rule 17 (sc -> SEMI_COLON .)
    BREAK           reduce using rule 17 (sc -> SEMI_COLON .)
    RETURN          reduce using rule 17 (sc -> SEMI_COLON .)
    FUNCTION        reduce using rule 17 (sc -> SEMI_COLON .)
    $end            reduce using rule 17 (sc -> SEMI_COLON .)
    R_LLAVE         reduce using rule 17 (sc -> SEMI_COLON .)


state 31

    (5) instruccion -> declaration_instruction sc .

    CONSOLE         reduce using rule 5 (instruccion -> declaration_instruction sc .)
    LET             reduce using rule 5 (instruccion -> declaration_instruction sc .)
    LITERAL         reduce using rule 5 (instruccion -> declaration_instruction sc .)
    IF              reduce using rule 5 (instruccion -> declaration_instruction sc .)
    WHILE           reduce using rule 5 (instruccion -> declaration_instruction sc .)
    FOR             reduce using rule 5 (instruccion -> declaration_instruction sc .)
    INTERFACE       reduce using rule 5 (instruccion -> declaration_instruction sc .)
    CONTINUE        reduce using rule 5 (instruccion -> declaration_instruction sc .)
    BREAK           reduce using rule 5 (instruccion -> declaration_instruction sc .)
    RETURN          reduce using rule 5 (instruccion -> declaration_instruction sc .)
    FUNCTION        reduce using rule 5 (instruccion -> declaration_instruction sc .)
    $end            reduce using rule 5 (instruccion -> declaration_instruction sc .)
    R_LLAVE         reduce using rule 5 (instruccion -> declaration_instruction sc .)


state 32

    (6) instruccion -> assig_pro sc .

    CONSOLE         reduce using rule 6 (instruccion -> assig_pro sc .)
    LET             reduce using rule 6 (instruccion -> assig_pro sc .)
    LITERAL         reduce using rule 6 (instruccion -> assig_pro sc .)
    IF              reduce using rule 6 (instruccion -> assig_pro sc .)
    WHILE           reduce using rule 6 (instruccion -> assig_pro sc .)
    FOR             reduce using rule 6 (instruccion -> assig_pro sc .)
    INTERFACE       reduce using rule 6 (instruccion -> assig_pro sc .)
    CONTINUE        reduce using rule 6 (instruccion -> assig_pro sc .)
    BREAK           reduce using rule 6 (instruccion -> assig_pro sc .)
    RETURN          reduce using rule 6 (instruccion -> assig_pro sc .)
    FUNCTION        reduce using rule 6 (instruccion -> assig_pro sc .)
    $end            reduce using rule 6 (instruccion -> assig_pro sc .)
    R_LLAVE         reduce using rule 6 (instruccion -> assig_pro sc .)


state 33

    (7) instruccion -> if_pro sc .

    CONSOLE         reduce using rule 7 (instruccion -> if_pro sc .)
    LET             reduce using rule 7 (instruccion -> if_pro sc .)
    LITERAL         reduce using rule 7 (instruccion -> if_pro sc .)
    IF              reduce using rule 7 (instruccion -> if_pro sc .)
    WHILE           reduce using rule 7 (instruccion -> if_pro sc .)
    FOR             reduce using rule 7 (instruccion -> if_pro sc .)
    INTERFACE       reduce using rule 7 (instruccion -> if_pro sc .)
    CONTINUE        reduce using rule 7 (instruccion -> if_pro sc .)
    BREAK           reduce using rule 7 (instruccion -> if_pro sc .)
    RETURN          reduce using rule 7 (instruccion -> if_pro sc .)
    FUNCTION        reduce using rule 7 (instruccion -> if_pro sc .)
    $end            reduce using rule 7 (instruccion -> if_pro sc .)
    R_LLAVE         reduce using rule 7 (instruccion -> if_pro sc .)


state 34

    (8) instruccion -> while_pro sc .

    CONSOLE         reduce using rule 8 (instruccion -> while_pro sc .)
    LET             reduce using rule 8 (instruccion -> while_pro sc .)
    LITERAL         reduce using rule 8 (instruccion -> while_pro sc .)
    IF              reduce using rule 8 (instruccion -> while_pro sc .)
    WHILE           reduce using rule 8 (instruccion -> while_pro sc .)
    FOR             reduce using rule 8 (instruccion -> while_pro sc .)
    INTERFACE       reduce using rule 8 (instruccion -> while_pro sc .)
    CONTINUE        reduce using rule 8 (instruccion -> while_pro sc .)
    BREAK           reduce using rule 8 (instruccion -> while_pro sc .)
    RETURN          reduce using rule 8 (instruccion -> while_pro sc .)
    FUNCTION        reduce using rule 8 (instruccion -> while_pro sc .)
    $end            reduce using rule 8 (instruccion -> while_pro sc .)
    R_LLAVE         reduce using rule 8 (instruccion -> while_pro sc .)


state 35

    (9) instruccion -> for_pro sc .

    CONSOLE         reduce using rule 9 (instruccion -> for_pro sc .)
    LET             reduce using rule 9 (instruccion -> for_pro sc .)
    LITERAL         reduce using rule 9 (instruccion -> for_pro sc .)
    IF              reduce using rule 9 (instruccion -> for_pro sc .)
    WHILE           reduce using rule 9 (instruccion -> for_pro sc .)
    FOR             reduce using rule 9 (instruccion -> for_pro sc .)
    INTERFACE       reduce using rule 9 (instruccion -> for_pro sc .)
    CONTINUE        reduce using rule 9 (instruccion -> for_pro sc .)
    BREAK           reduce using rule 9 (instruccion -> for_pro sc .)
    RETURN          reduce using rule 9 (instruccion -> for_pro sc .)
    FUNCTION        reduce using rule 9 (instruccion -> for_pro sc .)
    $end            reduce using rule 9 (instruccion -> for_pro sc .)
    R_LLAVE         reduce using rule 9 (instruccion -> for_pro sc .)


state 36

    (10) instruccion -> for_each_pro sc .

    CONSOLE         reduce using rule 10 (instruccion -> for_each_pro sc .)
    LET             reduce using rule 10 (instruccion -> for_each_pro sc .)
    LITERAL         reduce using rule 10 (instruccion -> for_each_pro sc .)
    IF              reduce using rule 10 (instruccion -> for_each_pro sc .)
    WHILE           reduce using rule 10 (instruccion -> for_each_pro sc .)
    FOR             reduce using rule 10 (instruccion -> for_each_pro sc .)
    INTERFACE       reduce using rule 10 (instruccion -> for_each_pro sc .)
    CONTINUE        reduce using rule 10 (instruccion -> for_each_pro sc .)
    BREAK           reduce using rule 10 (instruccion -> for_each_pro sc .)
    RETURN          reduce using rule 10 (instruccion -> for_each_pro sc .)
    FUNCTION        reduce using rule 10 (instruccion -> for_each_pro sc .)
    $end            reduce using rule 10 (instruccion -> for_each_pro sc .)
    R_LLAVE         reduce using rule 10 (instruccion -> for_each_pro sc .)


state 37

    (11) instruccion -> interface_pro sc .

    CONSOLE         reduce using rule 11 (instruccion -> interface_pro sc .)
    LET             reduce using rule 11 (instruccion -> interface_pro sc .)
    LITERAL         reduce using rule 11 (instruccion -> interface_pro sc .)
    IF              reduce using rule 11 (instruccion -> interface_pro sc .)
    WHILE           reduce using rule 11 (instruccion -> interface_pro sc .)
    FOR             reduce using rule 11 (instruccion -> interface_pro sc .)
    INTERFACE       reduce using rule 11 (instruccion -> interface_pro sc .)
    CONTINUE        reduce using rule 11 (instruccion -> interface_pro sc .)
    BREAK           reduce using rule 11 (instruccion -> interface_pro sc .)
    RETURN          reduce using rule 11 (instruccion -> interface_pro sc .)
    FUNCTION        reduce using rule 11 (instruccion -> interface_pro sc .)
    $end            reduce using rule 11 (instruccion -> interface_pro sc .)
    R_LLAVE         reduce using rule 11 (instruccion -> interface_pro sc .)


state 38

    (12) instruccion -> continue_pro sc .

    CONSOLE         reduce using rule 12 (instruccion -> continue_pro sc .)
    LET             reduce using rule 12 (instruccion -> continue_pro sc .)
    LITERAL         reduce using rule 12 (instruccion -> continue_pro sc .)
    IF              reduce using rule 12 (instruccion -> continue_pro sc .)
    WHILE           reduce using rule 12 (instruccion -> continue_pro sc .)
    FOR             reduce using rule 12 (instruccion -> continue_pro sc .)
    INTERFACE       reduce using rule 12 (instruccion -> continue_pro sc .)
    CONTINUE        reduce using rule 12 (instruccion -> continue_pro sc .)
    BREAK           reduce using rule 12 (instruccion -> continue_pro sc .)
    RETURN          reduce using rule 12 (instruccion -> continue_pro sc .)
    FUNCTION        reduce using rule 12 (instruccion -> continue_pro sc .)
    $end            reduce using rule 12 (instruccion -> continue_pro sc .)
    R_LLAVE         reduce using rule 12 (instruccion -> continue_pro sc .)


state 39

    (13) instruccion -> break_pro sc .

    CONSOLE         reduce using rule 13 (instruccion -> break_pro sc .)
    LET             reduce using rule 13 (instruccion -> break_pro sc .)
    LITERAL         reduce using rule 13 (instruccion -> break_pro sc .)
    IF              reduce using rule 13 (instruccion -> break_pro sc .)
    WHILE           reduce using rule 13 (instruccion -> break_pro sc .)
    FOR             reduce using rule 13 (instruccion -> break_pro sc .)
    INTERFACE       reduce using rule 13 (instruccion -> break_pro sc .)
    CONTINUE        reduce using rule 13 (instruccion -> break_pro sc .)
    BREAK           reduce using rule 13 (instruccion -> break_pro sc .)
    RETURN          reduce using rule 13 (instruccion -> break_pro sc .)
    FUNCTION        reduce using rule 13 (instruccion -> break_pro sc .)
    $end            reduce using rule 13 (instruccion -> break_pro sc .)
    R_LLAVE         reduce using rule 13 (instruccion -> break_pro sc .)


state 40

    (14) instruccion -> return_pro sc .

    CONSOLE         reduce using rule 14 (instruccion -> return_pro sc .)
    LET             reduce using rule 14 (instruccion -> return_pro sc .)
    LITERAL         reduce using rule 14 (instruccion -> return_pro sc .)
    IF              reduce using rule 14 (instruccion -> return_pro sc .)
    WHILE           reduce using rule 14 (instruccion -> return_pro sc .)
    FOR             reduce using rule 14 (instruccion -> return_pro sc .)
    INTERFACE       reduce using rule 14 (instruccion -> return_pro sc .)
    CONTINUE        reduce using rule 14 (instruccion -> return_pro sc .)
    BREAK           reduce using rule 14 (instruccion -> return_pro sc .)
    RETURN          reduce using rule 14 (instruccion -> return_pro sc .)
    FUNCTION        reduce using rule 14 (instruccion -> return_pro sc .)
    $end            reduce using rule 14 (instruccion -> return_pro sc .)
    R_LLAVE         reduce using rule 14 (instruccion -> return_pro sc .)


state 41

    (15) instruccion -> function_pro sc .

    CONSOLE         reduce using rule 15 (instruccion -> function_pro sc .)
    LET             reduce using rule 15 (instruccion -> function_pro sc .)
    LITERAL         reduce using rule 15 (instruccion -> function_pro sc .)
    IF              reduce using rule 15 (instruccion -> function_pro sc .)
    WHILE           reduce using rule 15 (instruccion -> function_pro sc .)
    FOR             reduce using rule 15 (instruccion -> function_pro sc .)
    INTERFACE       reduce using rule 15 (instruccion -> function_pro sc .)
    CONTINUE        reduce using rule 15 (instruccion -> function_pro sc .)
    BREAK           reduce using rule 15 (instruccion -> function_pro sc .)
    RETURN          reduce using rule 15 (instruccion -> function_pro sc .)
    FUNCTION        reduce using rule 15 (instruccion -> function_pro sc .)
    $end            reduce using rule 15 (instruccion -> function_pro sc .)
    R_LLAVE         reduce using rule 15 (instruccion -> function_pro sc .)


state 42

    (16) instruccion -> sumadores sc .

    CONSOLE         reduce using rule 16 (instruccion -> sumadores sc .)
    LET             reduce using rule 16 (instruccion -> sumadores sc .)
    LITERAL         reduce using rule 16 (instruccion -> sumadores sc .)
    IF              reduce using rule 16 (instruccion -> sumadores sc .)
    WHILE           reduce using rule 16 (instruccion -> sumadores sc .)
    FOR             reduce using rule 16 (instruccion -> sumadores sc .)
    INTERFACE       reduce using rule 16 (instruccion -> sumadores sc .)
    CONTINUE        reduce using rule 16 (instruccion -> sumadores sc .)
    BREAK           reduce using rule 16 (instruccion -> sumadores sc .)
    RETURN          reduce using rule 16 (instruccion -> sumadores sc .)
    FUNCTION        reduce using rule 16 (instruccion -> sumadores sc .)
    $end            reduce using rule 16 (instruccion -> sumadores sc .)
    R_LLAVE         reduce using rule 16 (instruccion -> sumadores sc .)


state 43

    (56) console_pro -> CONSOLE PUNTO . LOG L_PAREN expresion R_PAREN

    LOG             shift and go to state 70


state 44

    (34) declaration_instruction -> LET declaracion_list .
    (35) declaracion_list -> declaracion_list . COMA assignacion_instruction

    SEMI_COLON      reduce using rule 34 (declaration_instruction -> LET declaracion_list .)
    CONSOLE         reduce using rule 34 (declaration_instruction -> LET declaracion_list .)
    LET             reduce using rule 34 (declaration_instruction -> LET declaracion_list .)
    LITERAL         reduce using rule 34 (declaration_instruction -> LET declaracion_list .)
    IF              reduce using rule 34 (declaration_instruction -> LET declaracion_list .)
    WHILE           reduce using rule 34 (declaration_instruction -> LET declaracion_list .)
    FOR             reduce using rule 34 (declaration_instruction -> LET declaracion_list .)
    INTERFACE       reduce using rule 34 (declaration_instruction -> LET declaracion_list .)
    CONTINUE        reduce using rule 34 (declaration_instruction -> LET declaracion_list .)
    BREAK           reduce using rule 34 (declaration_instruction -> LET declaracion_list .)
    RETURN          reduce using rule 34 (declaration_instruction -> LET declaracion_list .)
    FUNCTION        reduce using rule 34 (declaration_instruction -> LET declaracion_list .)
    $end            reduce using rule 34 (declaration_instruction -> LET declaracion_list .)
    R_LLAVE         reduce using rule 34 (declaration_instruction -> LET declaracion_list .)
    COMA            shift and go to state 71


state 45

    (36) declaracion_list -> assignacion_instruction .

    COMA            reduce using rule 36 (declaracion_list -> assignacion_instruction .)
    SEMI_COLON      reduce using rule 36 (declaracion_list -> assignacion_instruction .)
    CONSOLE         reduce using rule 36 (declaracion_list -> assignacion_instruction .)
    LET             reduce using rule 36 (declaracion_list -> assignacion_instruction .)
    LITERAL         reduce using rule 36 (declaracion_list -> assignacion_instruction .)
    IF              reduce using rule 36 (declaracion_list -> assignacion_instruction .)
    WHILE           reduce using rule 36 (declaracion_list -> assignacion_instruction .)
    FOR             reduce using rule 36 (declaracion_list -> assignacion_instruction .)
    INTERFACE       reduce using rule 36 (declaracion_list -> assignacion_instruction .)
    CONTINUE        reduce using rule 36 (declaracion_list -> assignacion_instruction .)
    BREAK           reduce using rule 36 (declaracion_list -> assignacion_instruction .)
    RETURN          reduce using rule 36 (declaracion_list -> assignacion_instruction .)
    FUNCTION        reduce using rule 36 (declaracion_list -> assignacion_instruction .)
    $end            reduce using rule 36 (declaracion_list -> assignacion_instruction .)
    R_LLAVE         reduce using rule 36 (declaracion_list -> assignacion_instruction .)


state 46

    (37) assignacion_instruction -> LITERAL . COLON type IGUAL a
    (38) assignacion_instruction -> LITERAL . COLON type
    (39) assignacion_instruction -> LITERAL . IGUAL a

    COLON           shift and go to state 72
    IGUAL           shift and go to state 73


state 47

    (45) assig_pro -> LITERAL IGUAL . a
    (59) a -> . a OR b
    (60) a -> . b
    (61) b -> . b AND c
    (62) b -> . c
    (63) c -> . NOT d
    (64) c -> . d
    (65) d -> . d DISTINTO_QUE e
    (66) d -> . d MENOR_QUE e
    (67) d -> . d MENOR_IGUAL_QUE e
    (68) d -> . d MAYOR_QUE e
    (69) d -> . d MAYOR_IGUAL_QUE e
    (70) d -> . d TRIPLE_IGUAL e
    (71) d -> . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 57
    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    a                              shift and go to state 74
    b                              shift and go to state 55
    c                              shift and go to state 56
    d                              shift and go to state 58
    e                              shift and go to state 59
    f                              shift and go to state 60
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 48

    (87) sumadores -> LITERAL MAS . MAS

    MAS             shift and go to state 75


state 49

    (88) sumadores -> LITERAL MENOS . MENOS

    MENOS           shift and go to state 76


state 50

    (46) if_pro -> IF L_PAREN . a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (59) a -> . a OR b
    (60) a -> . b
    (61) b -> . b AND c
    (62) b -> . c
    (63) c -> . NOT d
    (64) c -> . d
    (65) d -> . d DISTINTO_QUE e
    (66) d -> . d MENOR_QUE e
    (67) d -> . d MENOR_IGUAL_QUE e
    (68) d -> . d MAYOR_QUE e
    (69) d -> . d MAYOR_IGUAL_QUE e
    (70) d -> . d TRIPLE_IGUAL e
    (71) d -> . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 57
    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    a                              shift and go to state 77
    b                              shift and go to state 55
    c                              shift and go to state 56
    d                              shift and go to state 58
    e                              shift and go to state 59
    f                              shift and go to state 60
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 51

    (50) while_pro -> WHILE L_PAREN . a R_PAREN L_LLAVE instrucciones R_LLAVE
    (59) a -> . a OR b
    (60) a -> . b
    (61) b -> . b AND c
    (62) b -> . c
    (63) c -> . NOT d
    (64) c -> . d
    (65) d -> . d DISTINTO_QUE e
    (66) d -> . d MENOR_QUE e
    (67) d -> . d MENOR_IGUAL_QUE e
    (68) d -> . d MAYOR_QUE e
    (69) d -> . d MAYOR_IGUAL_QUE e
    (70) d -> . d TRIPLE_IGUAL e
    (71) d -> . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 57
    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    a                              shift and go to state 78
    b                              shift and go to state 55
    c                              shift and go to state 56
    d                              shift and go to state 58
    e                              shift and go to state 59
    f                              shift and go to state 60
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 52

    (51) for_pro -> FOR L_PAREN . declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (52) for_pro -> FOR L_PAREN . assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (53) for_each_pro -> FOR L_PAREN . for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (34) declaration_instruction -> . LET declaracion_list
    (45) assig_pro -> . LITERAL IGUAL a
    (54) for_each_dec -> . LET LITERAL OF a
    (55) for_each_dec -> . LET LITERAL COLON type OF a

    LET             shift and go to state 82
    LITERAL         shift and go to state 83

    declaration_instruction        shift and go to state 79
    assig_pro                      shift and go to state 80
    for_each_dec                   shift and go to state 81

state 53

    (29) interface_pro -> INTERFACE LITERAL . L_LLAVE interface_atributos R_LLAVE

    L_LLAVE         shift and go to state 84


state 54

    (28) return_pro -> RETURN a .
    (59) a -> a . OR b

    SEMI_COLON      reduce using rule 28 (return_pro -> RETURN a .)
    CONSOLE         reduce using rule 28 (return_pro -> RETURN a .)
    LET             reduce using rule 28 (return_pro -> RETURN a .)
    LITERAL         reduce using rule 28 (return_pro -> RETURN a .)
    IF              reduce using rule 28 (return_pro -> RETURN a .)
    WHILE           reduce using rule 28 (return_pro -> RETURN a .)
    FOR             reduce using rule 28 (return_pro -> RETURN a .)
    INTERFACE       reduce using rule 28 (return_pro -> RETURN a .)
    CONTINUE        reduce using rule 28 (return_pro -> RETURN a .)
    BREAK           reduce using rule 28 (return_pro -> RETURN a .)
    RETURN          reduce using rule 28 (return_pro -> RETURN a .)
    FUNCTION        reduce using rule 28 (return_pro -> RETURN a .)
    $end            reduce using rule 28 (return_pro -> RETURN a .)
    R_LLAVE         reduce using rule 28 (return_pro -> RETURN a .)
    OR              shift and go to state 85


state 55

    (60) a -> b .
    (61) b -> b . AND c

    OR              reduce using rule 60 (a -> b .)
    SEMI_COLON      reduce using rule 60 (a -> b .)
    CONSOLE         reduce using rule 60 (a -> b .)
    LET             reduce using rule 60 (a -> b .)
    LITERAL         reduce using rule 60 (a -> b .)
    IF              reduce using rule 60 (a -> b .)
    WHILE           reduce using rule 60 (a -> b .)
    FOR             reduce using rule 60 (a -> b .)
    INTERFACE       reduce using rule 60 (a -> b .)
    CONTINUE        reduce using rule 60 (a -> b .)
    BREAK           reduce using rule 60 (a -> b .)
    RETURN          reduce using rule 60 (a -> b .)
    FUNCTION        reduce using rule 60 (a -> b .)
    $end            reduce using rule 60 (a -> b .)
    R_LLAVE         reduce using rule 60 (a -> b .)
    R_PAREN         reduce using rule 60 (a -> b .)
    COMA            reduce using rule 60 (a -> b .)
    AND             shift and go to state 86


state 56

    (62) b -> c .

    AND             reduce using rule 62 (b -> c .)
    OR              reduce using rule 62 (b -> c .)
    SEMI_COLON      reduce using rule 62 (b -> c .)
    CONSOLE         reduce using rule 62 (b -> c .)
    LET             reduce using rule 62 (b -> c .)
    LITERAL         reduce using rule 62 (b -> c .)
    IF              reduce using rule 62 (b -> c .)
    WHILE           reduce using rule 62 (b -> c .)
    FOR             reduce using rule 62 (b -> c .)
    INTERFACE       reduce using rule 62 (b -> c .)
    CONTINUE        reduce using rule 62 (b -> c .)
    BREAK           reduce using rule 62 (b -> c .)
    RETURN          reduce using rule 62 (b -> c .)
    FUNCTION        reduce using rule 62 (b -> c .)
    $end            reduce using rule 62 (b -> c .)
    R_LLAVE         reduce using rule 62 (b -> c .)
    R_PAREN         reduce using rule 62 (b -> c .)
    COMA            reduce using rule 62 (b -> c .)


state 57

    (63) c -> NOT . d
    (65) d -> . d DISTINTO_QUE e
    (66) d -> . d MENOR_QUE e
    (67) d -> . d MENOR_IGUAL_QUE e
    (68) d -> . d MAYOR_QUE e
    (69) d -> . d MAYOR_IGUAL_QUE e
    (70) d -> . d TRIPLE_IGUAL e
    (71) d -> . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    d                              shift and go to state 87
    e                              shift and go to state 59
    f                              shift and go to state 60
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 58

    (64) c -> d .
    (65) d -> d . DISTINTO_QUE e
    (66) d -> d . MENOR_QUE e
    (67) d -> d . MENOR_IGUAL_QUE e
    (68) d -> d . MAYOR_QUE e
    (69) d -> d . MAYOR_IGUAL_QUE e
    (70) d -> d . TRIPLE_IGUAL e

    AND             reduce using rule 64 (c -> d .)
    OR              reduce using rule 64 (c -> d .)
    SEMI_COLON      reduce using rule 64 (c -> d .)
    CONSOLE         reduce using rule 64 (c -> d .)
    LET             reduce using rule 64 (c -> d .)
    LITERAL         reduce using rule 64 (c -> d .)
    IF              reduce using rule 64 (c -> d .)
    WHILE           reduce using rule 64 (c -> d .)
    FOR             reduce using rule 64 (c -> d .)
    INTERFACE       reduce using rule 64 (c -> d .)
    CONTINUE        reduce using rule 64 (c -> d .)
    BREAK           reduce using rule 64 (c -> d .)
    RETURN          reduce using rule 64 (c -> d .)
    FUNCTION        reduce using rule 64 (c -> d .)
    $end            reduce using rule 64 (c -> d .)
    R_LLAVE         reduce using rule 64 (c -> d .)
    R_PAREN         reduce using rule 64 (c -> d .)
    COMA            reduce using rule 64 (c -> d .)
    DISTINTO_QUE    shift and go to state 88
    MENOR_QUE       shift and go to state 89
    MENOR_IGUAL_QUE shift and go to state 90
    MAYOR_QUE       shift and go to state 91
    MAYOR_IGUAL_QUE shift and go to state 92
    TRIPLE_IGUAL    shift and go to state 93


state 59

    (71) d -> e .
    (72) e -> e . MAS f
    (73) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 71 (d -> e .)
    MENOR_QUE       reduce using rule 71 (d -> e .)
    MENOR_IGUAL_QUE reduce using rule 71 (d -> e .)
    MAYOR_QUE       reduce using rule 71 (d -> e .)
    MAYOR_IGUAL_QUE reduce using rule 71 (d -> e .)
    TRIPLE_IGUAL    reduce using rule 71 (d -> e .)
    AND             reduce using rule 71 (d -> e .)
    OR              reduce using rule 71 (d -> e .)
    SEMI_COLON      reduce using rule 71 (d -> e .)
    CONSOLE         reduce using rule 71 (d -> e .)
    LET             reduce using rule 71 (d -> e .)
    LITERAL         reduce using rule 71 (d -> e .)
    IF              reduce using rule 71 (d -> e .)
    WHILE           reduce using rule 71 (d -> e .)
    FOR             reduce using rule 71 (d -> e .)
    INTERFACE       reduce using rule 71 (d -> e .)
    CONTINUE        reduce using rule 71 (d -> e .)
    BREAK           reduce using rule 71 (d -> e .)
    RETURN          reduce using rule 71 (d -> e .)
    FUNCTION        reduce using rule 71 (d -> e .)
    $end            reduce using rule 71 (d -> e .)
    R_LLAVE         reduce using rule 71 (d -> e .)
    R_PAREN         reduce using rule 71 (d -> e .)
    COMA            reduce using rule 71 (d -> e .)
    MAS             shift and go to state 94
    MENOS           shift and go to state 95


state 60

    (74) e -> f .
    (75) f -> f . TIMES g
    (76) f -> f . DIVIDE g
    (77) f -> f . MOD g
    (78) f -> f . POTENCIA g

    MAS             reduce using rule 74 (e -> f .)
    MENOS           reduce using rule 74 (e -> f .)
    DISTINTO_QUE    reduce using rule 74 (e -> f .)
    MENOR_QUE       reduce using rule 74 (e -> f .)
    MENOR_IGUAL_QUE reduce using rule 74 (e -> f .)
    MAYOR_QUE       reduce using rule 74 (e -> f .)
    MAYOR_IGUAL_QUE reduce using rule 74 (e -> f .)
    TRIPLE_IGUAL    reduce using rule 74 (e -> f .)
    AND             reduce using rule 74 (e -> f .)
    OR              reduce using rule 74 (e -> f .)
    SEMI_COLON      reduce using rule 74 (e -> f .)
    CONSOLE         reduce using rule 74 (e -> f .)
    LET             reduce using rule 74 (e -> f .)
    LITERAL         reduce using rule 74 (e -> f .)
    IF              reduce using rule 74 (e -> f .)
    WHILE           reduce using rule 74 (e -> f .)
    FOR             reduce using rule 74 (e -> f .)
    INTERFACE       reduce using rule 74 (e -> f .)
    CONTINUE        reduce using rule 74 (e -> f .)
    BREAK           reduce using rule 74 (e -> f .)
    RETURN          reduce using rule 74 (e -> f .)
    FUNCTION        reduce using rule 74 (e -> f .)
    $end            reduce using rule 74 (e -> f .)
    R_LLAVE         reduce using rule 74 (e -> f .)
    R_PAREN         reduce using rule 74 (e -> f .)
    COMA            reduce using rule 74 (e -> f .)
    TIMES           shift and go to state 96
    DIVIDE          shift and go to state 97
    MOD             shift and go to state 98
    POTENCIA        shift and go to state 99


state 61

    (79) f -> g .
    (80) f -> g . PUNTO nativeFun L_PAREN expresion R_PAREN

    TIMES           reduce using rule 79 (f -> g .)
    DIVIDE          reduce using rule 79 (f -> g .)
    MOD             reduce using rule 79 (f -> g .)
    POTENCIA        reduce using rule 79 (f -> g .)
    MAS             reduce using rule 79 (f -> g .)
    MENOS           reduce using rule 79 (f -> g .)
    DISTINTO_QUE    reduce using rule 79 (f -> g .)
    MENOR_QUE       reduce using rule 79 (f -> g .)
    MENOR_IGUAL_QUE reduce using rule 79 (f -> g .)
    MAYOR_QUE       reduce using rule 79 (f -> g .)
    MAYOR_IGUAL_QUE reduce using rule 79 (f -> g .)
    TRIPLE_IGUAL    reduce using rule 79 (f -> g .)
    AND             reduce using rule 79 (f -> g .)
    OR              reduce using rule 79 (f -> g .)
    SEMI_COLON      reduce using rule 79 (f -> g .)
    CONSOLE         reduce using rule 79 (f -> g .)
    LET             reduce using rule 79 (f -> g .)
    LITERAL         reduce using rule 79 (f -> g .)
    IF              reduce using rule 79 (f -> g .)
    WHILE           reduce using rule 79 (f -> g .)
    FOR             reduce using rule 79 (f -> g .)
    INTERFACE       reduce using rule 79 (f -> g .)
    CONTINUE        reduce using rule 79 (f -> g .)
    BREAK           reduce using rule 79 (f -> g .)
    RETURN          reduce using rule 79 (f -> g .)
    FUNCTION        reduce using rule 79 (f -> g .)
    $end            reduce using rule 79 (f -> g .)
    R_LLAVE         reduce using rule 79 (f -> g .)
    R_PAREN         reduce using rule 79 (f -> g .)
    COMA            reduce using rule 79 (f -> g .)
    PUNTO           shift and go to state 100


state 62

    (86) g -> L_PAREN . a R_PAREN
    (59) a -> . a OR b
    (60) a -> . b
    (61) b -> . b AND c
    (62) b -> . c
    (63) c -> . NOT d
    (64) c -> . d
    (65) d -> . d DISTINTO_QUE e
    (66) d -> . d MENOR_QUE e
    (67) d -> . d MENOR_IGUAL_QUE e
    (68) d -> . d MAYOR_QUE e
    (69) d -> . d MAYOR_IGUAL_QUE e
    (70) d -> . d TRIPLE_IGUAL e
    (71) d -> . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 57
    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    a                              shift and go to state 101
    b                              shift and go to state 55
    c                              shift and go to state 56
    d                              shift and go to state 58
    e                              shift and go to state 59
    f                              shift and go to state 60
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 63

    (81) g -> ENTERO .

    PUNTO           reduce using rule 81 (g -> ENTERO .)
    TIMES           reduce using rule 81 (g -> ENTERO .)
    DIVIDE          reduce using rule 81 (g -> ENTERO .)
    MOD             reduce using rule 81 (g -> ENTERO .)
    POTENCIA        reduce using rule 81 (g -> ENTERO .)
    MAS             reduce using rule 81 (g -> ENTERO .)
    MENOS           reduce using rule 81 (g -> ENTERO .)
    DISTINTO_QUE    reduce using rule 81 (g -> ENTERO .)
    MENOR_QUE       reduce using rule 81 (g -> ENTERO .)
    MENOR_IGUAL_QUE reduce using rule 81 (g -> ENTERO .)
    MAYOR_QUE       reduce using rule 81 (g -> ENTERO .)
    MAYOR_IGUAL_QUE reduce using rule 81 (g -> ENTERO .)
    TRIPLE_IGUAL    reduce using rule 81 (g -> ENTERO .)
    AND             reduce using rule 81 (g -> ENTERO .)
    OR              reduce using rule 81 (g -> ENTERO .)
    SEMI_COLON      reduce using rule 81 (g -> ENTERO .)
    CONSOLE         reduce using rule 81 (g -> ENTERO .)
    LET             reduce using rule 81 (g -> ENTERO .)
    LITERAL         reduce using rule 81 (g -> ENTERO .)
    IF              reduce using rule 81 (g -> ENTERO .)
    WHILE           reduce using rule 81 (g -> ENTERO .)
    FOR             reduce using rule 81 (g -> ENTERO .)
    INTERFACE       reduce using rule 81 (g -> ENTERO .)
    CONTINUE        reduce using rule 81 (g -> ENTERO .)
    BREAK           reduce using rule 81 (g -> ENTERO .)
    RETURN          reduce using rule 81 (g -> ENTERO .)
    FUNCTION        reduce using rule 81 (g -> ENTERO .)
    $end            reduce using rule 81 (g -> ENTERO .)
    R_LLAVE         reduce using rule 81 (g -> ENTERO .)
    R_PAREN         reduce using rule 81 (g -> ENTERO .)
    COMA            reduce using rule 81 (g -> ENTERO .)


state 64

    (82) g -> DECIMAL .

    PUNTO           reduce using rule 82 (g -> DECIMAL .)
    TIMES           reduce using rule 82 (g -> DECIMAL .)
    DIVIDE          reduce using rule 82 (g -> DECIMAL .)
    MOD             reduce using rule 82 (g -> DECIMAL .)
    POTENCIA        reduce using rule 82 (g -> DECIMAL .)
    MAS             reduce using rule 82 (g -> DECIMAL .)
    MENOS           reduce using rule 82 (g -> DECIMAL .)
    DISTINTO_QUE    reduce using rule 82 (g -> DECIMAL .)
    MENOR_QUE       reduce using rule 82 (g -> DECIMAL .)
    MENOR_IGUAL_QUE reduce using rule 82 (g -> DECIMAL .)
    MAYOR_QUE       reduce using rule 82 (g -> DECIMAL .)
    MAYOR_IGUAL_QUE reduce using rule 82 (g -> DECIMAL .)
    TRIPLE_IGUAL    reduce using rule 82 (g -> DECIMAL .)
    AND             reduce using rule 82 (g -> DECIMAL .)
    OR              reduce using rule 82 (g -> DECIMAL .)
    SEMI_COLON      reduce using rule 82 (g -> DECIMAL .)
    CONSOLE         reduce using rule 82 (g -> DECIMAL .)
    LET             reduce using rule 82 (g -> DECIMAL .)
    LITERAL         reduce using rule 82 (g -> DECIMAL .)
    IF              reduce using rule 82 (g -> DECIMAL .)
    WHILE           reduce using rule 82 (g -> DECIMAL .)
    FOR             reduce using rule 82 (g -> DECIMAL .)
    INTERFACE       reduce using rule 82 (g -> DECIMAL .)
    CONTINUE        reduce using rule 82 (g -> DECIMAL .)
    BREAK           reduce using rule 82 (g -> DECIMAL .)
    RETURN          reduce using rule 82 (g -> DECIMAL .)
    FUNCTION        reduce using rule 82 (g -> DECIMAL .)
    $end            reduce using rule 82 (g -> DECIMAL .)
    R_LLAVE         reduce using rule 82 (g -> DECIMAL .)
    R_PAREN         reduce using rule 82 (g -> DECIMAL .)
    COMA            reduce using rule 82 (g -> DECIMAL .)


state 65

    (83) g -> CADENA .

    PUNTO           reduce using rule 83 (g -> CADENA .)
    TIMES           reduce using rule 83 (g -> CADENA .)
    DIVIDE          reduce using rule 83 (g -> CADENA .)
    MOD             reduce using rule 83 (g -> CADENA .)
    POTENCIA        reduce using rule 83 (g -> CADENA .)
    MAS             reduce using rule 83 (g -> CADENA .)
    MENOS           reduce using rule 83 (g -> CADENA .)
    DISTINTO_QUE    reduce using rule 83 (g -> CADENA .)
    MENOR_QUE       reduce using rule 83 (g -> CADENA .)
    MENOR_IGUAL_QUE reduce using rule 83 (g -> CADENA .)
    MAYOR_QUE       reduce using rule 83 (g -> CADENA .)
    MAYOR_IGUAL_QUE reduce using rule 83 (g -> CADENA .)
    TRIPLE_IGUAL    reduce using rule 83 (g -> CADENA .)
    AND             reduce using rule 83 (g -> CADENA .)
    OR              reduce using rule 83 (g -> CADENA .)
    SEMI_COLON      reduce using rule 83 (g -> CADENA .)
    CONSOLE         reduce using rule 83 (g -> CADENA .)
    LET             reduce using rule 83 (g -> CADENA .)
    LITERAL         reduce using rule 83 (g -> CADENA .)
    IF              reduce using rule 83 (g -> CADENA .)
    WHILE           reduce using rule 83 (g -> CADENA .)
    FOR             reduce using rule 83 (g -> CADENA .)
    INTERFACE       reduce using rule 83 (g -> CADENA .)
    CONTINUE        reduce using rule 83 (g -> CADENA .)
    BREAK           reduce using rule 83 (g -> CADENA .)
    RETURN          reduce using rule 83 (g -> CADENA .)
    FUNCTION        reduce using rule 83 (g -> CADENA .)
    $end            reduce using rule 83 (g -> CADENA .)
    R_LLAVE         reduce using rule 83 (g -> CADENA .)
    R_PAREN         reduce using rule 83 (g -> CADENA .)
    COMA            reduce using rule 83 (g -> CADENA .)


state 66

    (84) g -> LITERAL .

    PUNTO           reduce using rule 84 (g -> LITERAL .)
    TIMES           reduce using rule 84 (g -> LITERAL .)
    DIVIDE          reduce using rule 84 (g -> LITERAL .)
    MOD             reduce using rule 84 (g -> LITERAL .)
    POTENCIA        reduce using rule 84 (g -> LITERAL .)
    MAS             reduce using rule 84 (g -> LITERAL .)
    MENOS           reduce using rule 84 (g -> LITERAL .)
    DISTINTO_QUE    reduce using rule 84 (g -> LITERAL .)
    MENOR_QUE       reduce using rule 84 (g -> LITERAL .)
    MENOR_IGUAL_QUE reduce using rule 84 (g -> LITERAL .)
    MAYOR_QUE       reduce using rule 84 (g -> LITERAL .)
    MAYOR_IGUAL_QUE reduce using rule 84 (g -> LITERAL .)
    TRIPLE_IGUAL    reduce using rule 84 (g -> LITERAL .)
    AND             reduce using rule 84 (g -> LITERAL .)
    OR              reduce using rule 84 (g -> LITERAL .)
    SEMI_COLON      reduce using rule 84 (g -> LITERAL .)
    CONSOLE         reduce using rule 84 (g -> LITERAL .)
    LET             reduce using rule 84 (g -> LITERAL .)
    LITERAL         reduce using rule 84 (g -> LITERAL .)
    IF              reduce using rule 84 (g -> LITERAL .)
    WHILE           reduce using rule 84 (g -> LITERAL .)
    FOR             reduce using rule 84 (g -> LITERAL .)
    INTERFACE       reduce using rule 84 (g -> LITERAL .)
    CONTINUE        reduce using rule 84 (g -> LITERAL .)
    BREAK           reduce using rule 84 (g -> LITERAL .)
    RETURN          reduce using rule 84 (g -> LITERAL .)
    FUNCTION        reduce using rule 84 (g -> LITERAL .)
    $end            reduce using rule 84 (g -> LITERAL .)
    R_LLAVE         reduce using rule 84 (g -> LITERAL .)
    R_PAREN         reduce using rule 84 (g -> LITERAL .)
    COMA            reduce using rule 84 (g -> LITERAL .)


state 67

    (85) g -> interface_assi .

    PUNTO           reduce using rule 85 (g -> interface_assi .)
    TIMES           reduce using rule 85 (g -> interface_assi .)
    DIVIDE          reduce using rule 85 (g -> interface_assi .)
    MOD             reduce using rule 85 (g -> interface_assi .)
    POTENCIA        reduce using rule 85 (g -> interface_assi .)
    MAS             reduce using rule 85 (g -> interface_assi .)
    MENOS           reduce using rule 85 (g -> interface_assi .)
    DISTINTO_QUE    reduce using rule 85 (g -> interface_assi .)
    MENOR_QUE       reduce using rule 85 (g -> interface_assi .)
    MENOR_IGUAL_QUE reduce using rule 85 (g -> interface_assi .)
    MAYOR_QUE       reduce using rule 85 (g -> interface_assi .)
    MAYOR_IGUAL_QUE reduce using rule 85 (g -> interface_assi .)
    TRIPLE_IGUAL    reduce using rule 85 (g -> interface_assi .)
    AND             reduce using rule 85 (g -> interface_assi .)
    OR              reduce using rule 85 (g -> interface_assi .)
    SEMI_COLON      reduce using rule 85 (g -> interface_assi .)
    CONSOLE         reduce using rule 85 (g -> interface_assi .)
    LET             reduce using rule 85 (g -> interface_assi .)
    LITERAL         reduce using rule 85 (g -> interface_assi .)
    IF              reduce using rule 85 (g -> interface_assi .)
    WHILE           reduce using rule 85 (g -> interface_assi .)
    FOR             reduce using rule 85 (g -> interface_assi .)
    INTERFACE       reduce using rule 85 (g -> interface_assi .)
    CONTINUE        reduce using rule 85 (g -> interface_assi .)
    BREAK           reduce using rule 85 (g -> interface_assi .)
    RETURN          reduce using rule 85 (g -> interface_assi .)
    FUNCTION        reduce using rule 85 (g -> interface_assi .)
    $end            reduce using rule 85 (g -> interface_assi .)
    R_LLAVE         reduce using rule 85 (g -> interface_assi .)
    R_PAREN         reduce using rule 85 (g -> interface_assi .)
    COMA            reduce using rule 85 (g -> interface_assi .)


state 68

    (89) interface_assi -> L_LLAVE . atributos_assi R_LLAVE
    (90) atributos_assi -> . atributos_assi COMA LITERAL COLON a
    (91) atributos_assi -> . LITERAL COLON a

    LITERAL         shift and go to state 103

    atributos_assi                 shift and go to state 102

state 69

    (19) function_pro -> FUNCTION LITERAL . L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (20) function_pro -> FUNCTION LITERAL . L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE

    L_PAREN         shift and go to state 104


state 70

    (56) console_pro -> CONSOLE PUNTO LOG . L_PAREN expresion R_PAREN

    L_PAREN         shift and go to state 105


state 71

    (35) declaracion_list -> declaracion_list COMA . assignacion_instruction
    (37) assignacion_instruction -> . LITERAL COLON type IGUAL a
    (38) assignacion_instruction -> . LITERAL COLON type
    (39) assignacion_instruction -> . LITERAL IGUAL a

    LITERAL         shift and go to state 46

    assignacion_instruction        shift and go to state 106

state 72

    (37) assignacion_instruction -> LITERAL COLON . type IGUAL a
    (38) assignacion_instruction -> LITERAL COLON . type
    (40) type -> . NUMBER
    (41) type -> . STRING
    (42) type -> . BOOLEAN
    (43) type -> . ANY
    (44) type -> . LITERAL

    NUMBER          shift and go to state 109
    STRING          shift and go to state 110
    BOOLEAN         shift and go to state 111
    ANY             shift and go to state 112
    LITERAL         shift and go to state 107

    type                           shift and go to state 108

state 73

    (39) assignacion_instruction -> LITERAL IGUAL . a
    (59) a -> . a OR b
    (60) a -> . b
    (61) b -> . b AND c
    (62) b -> . c
    (63) c -> . NOT d
    (64) c -> . d
    (65) d -> . d DISTINTO_QUE e
    (66) d -> . d MENOR_QUE e
    (67) d -> . d MENOR_IGUAL_QUE e
    (68) d -> . d MAYOR_QUE e
    (69) d -> . d MAYOR_IGUAL_QUE e
    (70) d -> . d TRIPLE_IGUAL e
    (71) d -> . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 57
    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    a                              shift and go to state 113
    b                              shift and go to state 55
    c                              shift and go to state 56
    d                              shift and go to state 58
    e                              shift and go to state 59
    f                              shift and go to state 60
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 74

    (45) assig_pro -> LITERAL IGUAL a .
    (59) a -> a . OR b

    SEMI_COLON      reduce using rule 45 (assig_pro -> LITERAL IGUAL a .)
    CONSOLE         reduce using rule 45 (assig_pro -> LITERAL IGUAL a .)
    LET             reduce using rule 45 (assig_pro -> LITERAL IGUAL a .)
    LITERAL         reduce using rule 45 (assig_pro -> LITERAL IGUAL a .)
    IF              reduce using rule 45 (assig_pro -> LITERAL IGUAL a .)
    WHILE           reduce using rule 45 (assig_pro -> LITERAL IGUAL a .)
    FOR             reduce using rule 45 (assig_pro -> LITERAL IGUAL a .)
    INTERFACE       reduce using rule 45 (assig_pro -> LITERAL IGUAL a .)
    CONTINUE        reduce using rule 45 (assig_pro -> LITERAL IGUAL a .)
    BREAK           reduce using rule 45 (assig_pro -> LITERAL IGUAL a .)
    RETURN          reduce using rule 45 (assig_pro -> LITERAL IGUAL a .)
    FUNCTION        reduce using rule 45 (assig_pro -> LITERAL IGUAL a .)
    $end            reduce using rule 45 (assig_pro -> LITERAL IGUAL a .)
    R_LLAVE         reduce using rule 45 (assig_pro -> LITERAL IGUAL a .)
    R_PAREN         reduce using rule 45 (assig_pro -> LITERAL IGUAL a .)
    OR              shift and go to state 85


state 75

    (87) sumadores -> LITERAL MAS MAS .

    SEMI_COLON      reduce using rule 87 (sumadores -> LITERAL MAS MAS .)
    CONSOLE         reduce using rule 87 (sumadores -> LITERAL MAS MAS .)
    LET             reduce using rule 87 (sumadores -> LITERAL MAS MAS .)
    LITERAL         reduce using rule 87 (sumadores -> LITERAL MAS MAS .)
    IF              reduce using rule 87 (sumadores -> LITERAL MAS MAS .)
    WHILE           reduce using rule 87 (sumadores -> LITERAL MAS MAS .)
    FOR             reduce using rule 87 (sumadores -> LITERAL MAS MAS .)
    INTERFACE       reduce using rule 87 (sumadores -> LITERAL MAS MAS .)
    CONTINUE        reduce using rule 87 (sumadores -> LITERAL MAS MAS .)
    BREAK           reduce using rule 87 (sumadores -> LITERAL MAS MAS .)
    RETURN          reduce using rule 87 (sumadores -> LITERAL MAS MAS .)
    FUNCTION        reduce using rule 87 (sumadores -> LITERAL MAS MAS .)
    $end            reduce using rule 87 (sumadores -> LITERAL MAS MAS .)
    R_LLAVE         reduce using rule 87 (sumadores -> LITERAL MAS MAS .)


state 76

    (88) sumadores -> LITERAL MENOS MENOS .

    SEMI_COLON      reduce using rule 88 (sumadores -> LITERAL MENOS MENOS .)
    CONSOLE         reduce using rule 88 (sumadores -> LITERAL MENOS MENOS .)
    LET             reduce using rule 88 (sumadores -> LITERAL MENOS MENOS .)
    LITERAL         reduce using rule 88 (sumadores -> LITERAL MENOS MENOS .)
    IF              reduce using rule 88 (sumadores -> LITERAL MENOS MENOS .)
    WHILE           reduce using rule 88 (sumadores -> LITERAL MENOS MENOS .)
    FOR             reduce using rule 88 (sumadores -> LITERAL MENOS MENOS .)
    INTERFACE       reduce using rule 88 (sumadores -> LITERAL MENOS MENOS .)
    CONTINUE        reduce using rule 88 (sumadores -> LITERAL MENOS MENOS .)
    BREAK           reduce using rule 88 (sumadores -> LITERAL MENOS MENOS .)
    RETURN          reduce using rule 88 (sumadores -> LITERAL MENOS MENOS .)
    FUNCTION        reduce using rule 88 (sumadores -> LITERAL MENOS MENOS .)
    $end            reduce using rule 88 (sumadores -> LITERAL MENOS MENOS .)
    R_LLAVE         reduce using rule 88 (sumadores -> LITERAL MENOS MENOS .)


state 77

    (46) if_pro -> IF L_PAREN a . R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (59) a -> a . OR b

    R_PAREN         shift and go to state 114
    OR              shift and go to state 85


state 78

    (50) while_pro -> WHILE L_PAREN a . R_PAREN L_LLAVE instrucciones R_LLAVE
    (59) a -> a . OR b

    R_PAREN         shift and go to state 115
    OR              shift and go to state 85


state 79

    (51) for_pro -> FOR L_PAREN declaration_instruction . SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE

    SEMI_COLON      shift and go to state 116


state 80

    (52) for_pro -> FOR L_PAREN assig_pro . SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE

    SEMI_COLON      shift and go to state 117


state 81

    (53) for_each_pro -> FOR L_PAREN for_each_dec . R_PAREN L_LLAVE instrucciones R_LLAVE

    R_PAREN         shift and go to state 118


state 82

    (34) declaration_instruction -> LET . declaracion_list
    (54) for_each_dec -> LET . LITERAL OF a
    (55) for_each_dec -> LET . LITERAL COLON type OF a
    (35) declaracion_list -> . declaracion_list COMA assignacion_instruction
    (36) declaracion_list -> . assignacion_instruction
    (37) assignacion_instruction -> . LITERAL COLON type IGUAL a
    (38) assignacion_instruction -> . LITERAL COLON type
    (39) assignacion_instruction -> . LITERAL IGUAL a

    LITERAL         shift and go to state 119

    declaracion_list               shift and go to state 44
    assignacion_instruction        shift and go to state 45

state 83

    (45) assig_pro -> LITERAL . IGUAL a

    IGUAL           shift and go to state 47


state 84

    (29) interface_pro -> INTERFACE LITERAL L_LLAVE . interface_atributos R_LLAVE
    (30) interface_atributos -> . interface_atributos interface_atributo sc
    (31) interface_atributos -> .

    R_LLAVE         reduce using rule 31 (interface_atributos -> .)
    LITERAL         reduce using rule 31 (interface_atributos -> .)

    interface_atributos            shift and go to state 120

state 85

    (59) a -> a OR . b
    (61) b -> . b AND c
    (62) b -> . c
    (63) c -> . NOT d
    (64) c -> . d
    (65) d -> . d DISTINTO_QUE e
    (66) d -> . d MENOR_QUE e
    (67) d -> . d MENOR_IGUAL_QUE e
    (68) d -> . d MAYOR_QUE e
    (69) d -> . d MAYOR_IGUAL_QUE e
    (70) d -> . d TRIPLE_IGUAL e
    (71) d -> . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 57
    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    b                              shift and go to state 121
    c                              shift and go to state 56
    d                              shift and go to state 58
    e                              shift and go to state 59
    f                              shift and go to state 60
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 86

    (61) b -> b AND . c
    (63) c -> . NOT d
    (64) c -> . d
    (65) d -> . d DISTINTO_QUE e
    (66) d -> . d MENOR_QUE e
    (67) d -> . d MENOR_IGUAL_QUE e
    (68) d -> . d MAYOR_QUE e
    (69) d -> . d MAYOR_IGUAL_QUE e
    (70) d -> . d TRIPLE_IGUAL e
    (71) d -> . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 57
    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    c                              shift and go to state 122
    d                              shift and go to state 58
    e                              shift and go to state 59
    f                              shift and go to state 60
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 87

    (63) c -> NOT d .
    (65) d -> d . DISTINTO_QUE e
    (66) d -> d . MENOR_QUE e
    (67) d -> d . MENOR_IGUAL_QUE e
    (68) d -> d . MAYOR_QUE e
    (69) d -> d . MAYOR_IGUAL_QUE e
    (70) d -> d . TRIPLE_IGUAL e

    AND             reduce using rule 63 (c -> NOT d .)
    OR              reduce using rule 63 (c -> NOT d .)
    SEMI_COLON      reduce using rule 63 (c -> NOT d .)
    CONSOLE         reduce using rule 63 (c -> NOT d .)
    LET             reduce using rule 63 (c -> NOT d .)
    LITERAL         reduce using rule 63 (c -> NOT d .)
    IF              reduce using rule 63 (c -> NOT d .)
    WHILE           reduce using rule 63 (c -> NOT d .)
    FOR             reduce using rule 63 (c -> NOT d .)
    INTERFACE       reduce using rule 63 (c -> NOT d .)
    CONTINUE        reduce using rule 63 (c -> NOT d .)
    BREAK           reduce using rule 63 (c -> NOT d .)
    RETURN          reduce using rule 63 (c -> NOT d .)
    FUNCTION        reduce using rule 63 (c -> NOT d .)
    $end            reduce using rule 63 (c -> NOT d .)
    R_LLAVE         reduce using rule 63 (c -> NOT d .)
    R_PAREN         reduce using rule 63 (c -> NOT d .)
    COMA            reduce using rule 63 (c -> NOT d .)
    DISTINTO_QUE    shift and go to state 88
    MENOR_QUE       shift and go to state 89
    MENOR_IGUAL_QUE shift and go to state 90
    MAYOR_QUE       shift and go to state 91
    MAYOR_IGUAL_QUE shift and go to state 92
    TRIPLE_IGUAL    shift and go to state 93


state 88

    (65) d -> d DISTINTO_QUE . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    e                              shift and go to state 123
    f                              shift and go to state 60
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 89

    (66) d -> d MENOR_QUE . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    e                              shift and go to state 124
    f                              shift and go to state 60
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 90

    (67) d -> d MENOR_IGUAL_QUE . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    e                              shift and go to state 125
    f                              shift and go to state 60
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 91

    (68) d -> d MAYOR_QUE . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    e                              shift and go to state 126
    f                              shift and go to state 60
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 92

    (69) d -> d MAYOR_IGUAL_QUE . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    e                              shift and go to state 127
    f                              shift and go to state 60
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 93

    (70) d -> d TRIPLE_IGUAL . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    e                              shift and go to state 128
    f                              shift and go to state 60
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 94

    (72) e -> e MAS . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    f                              shift and go to state 129
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 95

    (73) e -> e MENOS . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    f                              shift and go to state 130
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 96

    (75) f -> f TIMES . g
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    g                              shift and go to state 131
    interface_assi                 shift and go to state 67

state 97

    (76) f -> f DIVIDE . g
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    g                              shift and go to state 132
    interface_assi                 shift and go to state 67

state 98

    (77) f -> f MOD . g
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    g                              shift and go to state 133
    interface_assi                 shift and go to state 67

state 99

    (78) f -> f POTENCIA . g
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    g                              shift and go to state 134
    interface_assi                 shift and go to state 67

state 100

    (80) f -> g PUNTO . nativeFun L_PAREN expresion R_PAREN
    (92) nativeFun -> . TOSTRING
    (93) nativeFun -> . TOFIXED
    (94) nativeFun -> . TOEXPONENTIAL
    (95) nativeFun -> . TOLOWERCASE
    (96) nativeFun -> . TOUPPERCASE
    (97) nativeFun -> . SPLIT
    (98) nativeFun -> . CONCAT

    TOSTRING        shift and go to state 136
    TOFIXED         shift and go to state 137
    TOEXPONENTIAL   shift and go to state 138
    TOLOWERCASE     shift and go to state 139
    TOUPPERCASE     shift and go to state 140
    SPLIT           shift and go to state 141
    CONCAT          shift and go to state 142

    nativeFun                      shift and go to state 135

state 101

    (86) g -> L_PAREN a . R_PAREN
    (59) a -> a . OR b

    R_PAREN         shift and go to state 143
    OR              shift and go to state 85


state 102

    (89) interface_assi -> L_LLAVE atributos_assi . R_LLAVE
    (90) atributos_assi -> atributos_assi . COMA LITERAL COLON a

    R_LLAVE         shift and go to state 144
    COMA            shift and go to state 145


state 103

    (91) atributos_assi -> LITERAL . COLON a

    COLON           shift and go to state 146


state 104

    (19) function_pro -> FUNCTION LITERAL L_PAREN . parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (20) function_pro -> FUNCTION LITERAL L_PAREN . R_PAREN L_LLAVE instrucciones R_LLAVE
    (21) parameters_pro -> . parameters_pro COMA parameter_pro
    (22) parameters_pro -> . parameter_pro
    (23) parameter_pro -> . LITERAL COLON type
    (24) parameter_pro -> . LITERAL

    R_PAREN         shift and go to state 149
    LITERAL         shift and go to state 147

    parameters_pro                 shift and go to state 148
    parameter_pro                  shift and go to state 150

state 105

    (56) console_pro -> CONSOLE PUNTO LOG L_PAREN . expresion R_PAREN
    (57) expresion -> . expresion COMA a
    (58) expresion -> . a
    (59) a -> . a OR b
    (60) a -> . b
    (61) b -> . b AND c
    (62) b -> . c
    (63) c -> . NOT d
    (64) c -> . d
    (65) d -> . d DISTINTO_QUE e
    (66) d -> . d MENOR_QUE e
    (67) d -> . d MENOR_IGUAL_QUE e
    (68) d -> . d MAYOR_QUE e
    (69) d -> . d MAYOR_IGUAL_QUE e
    (70) d -> . d TRIPLE_IGUAL e
    (71) d -> . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 57
    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    expresion                      shift and go to state 151
    a                              shift and go to state 152
    b                              shift and go to state 55
    c                              shift and go to state 56
    d                              shift and go to state 58
    e                              shift and go to state 59
    f                              shift and go to state 60
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 106

    (35) declaracion_list -> declaracion_list COMA assignacion_instruction .

    COMA            reduce using rule 35 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    SEMI_COLON      reduce using rule 35 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    CONSOLE         reduce using rule 35 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    LET             reduce using rule 35 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    LITERAL         reduce using rule 35 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    IF              reduce using rule 35 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    WHILE           reduce using rule 35 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    FOR             reduce using rule 35 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    INTERFACE       reduce using rule 35 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    CONTINUE        reduce using rule 35 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    BREAK           reduce using rule 35 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    RETURN          reduce using rule 35 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    FUNCTION        reduce using rule 35 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    $end            reduce using rule 35 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    R_LLAVE         reduce using rule 35 (declaracion_list -> declaracion_list COMA assignacion_instruction .)


state 107

    (44) type -> LITERAL .

    IGUAL           reduce using rule 44 (type -> LITERAL .)
    COMA            reduce using rule 44 (type -> LITERAL .)
    SEMI_COLON      reduce using rule 44 (type -> LITERAL .)
    CONSOLE         reduce using rule 44 (type -> LITERAL .)
    LET             reduce using rule 44 (type -> LITERAL .)
    LITERAL         reduce using rule 44 (type -> LITERAL .)
    IF              reduce using rule 44 (type -> LITERAL .)
    WHILE           reduce using rule 44 (type -> LITERAL .)
    FOR             reduce using rule 44 (type -> LITERAL .)
    INTERFACE       reduce using rule 44 (type -> LITERAL .)
    CONTINUE        reduce using rule 44 (type -> LITERAL .)
    BREAK           reduce using rule 44 (type -> LITERAL .)
    RETURN          reduce using rule 44 (type -> LITERAL .)
    FUNCTION        reduce using rule 44 (type -> LITERAL .)
    $end            reduce using rule 44 (type -> LITERAL .)
    R_LLAVE         reduce using rule 44 (type -> LITERAL .)
    OF              reduce using rule 44 (type -> LITERAL .)
    R_PAREN         reduce using rule 44 (type -> LITERAL .)


state 108

    (37) assignacion_instruction -> LITERAL COLON type . IGUAL a
    (38) assignacion_instruction -> LITERAL COLON type .

    IGUAL           shift and go to state 153
    COMA            reduce using rule 38 (assignacion_instruction -> LITERAL COLON type .)
    SEMI_COLON      reduce using rule 38 (assignacion_instruction -> LITERAL COLON type .)
    CONSOLE         reduce using rule 38 (assignacion_instruction -> LITERAL COLON type .)
    LET             reduce using rule 38 (assignacion_instruction -> LITERAL COLON type .)
    LITERAL         reduce using rule 38 (assignacion_instruction -> LITERAL COLON type .)
    IF              reduce using rule 38 (assignacion_instruction -> LITERAL COLON type .)
    WHILE           reduce using rule 38 (assignacion_instruction -> LITERAL COLON type .)
    FOR             reduce using rule 38 (assignacion_instruction -> LITERAL COLON type .)
    INTERFACE       reduce using rule 38 (assignacion_instruction -> LITERAL COLON type .)
    CONTINUE        reduce using rule 38 (assignacion_instruction -> LITERAL COLON type .)
    BREAK           reduce using rule 38 (assignacion_instruction -> LITERAL COLON type .)
    RETURN          reduce using rule 38 (assignacion_instruction -> LITERAL COLON type .)
    FUNCTION        reduce using rule 38 (assignacion_instruction -> LITERAL COLON type .)
    $end            reduce using rule 38 (assignacion_instruction -> LITERAL COLON type .)
    R_LLAVE         reduce using rule 38 (assignacion_instruction -> LITERAL COLON type .)


state 109

    (40) type -> NUMBER .

    IGUAL           reduce using rule 40 (type -> NUMBER .)
    COMA            reduce using rule 40 (type -> NUMBER .)
    SEMI_COLON      reduce using rule 40 (type -> NUMBER .)
    CONSOLE         reduce using rule 40 (type -> NUMBER .)
    LET             reduce using rule 40 (type -> NUMBER .)
    LITERAL         reduce using rule 40 (type -> NUMBER .)
    IF              reduce using rule 40 (type -> NUMBER .)
    WHILE           reduce using rule 40 (type -> NUMBER .)
    FOR             reduce using rule 40 (type -> NUMBER .)
    INTERFACE       reduce using rule 40 (type -> NUMBER .)
    CONTINUE        reduce using rule 40 (type -> NUMBER .)
    BREAK           reduce using rule 40 (type -> NUMBER .)
    RETURN          reduce using rule 40 (type -> NUMBER .)
    FUNCTION        reduce using rule 40 (type -> NUMBER .)
    $end            reduce using rule 40 (type -> NUMBER .)
    R_LLAVE         reduce using rule 40 (type -> NUMBER .)
    OF              reduce using rule 40 (type -> NUMBER .)
    R_PAREN         reduce using rule 40 (type -> NUMBER .)


state 110

    (41) type -> STRING .

    IGUAL           reduce using rule 41 (type -> STRING .)
    COMA            reduce using rule 41 (type -> STRING .)
    SEMI_COLON      reduce using rule 41 (type -> STRING .)
    CONSOLE         reduce using rule 41 (type -> STRING .)
    LET             reduce using rule 41 (type -> STRING .)
    LITERAL         reduce using rule 41 (type -> STRING .)
    IF              reduce using rule 41 (type -> STRING .)
    WHILE           reduce using rule 41 (type -> STRING .)
    FOR             reduce using rule 41 (type -> STRING .)
    INTERFACE       reduce using rule 41 (type -> STRING .)
    CONTINUE        reduce using rule 41 (type -> STRING .)
    BREAK           reduce using rule 41 (type -> STRING .)
    RETURN          reduce using rule 41 (type -> STRING .)
    FUNCTION        reduce using rule 41 (type -> STRING .)
    $end            reduce using rule 41 (type -> STRING .)
    R_LLAVE         reduce using rule 41 (type -> STRING .)
    OF              reduce using rule 41 (type -> STRING .)
    R_PAREN         reduce using rule 41 (type -> STRING .)


state 111

    (42) type -> BOOLEAN .

    IGUAL           reduce using rule 42 (type -> BOOLEAN .)
    COMA            reduce using rule 42 (type -> BOOLEAN .)
    SEMI_COLON      reduce using rule 42 (type -> BOOLEAN .)
    CONSOLE         reduce using rule 42 (type -> BOOLEAN .)
    LET             reduce using rule 42 (type -> BOOLEAN .)
    LITERAL         reduce using rule 42 (type -> BOOLEAN .)
    IF              reduce using rule 42 (type -> BOOLEAN .)
    WHILE           reduce using rule 42 (type -> BOOLEAN .)
    FOR             reduce using rule 42 (type -> BOOLEAN .)
    INTERFACE       reduce using rule 42 (type -> BOOLEAN .)
    CONTINUE        reduce using rule 42 (type -> BOOLEAN .)
    BREAK           reduce using rule 42 (type -> BOOLEAN .)
    RETURN          reduce using rule 42 (type -> BOOLEAN .)
    FUNCTION        reduce using rule 42 (type -> BOOLEAN .)
    $end            reduce using rule 42 (type -> BOOLEAN .)
    R_LLAVE         reduce using rule 42 (type -> BOOLEAN .)
    OF              reduce using rule 42 (type -> BOOLEAN .)
    R_PAREN         reduce using rule 42 (type -> BOOLEAN .)


state 112

    (43) type -> ANY .

    IGUAL           reduce using rule 43 (type -> ANY .)
    COMA            reduce using rule 43 (type -> ANY .)
    SEMI_COLON      reduce using rule 43 (type -> ANY .)
    CONSOLE         reduce using rule 43 (type -> ANY .)
    LET             reduce using rule 43 (type -> ANY .)
    LITERAL         reduce using rule 43 (type -> ANY .)
    IF              reduce using rule 43 (type -> ANY .)
    WHILE           reduce using rule 43 (type -> ANY .)
    FOR             reduce using rule 43 (type -> ANY .)
    INTERFACE       reduce using rule 43 (type -> ANY .)
    CONTINUE        reduce using rule 43 (type -> ANY .)
    BREAK           reduce using rule 43 (type -> ANY .)
    RETURN          reduce using rule 43 (type -> ANY .)
    FUNCTION        reduce using rule 43 (type -> ANY .)
    $end            reduce using rule 43 (type -> ANY .)
    R_LLAVE         reduce using rule 43 (type -> ANY .)
    OF              reduce using rule 43 (type -> ANY .)
    R_PAREN         reduce using rule 43 (type -> ANY .)


state 113

    (39) assignacion_instruction -> LITERAL IGUAL a .
    (59) a -> a . OR b

    COMA            reduce using rule 39 (assignacion_instruction -> LITERAL IGUAL a .)
    SEMI_COLON      reduce using rule 39 (assignacion_instruction -> LITERAL IGUAL a .)
    CONSOLE         reduce using rule 39 (assignacion_instruction -> LITERAL IGUAL a .)
    LET             reduce using rule 39 (assignacion_instruction -> LITERAL IGUAL a .)
    LITERAL         reduce using rule 39 (assignacion_instruction -> LITERAL IGUAL a .)
    IF              reduce using rule 39 (assignacion_instruction -> LITERAL IGUAL a .)
    WHILE           reduce using rule 39 (assignacion_instruction -> LITERAL IGUAL a .)
    FOR             reduce using rule 39 (assignacion_instruction -> LITERAL IGUAL a .)
    INTERFACE       reduce using rule 39 (assignacion_instruction -> LITERAL IGUAL a .)
    CONTINUE        reduce using rule 39 (assignacion_instruction -> LITERAL IGUAL a .)
    BREAK           reduce using rule 39 (assignacion_instruction -> LITERAL IGUAL a .)
    RETURN          reduce using rule 39 (assignacion_instruction -> LITERAL IGUAL a .)
    FUNCTION        reduce using rule 39 (assignacion_instruction -> LITERAL IGUAL a .)
    $end            reduce using rule 39 (assignacion_instruction -> LITERAL IGUAL a .)
    R_LLAVE         reduce using rule 39 (assignacion_instruction -> LITERAL IGUAL a .)
    OR              shift and go to state 85


state 114

    (46) if_pro -> IF L_PAREN a R_PAREN . L_LLAVE instrucciones R_LLAVE else_pro

    L_LLAVE         shift and go to state 154


state 115

    (50) while_pro -> WHILE L_PAREN a R_PAREN . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 155


state 116

    (51) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON . a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (59) a -> . a OR b
    (60) a -> . b
    (61) b -> . b AND c
    (62) b -> . c
    (63) c -> . NOT d
    (64) c -> . d
    (65) d -> . d DISTINTO_QUE e
    (66) d -> . d MENOR_QUE e
    (67) d -> . d MENOR_IGUAL_QUE e
    (68) d -> . d MAYOR_QUE e
    (69) d -> . d MAYOR_IGUAL_QUE e
    (70) d -> . d TRIPLE_IGUAL e
    (71) d -> . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 57
    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    a                              shift and go to state 156
    b                              shift and go to state 55
    c                              shift and go to state 56
    d                              shift and go to state 58
    e                              shift and go to state 59
    f                              shift and go to state 60
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 117

    (52) for_pro -> FOR L_PAREN assig_pro SEMI_COLON . a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (59) a -> . a OR b
    (60) a -> . b
    (61) b -> . b AND c
    (62) b -> . c
    (63) c -> . NOT d
    (64) c -> . d
    (65) d -> . d DISTINTO_QUE e
    (66) d -> . d MENOR_QUE e
    (67) d -> . d MENOR_IGUAL_QUE e
    (68) d -> . d MAYOR_QUE e
    (69) d -> . d MAYOR_IGUAL_QUE e
    (70) d -> . d TRIPLE_IGUAL e
    (71) d -> . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 57
    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    a                              shift and go to state 157
    b                              shift and go to state 55
    c                              shift and go to state 56
    d                              shift and go to state 58
    e                              shift and go to state 59
    f                              shift and go to state 60
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 118

    (53) for_each_pro -> FOR L_PAREN for_each_dec R_PAREN . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 158


state 119

    (54) for_each_dec -> LET LITERAL . OF a
    (55) for_each_dec -> LET LITERAL . COLON type OF a
    (37) assignacion_instruction -> LITERAL . COLON type IGUAL a
    (38) assignacion_instruction -> LITERAL . COLON type
    (39) assignacion_instruction -> LITERAL . IGUAL a

    OF              shift and go to state 159
    COLON           shift and go to state 160
    IGUAL           shift and go to state 73


state 120

    (29) interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos . R_LLAVE
    (30) interface_atributos -> interface_atributos . interface_atributo sc
    (32) interface_atributo -> . LITERAL COLON type
    (33) interface_atributo -> . LITERAL

    R_LLAVE         shift and go to state 162
    LITERAL         shift and go to state 161

    interface_atributo             shift and go to state 163

state 121

    (59) a -> a OR b .
    (61) b -> b . AND c

    OR              reduce using rule 59 (a -> a OR b .)
    SEMI_COLON      reduce using rule 59 (a -> a OR b .)
    CONSOLE         reduce using rule 59 (a -> a OR b .)
    LET             reduce using rule 59 (a -> a OR b .)
    LITERAL         reduce using rule 59 (a -> a OR b .)
    IF              reduce using rule 59 (a -> a OR b .)
    WHILE           reduce using rule 59 (a -> a OR b .)
    FOR             reduce using rule 59 (a -> a OR b .)
    INTERFACE       reduce using rule 59 (a -> a OR b .)
    CONTINUE        reduce using rule 59 (a -> a OR b .)
    BREAK           reduce using rule 59 (a -> a OR b .)
    RETURN          reduce using rule 59 (a -> a OR b .)
    FUNCTION        reduce using rule 59 (a -> a OR b .)
    $end            reduce using rule 59 (a -> a OR b .)
    R_LLAVE         reduce using rule 59 (a -> a OR b .)
    R_PAREN         reduce using rule 59 (a -> a OR b .)
    COMA            reduce using rule 59 (a -> a OR b .)
    AND             shift and go to state 86


state 122

    (61) b -> b AND c .

    AND             reduce using rule 61 (b -> b AND c .)
    OR              reduce using rule 61 (b -> b AND c .)
    SEMI_COLON      reduce using rule 61 (b -> b AND c .)
    CONSOLE         reduce using rule 61 (b -> b AND c .)
    LET             reduce using rule 61 (b -> b AND c .)
    LITERAL         reduce using rule 61 (b -> b AND c .)
    IF              reduce using rule 61 (b -> b AND c .)
    WHILE           reduce using rule 61 (b -> b AND c .)
    FOR             reduce using rule 61 (b -> b AND c .)
    INTERFACE       reduce using rule 61 (b -> b AND c .)
    CONTINUE        reduce using rule 61 (b -> b AND c .)
    BREAK           reduce using rule 61 (b -> b AND c .)
    RETURN          reduce using rule 61 (b -> b AND c .)
    FUNCTION        reduce using rule 61 (b -> b AND c .)
    $end            reduce using rule 61 (b -> b AND c .)
    R_LLAVE         reduce using rule 61 (b -> b AND c .)
    R_PAREN         reduce using rule 61 (b -> b AND c .)
    COMA            reduce using rule 61 (b -> b AND c .)


state 123

    (65) d -> d DISTINTO_QUE e .
    (72) e -> e . MAS f
    (73) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 65 (d -> d DISTINTO_QUE e .)
    MENOR_QUE       reduce using rule 65 (d -> d DISTINTO_QUE e .)
    MENOR_IGUAL_QUE reduce using rule 65 (d -> d DISTINTO_QUE e .)
    MAYOR_QUE       reduce using rule 65 (d -> d DISTINTO_QUE e .)
    MAYOR_IGUAL_QUE reduce using rule 65 (d -> d DISTINTO_QUE e .)
    TRIPLE_IGUAL    reduce using rule 65 (d -> d DISTINTO_QUE e .)
    AND             reduce using rule 65 (d -> d DISTINTO_QUE e .)
    OR              reduce using rule 65 (d -> d DISTINTO_QUE e .)
    SEMI_COLON      reduce using rule 65 (d -> d DISTINTO_QUE e .)
    CONSOLE         reduce using rule 65 (d -> d DISTINTO_QUE e .)
    LET             reduce using rule 65 (d -> d DISTINTO_QUE e .)
    LITERAL         reduce using rule 65 (d -> d DISTINTO_QUE e .)
    IF              reduce using rule 65 (d -> d DISTINTO_QUE e .)
    WHILE           reduce using rule 65 (d -> d DISTINTO_QUE e .)
    FOR             reduce using rule 65 (d -> d DISTINTO_QUE e .)
    INTERFACE       reduce using rule 65 (d -> d DISTINTO_QUE e .)
    CONTINUE        reduce using rule 65 (d -> d DISTINTO_QUE e .)
    BREAK           reduce using rule 65 (d -> d DISTINTO_QUE e .)
    RETURN          reduce using rule 65 (d -> d DISTINTO_QUE e .)
    FUNCTION        reduce using rule 65 (d -> d DISTINTO_QUE e .)
    $end            reduce using rule 65 (d -> d DISTINTO_QUE e .)
    R_LLAVE         reduce using rule 65 (d -> d DISTINTO_QUE e .)
    R_PAREN         reduce using rule 65 (d -> d DISTINTO_QUE e .)
    COMA            reduce using rule 65 (d -> d DISTINTO_QUE e .)
    MAS             shift and go to state 94
    MENOS           shift and go to state 95


state 124

    (66) d -> d MENOR_QUE e .
    (72) e -> e . MAS f
    (73) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 66 (d -> d MENOR_QUE e .)
    MENOR_QUE       reduce using rule 66 (d -> d MENOR_QUE e .)
    MENOR_IGUAL_QUE reduce using rule 66 (d -> d MENOR_QUE e .)
    MAYOR_QUE       reduce using rule 66 (d -> d MENOR_QUE e .)
    MAYOR_IGUAL_QUE reduce using rule 66 (d -> d MENOR_QUE e .)
    TRIPLE_IGUAL    reduce using rule 66 (d -> d MENOR_QUE e .)
    AND             reduce using rule 66 (d -> d MENOR_QUE e .)
    OR              reduce using rule 66 (d -> d MENOR_QUE e .)
    SEMI_COLON      reduce using rule 66 (d -> d MENOR_QUE e .)
    CONSOLE         reduce using rule 66 (d -> d MENOR_QUE e .)
    LET             reduce using rule 66 (d -> d MENOR_QUE e .)
    LITERAL         reduce using rule 66 (d -> d MENOR_QUE e .)
    IF              reduce using rule 66 (d -> d MENOR_QUE e .)
    WHILE           reduce using rule 66 (d -> d MENOR_QUE e .)
    FOR             reduce using rule 66 (d -> d MENOR_QUE e .)
    INTERFACE       reduce using rule 66 (d -> d MENOR_QUE e .)
    CONTINUE        reduce using rule 66 (d -> d MENOR_QUE e .)
    BREAK           reduce using rule 66 (d -> d MENOR_QUE e .)
    RETURN          reduce using rule 66 (d -> d MENOR_QUE e .)
    FUNCTION        reduce using rule 66 (d -> d MENOR_QUE e .)
    $end            reduce using rule 66 (d -> d MENOR_QUE e .)
    R_LLAVE         reduce using rule 66 (d -> d MENOR_QUE e .)
    R_PAREN         reduce using rule 66 (d -> d MENOR_QUE e .)
    COMA            reduce using rule 66 (d -> d MENOR_QUE e .)
    MAS             shift and go to state 94
    MENOS           shift and go to state 95


state 125

    (67) d -> d MENOR_IGUAL_QUE e .
    (72) e -> e . MAS f
    (73) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 67 (d -> d MENOR_IGUAL_QUE e .)
    MENOR_QUE       reduce using rule 67 (d -> d MENOR_IGUAL_QUE e .)
    MENOR_IGUAL_QUE reduce using rule 67 (d -> d MENOR_IGUAL_QUE e .)
    MAYOR_QUE       reduce using rule 67 (d -> d MENOR_IGUAL_QUE e .)
    MAYOR_IGUAL_QUE reduce using rule 67 (d -> d MENOR_IGUAL_QUE e .)
    TRIPLE_IGUAL    reduce using rule 67 (d -> d MENOR_IGUAL_QUE e .)
    AND             reduce using rule 67 (d -> d MENOR_IGUAL_QUE e .)
    OR              reduce using rule 67 (d -> d MENOR_IGUAL_QUE e .)
    SEMI_COLON      reduce using rule 67 (d -> d MENOR_IGUAL_QUE e .)
    CONSOLE         reduce using rule 67 (d -> d MENOR_IGUAL_QUE e .)
    LET             reduce using rule 67 (d -> d MENOR_IGUAL_QUE e .)
    LITERAL         reduce using rule 67 (d -> d MENOR_IGUAL_QUE e .)
    IF              reduce using rule 67 (d -> d MENOR_IGUAL_QUE e .)
    WHILE           reduce using rule 67 (d -> d MENOR_IGUAL_QUE e .)
    FOR             reduce using rule 67 (d -> d MENOR_IGUAL_QUE e .)
    INTERFACE       reduce using rule 67 (d -> d MENOR_IGUAL_QUE e .)
    CONTINUE        reduce using rule 67 (d -> d MENOR_IGUAL_QUE e .)
    BREAK           reduce using rule 67 (d -> d MENOR_IGUAL_QUE e .)
    RETURN          reduce using rule 67 (d -> d MENOR_IGUAL_QUE e .)
    FUNCTION        reduce using rule 67 (d -> d MENOR_IGUAL_QUE e .)
    $end            reduce using rule 67 (d -> d MENOR_IGUAL_QUE e .)
    R_LLAVE         reduce using rule 67 (d -> d MENOR_IGUAL_QUE e .)
    R_PAREN         reduce using rule 67 (d -> d MENOR_IGUAL_QUE e .)
    COMA            reduce using rule 67 (d -> d MENOR_IGUAL_QUE e .)
    MAS             shift and go to state 94
    MENOS           shift and go to state 95


state 126

    (68) d -> d MAYOR_QUE e .
    (72) e -> e . MAS f
    (73) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 68 (d -> d MAYOR_QUE e .)
    MENOR_QUE       reduce using rule 68 (d -> d MAYOR_QUE e .)
    MENOR_IGUAL_QUE reduce using rule 68 (d -> d MAYOR_QUE e .)
    MAYOR_QUE       reduce using rule 68 (d -> d MAYOR_QUE e .)
    MAYOR_IGUAL_QUE reduce using rule 68 (d -> d MAYOR_QUE e .)
    TRIPLE_IGUAL    reduce using rule 68 (d -> d MAYOR_QUE e .)
    AND             reduce using rule 68 (d -> d MAYOR_QUE e .)
    OR              reduce using rule 68 (d -> d MAYOR_QUE e .)
    SEMI_COLON      reduce using rule 68 (d -> d MAYOR_QUE e .)
    CONSOLE         reduce using rule 68 (d -> d MAYOR_QUE e .)
    LET             reduce using rule 68 (d -> d MAYOR_QUE e .)
    LITERAL         reduce using rule 68 (d -> d MAYOR_QUE e .)
    IF              reduce using rule 68 (d -> d MAYOR_QUE e .)
    WHILE           reduce using rule 68 (d -> d MAYOR_QUE e .)
    FOR             reduce using rule 68 (d -> d MAYOR_QUE e .)
    INTERFACE       reduce using rule 68 (d -> d MAYOR_QUE e .)
    CONTINUE        reduce using rule 68 (d -> d MAYOR_QUE e .)
    BREAK           reduce using rule 68 (d -> d MAYOR_QUE e .)
    RETURN          reduce using rule 68 (d -> d MAYOR_QUE e .)
    FUNCTION        reduce using rule 68 (d -> d MAYOR_QUE e .)
    $end            reduce using rule 68 (d -> d MAYOR_QUE e .)
    R_LLAVE         reduce using rule 68 (d -> d MAYOR_QUE e .)
    R_PAREN         reduce using rule 68 (d -> d MAYOR_QUE e .)
    COMA            reduce using rule 68 (d -> d MAYOR_QUE e .)
    MAS             shift and go to state 94
    MENOS           shift and go to state 95


state 127

    (69) d -> d MAYOR_IGUAL_QUE e .
    (72) e -> e . MAS f
    (73) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 69 (d -> d MAYOR_IGUAL_QUE e .)
    MENOR_QUE       reduce using rule 69 (d -> d MAYOR_IGUAL_QUE e .)
    MENOR_IGUAL_QUE reduce using rule 69 (d -> d MAYOR_IGUAL_QUE e .)
    MAYOR_QUE       reduce using rule 69 (d -> d MAYOR_IGUAL_QUE e .)
    MAYOR_IGUAL_QUE reduce using rule 69 (d -> d MAYOR_IGUAL_QUE e .)
    TRIPLE_IGUAL    reduce using rule 69 (d -> d MAYOR_IGUAL_QUE e .)
    AND             reduce using rule 69 (d -> d MAYOR_IGUAL_QUE e .)
    OR              reduce using rule 69 (d -> d MAYOR_IGUAL_QUE e .)
    SEMI_COLON      reduce using rule 69 (d -> d MAYOR_IGUAL_QUE e .)
    CONSOLE         reduce using rule 69 (d -> d MAYOR_IGUAL_QUE e .)
    LET             reduce using rule 69 (d -> d MAYOR_IGUAL_QUE e .)
    LITERAL         reduce using rule 69 (d -> d MAYOR_IGUAL_QUE e .)
    IF              reduce using rule 69 (d -> d MAYOR_IGUAL_QUE e .)
    WHILE           reduce using rule 69 (d -> d MAYOR_IGUAL_QUE e .)
    FOR             reduce using rule 69 (d -> d MAYOR_IGUAL_QUE e .)
    INTERFACE       reduce using rule 69 (d -> d MAYOR_IGUAL_QUE e .)
    CONTINUE        reduce using rule 69 (d -> d MAYOR_IGUAL_QUE e .)
    BREAK           reduce using rule 69 (d -> d MAYOR_IGUAL_QUE e .)
    RETURN          reduce using rule 69 (d -> d MAYOR_IGUAL_QUE e .)
    FUNCTION        reduce using rule 69 (d -> d MAYOR_IGUAL_QUE e .)
    $end            reduce using rule 69 (d -> d MAYOR_IGUAL_QUE e .)
    R_LLAVE         reduce using rule 69 (d -> d MAYOR_IGUAL_QUE e .)
    R_PAREN         reduce using rule 69 (d -> d MAYOR_IGUAL_QUE e .)
    COMA            reduce using rule 69 (d -> d MAYOR_IGUAL_QUE e .)
    MAS             shift and go to state 94
    MENOS           shift and go to state 95


state 128

    (70) d -> d TRIPLE_IGUAL e .
    (72) e -> e . MAS f
    (73) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 70 (d -> d TRIPLE_IGUAL e .)
    MENOR_QUE       reduce using rule 70 (d -> d TRIPLE_IGUAL e .)
    MENOR_IGUAL_QUE reduce using rule 70 (d -> d TRIPLE_IGUAL e .)
    MAYOR_QUE       reduce using rule 70 (d -> d TRIPLE_IGUAL e .)
    MAYOR_IGUAL_QUE reduce using rule 70 (d -> d TRIPLE_IGUAL e .)
    TRIPLE_IGUAL    reduce using rule 70 (d -> d TRIPLE_IGUAL e .)
    AND             reduce using rule 70 (d -> d TRIPLE_IGUAL e .)
    OR              reduce using rule 70 (d -> d TRIPLE_IGUAL e .)
    SEMI_COLON      reduce using rule 70 (d -> d TRIPLE_IGUAL e .)
    CONSOLE         reduce using rule 70 (d -> d TRIPLE_IGUAL e .)
    LET             reduce using rule 70 (d -> d TRIPLE_IGUAL e .)
    LITERAL         reduce using rule 70 (d -> d TRIPLE_IGUAL e .)
    IF              reduce using rule 70 (d -> d TRIPLE_IGUAL e .)
    WHILE           reduce using rule 70 (d -> d TRIPLE_IGUAL e .)
    FOR             reduce using rule 70 (d -> d TRIPLE_IGUAL e .)
    INTERFACE       reduce using rule 70 (d -> d TRIPLE_IGUAL e .)
    CONTINUE        reduce using rule 70 (d -> d TRIPLE_IGUAL e .)
    BREAK           reduce using rule 70 (d -> d TRIPLE_IGUAL e .)
    RETURN          reduce using rule 70 (d -> d TRIPLE_IGUAL e .)
    FUNCTION        reduce using rule 70 (d -> d TRIPLE_IGUAL e .)
    $end            reduce using rule 70 (d -> d TRIPLE_IGUAL e .)
    R_LLAVE         reduce using rule 70 (d -> d TRIPLE_IGUAL e .)
    R_PAREN         reduce using rule 70 (d -> d TRIPLE_IGUAL e .)
    COMA            reduce using rule 70 (d -> d TRIPLE_IGUAL e .)
    MAS             shift and go to state 94
    MENOS           shift and go to state 95


state 129

    (72) e -> e MAS f .
    (75) f -> f . TIMES g
    (76) f -> f . DIVIDE g
    (77) f -> f . MOD g
    (78) f -> f . POTENCIA g

    MAS             reduce using rule 72 (e -> e MAS f .)
    MENOS           reduce using rule 72 (e -> e MAS f .)
    DISTINTO_QUE    reduce using rule 72 (e -> e MAS f .)
    MENOR_QUE       reduce using rule 72 (e -> e MAS f .)
    MENOR_IGUAL_QUE reduce using rule 72 (e -> e MAS f .)
    MAYOR_QUE       reduce using rule 72 (e -> e MAS f .)
    MAYOR_IGUAL_QUE reduce using rule 72 (e -> e MAS f .)
    TRIPLE_IGUAL    reduce using rule 72 (e -> e MAS f .)
    AND             reduce using rule 72 (e -> e MAS f .)
    OR              reduce using rule 72 (e -> e MAS f .)
    SEMI_COLON      reduce using rule 72 (e -> e MAS f .)
    CONSOLE         reduce using rule 72 (e -> e MAS f .)
    LET             reduce using rule 72 (e -> e MAS f .)
    LITERAL         reduce using rule 72 (e -> e MAS f .)
    IF              reduce using rule 72 (e -> e MAS f .)
    WHILE           reduce using rule 72 (e -> e MAS f .)
    FOR             reduce using rule 72 (e -> e MAS f .)
    INTERFACE       reduce using rule 72 (e -> e MAS f .)
    CONTINUE        reduce using rule 72 (e -> e MAS f .)
    BREAK           reduce using rule 72 (e -> e MAS f .)
    RETURN          reduce using rule 72 (e -> e MAS f .)
    FUNCTION        reduce using rule 72 (e -> e MAS f .)
    $end            reduce using rule 72 (e -> e MAS f .)
    R_LLAVE         reduce using rule 72 (e -> e MAS f .)
    R_PAREN         reduce using rule 72 (e -> e MAS f .)
    COMA            reduce using rule 72 (e -> e MAS f .)
    TIMES           shift and go to state 96
    DIVIDE          shift and go to state 97
    MOD             shift and go to state 98
    POTENCIA        shift and go to state 99


state 130

    (73) e -> e MENOS f .
    (75) f -> f . TIMES g
    (76) f -> f . DIVIDE g
    (77) f -> f . MOD g
    (78) f -> f . POTENCIA g

    MAS             reduce using rule 73 (e -> e MENOS f .)
    MENOS           reduce using rule 73 (e -> e MENOS f .)
    DISTINTO_QUE    reduce using rule 73 (e -> e MENOS f .)
    MENOR_QUE       reduce using rule 73 (e -> e MENOS f .)
    MENOR_IGUAL_QUE reduce using rule 73 (e -> e MENOS f .)
    MAYOR_QUE       reduce using rule 73 (e -> e MENOS f .)
    MAYOR_IGUAL_QUE reduce using rule 73 (e -> e MENOS f .)
    TRIPLE_IGUAL    reduce using rule 73 (e -> e MENOS f .)
    AND             reduce using rule 73 (e -> e MENOS f .)
    OR              reduce using rule 73 (e -> e MENOS f .)
    SEMI_COLON      reduce using rule 73 (e -> e MENOS f .)
    CONSOLE         reduce using rule 73 (e -> e MENOS f .)
    LET             reduce using rule 73 (e -> e MENOS f .)
    LITERAL         reduce using rule 73 (e -> e MENOS f .)
    IF              reduce using rule 73 (e -> e MENOS f .)
    WHILE           reduce using rule 73 (e -> e MENOS f .)
    FOR             reduce using rule 73 (e -> e MENOS f .)
    INTERFACE       reduce using rule 73 (e -> e MENOS f .)
    CONTINUE        reduce using rule 73 (e -> e MENOS f .)
    BREAK           reduce using rule 73 (e -> e MENOS f .)
    RETURN          reduce using rule 73 (e -> e MENOS f .)
    FUNCTION        reduce using rule 73 (e -> e MENOS f .)
    $end            reduce using rule 73 (e -> e MENOS f .)
    R_LLAVE         reduce using rule 73 (e -> e MENOS f .)
    R_PAREN         reduce using rule 73 (e -> e MENOS f .)
    COMA            reduce using rule 73 (e -> e MENOS f .)
    TIMES           shift and go to state 96
    DIVIDE          shift and go to state 97
    MOD             shift and go to state 98
    POTENCIA        shift and go to state 99


state 131

    (75) f -> f TIMES g .

    TIMES           reduce using rule 75 (f -> f TIMES g .)
    DIVIDE          reduce using rule 75 (f -> f TIMES g .)
    MOD             reduce using rule 75 (f -> f TIMES g .)
    POTENCIA        reduce using rule 75 (f -> f TIMES g .)
    MAS             reduce using rule 75 (f -> f TIMES g .)
    MENOS           reduce using rule 75 (f -> f TIMES g .)
    DISTINTO_QUE    reduce using rule 75 (f -> f TIMES g .)
    MENOR_QUE       reduce using rule 75 (f -> f TIMES g .)
    MENOR_IGUAL_QUE reduce using rule 75 (f -> f TIMES g .)
    MAYOR_QUE       reduce using rule 75 (f -> f TIMES g .)
    MAYOR_IGUAL_QUE reduce using rule 75 (f -> f TIMES g .)
    TRIPLE_IGUAL    reduce using rule 75 (f -> f TIMES g .)
    AND             reduce using rule 75 (f -> f TIMES g .)
    OR              reduce using rule 75 (f -> f TIMES g .)
    SEMI_COLON      reduce using rule 75 (f -> f TIMES g .)
    CONSOLE         reduce using rule 75 (f -> f TIMES g .)
    LET             reduce using rule 75 (f -> f TIMES g .)
    LITERAL         reduce using rule 75 (f -> f TIMES g .)
    IF              reduce using rule 75 (f -> f TIMES g .)
    WHILE           reduce using rule 75 (f -> f TIMES g .)
    FOR             reduce using rule 75 (f -> f TIMES g .)
    INTERFACE       reduce using rule 75 (f -> f TIMES g .)
    CONTINUE        reduce using rule 75 (f -> f TIMES g .)
    BREAK           reduce using rule 75 (f -> f TIMES g .)
    RETURN          reduce using rule 75 (f -> f TIMES g .)
    FUNCTION        reduce using rule 75 (f -> f TIMES g .)
    $end            reduce using rule 75 (f -> f TIMES g .)
    R_LLAVE         reduce using rule 75 (f -> f TIMES g .)
    R_PAREN         reduce using rule 75 (f -> f TIMES g .)
    COMA            reduce using rule 75 (f -> f TIMES g .)


state 132

    (76) f -> f DIVIDE g .

    TIMES           reduce using rule 76 (f -> f DIVIDE g .)
    DIVIDE          reduce using rule 76 (f -> f DIVIDE g .)
    MOD             reduce using rule 76 (f -> f DIVIDE g .)
    POTENCIA        reduce using rule 76 (f -> f DIVIDE g .)
    MAS             reduce using rule 76 (f -> f DIVIDE g .)
    MENOS           reduce using rule 76 (f -> f DIVIDE g .)
    DISTINTO_QUE    reduce using rule 76 (f -> f DIVIDE g .)
    MENOR_QUE       reduce using rule 76 (f -> f DIVIDE g .)
    MENOR_IGUAL_QUE reduce using rule 76 (f -> f DIVIDE g .)
    MAYOR_QUE       reduce using rule 76 (f -> f DIVIDE g .)
    MAYOR_IGUAL_QUE reduce using rule 76 (f -> f DIVIDE g .)
    TRIPLE_IGUAL    reduce using rule 76 (f -> f DIVIDE g .)
    AND             reduce using rule 76 (f -> f DIVIDE g .)
    OR              reduce using rule 76 (f -> f DIVIDE g .)
    SEMI_COLON      reduce using rule 76 (f -> f DIVIDE g .)
    CONSOLE         reduce using rule 76 (f -> f DIVIDE g .)
    LET             reduce using rule 76 (f -> f DIVIDE g .)
    LITERAL         reduce using rule 76 (f -> f DIVIDE g .)
    IF              reduce using rule 76 (f -> f DIVIDE g .)
    WHILE           reduce using rule 76 (f -> f DIVIDE g .)
    FOR             reduce using rule 76 (f -> f DIVIDE g .)
    INTERFACE       reduce using rule 76 (f -> f DIVIDE g .)
    CONTINUE        reduce using rule 76 (f -> f DIVIDE g .)
    BREAK           reduce using rule 76 (f -> f DIVIDE g .)
    RETURN          reduce using rule 76 (f -> f DIVIDE g .)
    FUNCTION        reduce using rule 76 (f -> f DIVIDE g .)
    $end            reduce using rule 76 (f -> f DIVIDE g .)
    R_LLAVE         reduce using rule 76 (f -> f DIVIDE g .)
    R_PAREN         reduce using rule 76 (f -> f DIVIDE g .)
    COMA            reduce using rule 76 (f -> f DIVIDE g .)


state 133

    (77) f -> f MOD g .

    TIMES           reduce using rule 77 (f -> f MOD g .)
    DIVIDE          reduce using rule 77 (f -> f MOD g .)
    MOD             reduce using rule 77 (f -> f MOD g .)
    POTENCIA        reduce using rule 77 (f -> f MOD g .)
    MAS             reduce using rule 77 (f -> f MOD g .)
    MENOS           reduce using rule 77 (f -> f MOD g .)
    DISTINTO_QUE    reduce using rule 77 (f -> f MOD g .)
    MENOR_QUE       reduce using rule 77 (f -> f MOD g .)
    MENOR_IGUAL_QUE reduce using rule 77 (f -> f MOD g .)
    MAYOR_QUE       reduce using rule 77 (f -> f MOD g .)
    MAYOR_IGUAL_QUE reduce using rule 77 (f -> f MOD g .)
    TRIPLE_IGUAL    reduce using rule 77 (f -> f MOD g .)
    AND             reduce using rule 77 (f -> f MOD g .)
    OR              reduce using rule 77 (f -> f MOD g .)
    SEMI_COLON      reduce using rule 77 (f -> f MOD g .)
    CONSOLE         reduce using rule 77 (f -> f MOD g .)
    LET             reduce using rule 77 (f -> f MOD g .)
    LITERAL         reduce using rule 77 (f -> f MOD g .)
    IF              reduce using rule 77 (f -> f MOD g .)
    WHILE           reduce using rule 77 (f -> f MOD g .)
    FOR             reduce using rule 77 (f -> f MOD g .)
    INTERFACE       reduce using rule 77 (f -> f MOD g .)
    CONTINUE        reduce using rule 77 (f -> f MOD g .)
    BREAK           reduce using rule 77 (f -> f MOD g .)
    RETURN          reduce using rule 77 (f -> f MOD g .)
    FUNCTION        reduce using rule 77 (f -> f MOD g .)
    $end            reduce using rule 77 (f -> f MOD g .)
    R_LLAVE         reduce using rule 77 (f -> f MOD g .)
    R_PAREN         reduce using rule 77 (f -> f MOD g .)
    COMA            reduce using rule 77 (f -> f MOD g .)


state 134

    (78) f -> f POTENCIA g .

    TIMES           reduce using rule 78 (f -> f POTENCIA g .)
    DIVIDE          reduce using rule 78 (f -> f POTENCIA g .)
    MOD             reduce using rule 78 (f -> f POTENCIA g .)
    POTENCIA        reduce using rule 78 (f -> f POTENCIA g .)
    MAS             reduce using rule 78 (f -> f POTENCIA g .)
    MENOS           reduce using rule 78 (f -> f POTENCIA g .)
    DISTINTO_QUE    reduce using rule 78 (f -> f POTENCIA g .)
    MENOR_QUE       reduce using rule 78 (f -> f POTENCIA g .)
    MENOR_IGUAL_QUE reduce using rule 78 (f -> f POTENCIA g .)
    MAYOR_QUE       reduce using rule 78 (f -> f POTENCIA g .)
    MAYOR_IGUAL_QUE reduce using rule 78 (f -> f POTENCIA g .)
    TRIPLE_IGUAL    reduce using rule 78 (f -> f POTENCIA g .)
    AND             reduce using rule 78 (f -> f POTENCIA g .)
    OR              reduce using rule 78 (f -> f POTENCIA g .)
    SEMI_COLON      reduce using rule 78 (f -> f POTENCIA g .)
    CONSOLE         reduce using rule 78 (f -> f POTENCIA g .)
    LET             reduce using rule 78 (f -> f POTENCIA g .)
    LITERAL         reduce using rule 78 (f -> f POTENCIA g .)
    IF              reduce using rule 78 (f -> f POTENCIA g .)
    WHILE           reduce using rule 78 (f -> f POTENCIA g .)
    FOR             reduce using rule 78 (f -> f POTENCIA g .)
    INTERFACE       reduce using rule 78 (f -> f POTENCIA g .)
    CONTINUE        reduce using rule 78 (f -> f POTENCIA g .)
    BREAK           reduce using rule 78 (f -> f POTENCIA g .)
    RETURN          reduce using rule 78 (f -> f POTENCIA g .)
    FUNCTION        reduce using rule 78 (f -> f POTENCIA g .)
    $end            reduce using rule 78 (f -> f POTENCIA g .)
    R_LLAVE         reduce using rule 78 (f -> f POTENCIA g .)
    R_PAREN         reduce using rule 78 (f -> f POTENCIA g .)
    COMA            reduce using rule 78 (f -> f POTENCIA g .)


state 135

    (80) f -> g PUNTO nativeFun . L_PAREN expresion R_PAREN

    L_PAREN         shift and go to state 164


state 136

    (92) nativeFun -> TOSTRING .

    L_PAREN         reduce using rule 92 (nativeFun -> TOSTRING .)


state 137

    (93) nativeFun -> TOFIXED .

    L_PAREN         reduce using rule 93 (nativeFun -> TOFIXED .)


state 138

    (94) nativeFun -> TOEXPONENTIAL .

    L_PAREN         reduce using rule 94 (nativeFun -> TOEXPONENTIAL .)


state 139

    (95) nativeFun -> TOLOWERCASE .

    L_PAREN         reduce using rule 95 (nativeFun -> TOLOWERCASE .)


state 140

    (96) nativeFun -> TOUPPERCASE .

    L_PAREN         reduce using rule 96 (nativeFun -> TOUPPERCASE .)


state 141

    (97) nativeFun -> SPLIT .

    L_PAREN         reduce using rule 97 (nativeFun -> SPLIT .)


state 142

    (98) nativeFun -> CONCAT .

    L_PAREN         reduce using rule 98 (nativeFun -> CONCAT .)


state 143

    (86) g -> L_PAREN a R_PAREN .

    PUNTO           reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    TIMES           reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    DIVIDE          reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    MOD             reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    POTENCIA        reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    MAS             reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    MENOS           reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    DISTINTO_QUE    reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    MENOR_QUE       reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    MENOR_IGUAL_QUE reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    MAYOR_QUE       reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    MAYOR_IGUAL_QUE reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    TRIPLE_IGUAL    reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    AND             reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    OR              reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    SEMI_COLON      reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    CONSOLE         reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    LET             reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    LITERAL         reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    IF              reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    WHILE           reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    FOR             reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    INTERFACE       reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    CONTINUE        reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    BREAK           reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    RETURN          reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    FUNCTION        reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    $end            reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    R_LLAVE         reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    R_PAREN         reduce using rule 86 (g -> L_PAREN a R_PAREN .)
    COMA            reduce using rule 86 (g -> L_PAREN a R_PAREN .)


state 144

    (89) interface_assi -> L_LLAVE atributos_assi R_LLAVE .

    PUNTO           reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    TIMES           reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    DIVIDE          reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MOD             reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    POTENCIA        reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MAS             reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MENOS           reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    DISTINTO_QUE    reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MENOR_QUE       reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MENOR_IGUAL_QUE reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MAYOR_QUE       reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MAYOR_IGUAL_QUE reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    TRIPLE_IGUAL    reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    AND             reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    OR              reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    SEMI_COLON      reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    CONSOLE         reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    LET             reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    LITERAL         reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    IF              reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    WHILE           reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    FOR             reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    INTERFACE       reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    CONTINUE        reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    BREAK           reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    RETURN          reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    FUNCTION        reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    $end            reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    R_LLAVE         reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    R_PAREN         reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    COMA            reduce using rule 89 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)


state 145

    (90) atributos_assi -> atributos_assi COMA . LITERAL COLON a

    LITERAL         shift and go to state 165


state 146

    (91) atributos_assi -> LITERAL COLON . a
    (59) a -> . a OR b
    (60) a -> . b
    (61) b -> . b AND c
    (62) b -> . c
    (63) c -> . NOT d
    (64) c -> . d
    (65) d -> . d DISTINTO_QUE e
    (66) d -> . d MENOR_QUE e
    (67) d -> . d MENOR_IGUAL_QUE e
    (68) d -> . d MAYOR_QUE e
    (69) d -> . d MAYOR_IGUAL_QUE e
    (70) d -> . d TRIPLE_IGUAL e
    (71) d -> . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 57
    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    a                              shift and go to state 166
    b                              shift and go to state 55
    c                              shift and go to state 56
    d                              shift and go to state 58
    e                              shift and go to state 59
    f                              shift and go to state 60
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 147

    (23) parameter_pro -> LITERAL . COLON type
    (24) parameter_pro -> LITERAL .

    COLON           shift and go to state 167
    R_PAREN         reduce using rule 24 (parameter_pro -> LITERAL .)
    COMA            reduce using rule 24 (parameter_pro -> LITERAL .)


state 148

    (19) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro . R_PAREN L_LLAVE instrucciones R_LLAVE
    (21) parameters_pro -> parameters_pro . COMA parameter_pro

    R_PAREN         shift and go to state 168
    COMA            shift and go to state 169


state 149

    (20) function_pro -> FUNCTION LITERAL L_PAREN R_PAREN . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 170


state 150

    (22) parameters_pro -> parameter_pro .

    R_PAREN         reduce using rule 22 (parameters_pro -> parameter_pro .)
    COMA            reduce using rule 22 (parameters_pro -> parameter_pro .)


state 151

    (56) console_pro -> CONSOLE PUNTO LOG L_PAREN expresion . R_PAREN
    (57) expresion -> expresion . COMA a

    R_PAREN         shift and go to state 171
    COMA            shift and go to state 172


state 152

    (58) expresion -> a .
    (59) a -> a . OR b

    R_PAREN         reduce using rule 58 (expresion -> a .)
    COMA            reduce using rule 58 (expresion -> a .)
    OR              shift and go to state 85


state 153

    (37) assignacion_instruction -> LITERAL COLON type IGUAL . a
    (59) a -> . a OR b
    (60) a -> . b
    (61) b -> . b AND c
    (62) b -> . c
    (63) c -> . NOT d
    (64) c -> . d
    (65) d -> . d DISTINTO_QUE e
    (66) d -> . d MENOR_QUE e
    (67) d -> . d MENOR_IGUAL_QUE e
    (68) d -> . d MAYOR_QUE e
    (69) d -> . d MAYOR_IGUAL_QUE e
    (70) d -> . d TRIPLE_IGUAL e
    (71) d -> . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 57
    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    a                              shift and go to state 173
    b                              shift and go to state 55
    c                              shift and go to state 56
    d                              shift and go to state 58
    e                              shift and go to state 59
    f                              shift and go to state 60
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 154

    (46) if_pro -> IF L_PAREN a R_PAREN L_LLAVE . instrucciones R_LLAVE else_pro
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . sumadores sc
    (56) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (34) declaration_instruction -> . LET declaracion_list
    (45) assig_pro -> . LITERAL IGUAL a
    (46) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (50) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (51) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (52) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (53) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (29) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (25) continue_pro -> . CONTINUE
    (26) break_pro -> . BREAK
    (27) return_pro -> . RETURN
    (28) return_pro -> . RETURN a
    (19) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (20) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (87) sumadores -> . LITERAL MAS MAS
    (88) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 17
    LET             shift and go to state 18
    LITERAL         shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    INTERFACE       shift and go to state 23
    CONTINUE        shift and go to state 24
    BREAK           shift and go to state 25
    RETURN          shift and go to state 26
    FUNCTION        shift and go to state 27

    instrucciones                  shift and go to state 174
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    sumadores                      shift and go to state 16

state 155

    (50) while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . sumadores sc
    (56) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (34) declaration_instruction -> . LET declaracion_list
    (45) assig_pro -> . LITERAL IGUAL a
    (46) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (50) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (51) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (52) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (53) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (29) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (25) continue_pro -> . CONTINUE
    (26) break_pro -> . BREAK
    (27) return_pro -> . RETURN
    (28) return_pro -> . RETURN a
    (19) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (20) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (87) sumadores -> . LITERAL MAS MAS
    (88) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 17
    LET             shift and go to state 18
    LITERAL         shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    INTERFACE       shift and go to state 23
    CONTINUE        shift and go to state 24
    BREAK           shift and go to state 25
    RETURN          shift and go to state 26
    FUNCTION        shift and go to state 27

    instrucciones                  shift and go to state 175
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    sumadores                      shift and go to state 16

state 156

    (51) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a . SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (59) a -> a . OR b

    SEMI_COLON      shift and go to state 176
    OR              shift and go to state 85


state 157

    (52) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a . SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (59) a -> a . OR b

    SEMI_COLON      shift and go to state 177
    OR              shift and go to state 85


state 158

    (53) for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . sumadores sc
    (56) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (34) declaration_instruction -> . LET declaracion_list
    (45) assig_pro -> . LITERAL IGUAL a
    (46) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (50) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (51) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (52) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (53) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (29) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (25) continue_pro -> . CONTINUE
    (26) break_pro -> . BREAK
    (27) return_pro -> . RETURN
    (28) return_pro -> . RETURN a
    (19) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (20) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (87) sumadores -> . LITERAL MAS MAS
    (88) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 17
    LET             shift and go to state 18
    LITERAL         shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    INTERFACE       shift and go to state 23
    CONTINUE        shift and go to state 24
    BREAK           shift and go to state 25
    RETURN          shift and go to state 26
    FUNCTION        shift and go to state 27

    instrucciones                  shift and go to state 178
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    sumadores                      shift and go to state 16

state 159

    (54) for_each_dec -> LET LITERAL OF . a
    (59) a -> . a OR b
    (60) a -> . b
    (61) b -> . b AND c
    (62) b -> . c
    (63) c -> . NOT d
    (64) c -> . d
    (65) d -> . d DISTINTO_QUE e
    (66) d -> . d MENOR_QUE e
    (67) d -> . d MENOR_IGUAL_QUE e
    (68) d -> . d MAYOR_QUE e
    (69) d -> . d MAYOR_IGUAL_QUE e
    (70) d -> . d TRIPLE_IGUAL e
    (71) d -> . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 57
    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    a                              shift and go to state 179
    b                              shift and go to state 55
    c                              shift and go to state 56
    d                              shift and go to state 58
    e                              shift and go to state 59
    f                              shift and go to state 60
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 160

    (55) for_each_dec -> LET LITERAL COLON . type OF a
    (37) assignacion_instruction -> LITERAL COLON . type IGUAL a
    (38) assignacion_instruction -> LITERAL COLON . type
    (40) type -> . NUMBER
    (41) type -> . STRING
    (42) type -> . BOOLEAN
    (43) type -> . ANY
    (44) type -> . LITERAL

    NUMBER          shift and go to state 109
    STRING          shift and go to state 110
    BOOLEAN         shift and go to state 111
    ANY             shift and go to state 112
    LITERAL         shift and go to state 107

    type                           shift and go to state 180

state 161

    (32) interface_atributo -> LITERAL . COLON type
    (33) interface_atributo -> LITERAL .

    COLON           shift and go to state 181
    SEMI_COLON      reduce using rule 33 (interface_atributo -> LITERAL .)
    R_LLAVE         reduce using rule 33 (interface_atributo -> LITERAL .)
    LITERAL         reduce using rule 33 (interface_atributo -> LITERAL .)


state 162

    (29) interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .

    SEMI_COLON      reduce using rule 29 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    CONSOLE         reduce using rule 29 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    LET             reduce using rule 29 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    LITERAL         reduce using rule 29 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    IF              reduce using rule 29 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    WHILE           reduce using rule 29 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    FOR             reduce using rule 29 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    INTERFACE       reduce using rule 29 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    CONTINUE        reduce using rule 29 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    BREAK           reduce using rule 29 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    RETURN          reduce using rule 29 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    FUNCTION        reduce using rule 29 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    $end            reduce using rule 29 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    R_LLAVE         reduce using rule 29 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)


state 163

    (30) interface_atributos -> interface_atributos interface_atributo . sc
    (17) sc -> . SEMI_COLON
    (18) sc -> .

    SEMI_COLON      shift and go to state 30
    R_LLAVE         reduce using rule 18 (sc -> .)
    LITERAL         reduce using rule 18 (sc -> .)

    sc                             shift and go to state 182

state 164

    (80) f -> g PUNTO nativeFun L_PAREN . expresion R_PAREN
    (57) expresion -> . expresion COMA a
    (58) expresion -> . a
    (59) a -> . a OR b
    (60) a -> . b
    (61) b -> . b AND c
    (62) b -> . c
    (63) c -> . NOT d
    (64) c -> . d
    (65) d -> . d DISTINTO_QUE e
    (66) d -> . d MENOR_QUE e
    (67) d -> . d MENOR_IGUAL_QUE e
    (68) d -> . d MAYOR_QUE e
    (69) d -> . d MAYOR_IGUAL_QUE e
    (70) d -> . d TRIPLE_IGUAL e
    (71) d -> . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 57
    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    g                              shift and go to state 61
    expresion                      shift and go to state 183
    a                              shift and go to state 152
    b                              shift and go to state 55
    c                              shift and go to state 56
    d                              shift and go to state 58
    e                              shift and go to state 59
    f                              shift and go to state 60
    interface_assi                 shift and go to state 67

state 165

    (90) atributos_assi -> atributos_assi COMA LITERAL . COLON a

    COLON           shift and go to state 184


state 166

    (91) atributos_assi -> LITERAL COLON a .
    (59) a -> a . OR b

    R_LLAVE         reduce using rule 91 (atributos_assi -> LITERAL COLON a .)
    COMA            reduce using rule 91 (atributos_assi -> LITERAL COLON a .)
    OR              shift and go to state 85


state 167

    (23) parameter_pro -> LITERAL COLON . type
    (40) type -> . NUMBER
    (41) type -> . STRING
    (42) type -> . BOOLEAN
    (43) type -> . ANY
    (44) type -> . LITERAL

    NUMBER          shift and go to state 109
    STRING          shift and go to state 110
    BOOLEAN         shift and go to state 111
    ANY             shift and go to state 112
    LITERAL         shift and go to state 107

    type                           shift and go to state 185

state 168

    (19) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 186


state 169

    (21) parameters_pro -> parameters_pro COMA . parameter_pro
    (23) parameter_pro -> . LITERAL COLON type
    (24) parameter_pro -> . LITERAL

    LITERAL         shift and go to state 147

    parameter_pro                  shift and go to state 187

state 170

    (20) function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . sumadores sc
    (56) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (34) declaration_instruction -> . LET declaracion_list
    (45) assig_pro -> . LITERAL IGUAL a
    (46) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (50) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (51) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (52) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (53) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (29) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (25) continue_pro -> . CONTINUE
    (26) break_pro -> . BREAK
    (27) return_pro -> . RETURN
    (28) return_pro -> . RETURN a
    (19) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (20) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (87) sumadores -> . LITERAL MAS MAS
    (88) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 17
    LET             shift and go to state 18
    LITERAL         shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    INTERFACE       shift and go to state 23
    CONTINUE        shift and go to state 24
    BREAK           shift and go to state 25
    RETURN          shift and go to state 26
    FUNCTION        shift and go to state 27

    instrucciones                  shift and go to state 188
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    sumadores                      shift and go to state 16

state 171

    (56) console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .

    SEMI_COLON      reduce using rule 56 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    CONSOLE         reduce using rule 56 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    LET             reduce using rule 56 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    LITERAL         reduce using rule 56 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    IF              reduce using rule 56 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    WHILE           reduce using rule 56 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    FOR             reduce using rule 56 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    INTERFACE       reduce using rule 56 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    CONTINUE        reduce using rule 56 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    BREAK           reduce using rule 56 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    RETURN          reduce using rule 56 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    FUNCTION        reduce using rule 56 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    $end            reduce using rule 56 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    R_LLAVE         reduce using rule 56 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)


state 172

    (57) expresion -> expresion COMA . a
    (59) a -> . a OR b
    (60) a -> . b
    (61) b -> . b AND c
    (62) b -> . c
    (63) c -> . NOT d
    (64) c -> . d
    (65) d -> . d DISTINTO_QUE e
    (66) d -> . d MENOR_QUE e
    (67) d -> . d MENOR_IGUAL_QUE e
    (68) d -> . d MAYOR_QUE e
    (69) d -> . d MAYOR_IGUAL_QUE e
    (70) d -> . d TRIPLE_IGUAL e
    (71) d -> . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 57
    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    a                              shift and go to state 189
    b                              shift and go to state 55
    c                              shift and go to state 56
    d                              shift and go to state 58
    e                              shift and go to state 59
    f                              shift and go to state 60
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 173

    (37) assignacion_instruction -> LITERAL COLON type IGUAL a .
    (59) a -> a . OR b

    COMA            reduce using rule 37 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    SEMI_COLON      reduce using rule 37 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    CONSOLE         reduce using rule 37 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    LET             reduce using rule 37 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    LITERAL         reduce using rule 37 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    IF              reduce using rule 37 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    WHILE           reduce using rule 37 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    FOR             reduce using rule 37 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    INTERFACE       reduce using rule 37 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    CONTINUE        reduce using rule 37 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    BREAK           reduce using rule 37 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    RETURN          reduce using rule 37 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    FUNCTION        reduce using rule 37 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    $end            reduce using rule 37 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    R_LLAVE         reduce using rule 37 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    OR              shift and go to state 85


state 174

    (46) if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones . R_LLAVE else_pro
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . sumadores sc
    (56) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (34) declaration_instruction -> . LET declaracion_list
    (45) assig_pro -> . LITERAL IGUAL a
    (46) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (50) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (51) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (52) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (53) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (29) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (25) continue_pro -> . CONTINUE
    (26) break_pro -> . BREAK
    (27) return_pro -> . RETURN
    (28) return_pro -> . RETURN a
    (19) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (20) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (87) sumadores -> . LITERAL MAS MAS
    (88) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 190
    CONSOLE         shift and go to state 17
    LET             shift and go to state 18
    LITERAL         shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    INTERFACE       shift and go to state 23
    CONTINUE        shift and go to state 24
    BREAK           shift and go to state 25
    RETURN          shift and go to state 26
    FUNCTION        shift and go to state 27

    instruccion                    shift and go to state 28
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    sumadores                      shift and go to state 16

state 175

    (50) while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . sumadores sc
    (56) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (34) declaration_instruction -> . LET declaracion_list
    (45) assig_pro -> . LITERAL IGUAL a
    (46) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (50) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (51) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (52) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (53) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (29) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (25) continue_pro -> . CONTINUE
    (26) break_pro -> . BREAK
    (27) return_pro -> . RETURN
    (28) return_pro -> . RETURN a
    (19) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (20) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (87) sumadores -> . LITERAL MAS MAS
    (88) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 191
    CONSOLE         shift and go to state 17
    LET             shift and go to state 18
    LITERAL         shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    INTERFACE       shift and go to state 23
    CONTINUE        shift and go to state 24
    BREAK           shift and go to state 25
    RETURN          shift and go to state 26
    FUNCTION        shift and go to state 27

    instruccion                    shift and go to state 28
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    sumadores                      shift and go to state 16

state 176

    (51) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON . assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (45) assig_pro -> . LITERAL IGUAL a

    LITERAL         shift and go to state 83

    assig_pro                      shift and go to state 192

state 177

    (52) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON . assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (45) assig_pro -> . LITERAL IGUAL a

    LITERAL         shift and go to state 83

    assig_pro                      shift and go to state 193

state 178

    (53) for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . sumadores sc
    (56) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (34) declaration_instruction -> . LET declaracion_list
    (45) assig_pro -> . LITERAL IGUAL a
    (46) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (50) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (51) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (52) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (53) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (29) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (25) continue_pro -> . CONTINUE
    (26) break_pro -> . BREAK
    (27) return_pro -> . RETURN
    (28) return_pro -> . RETURN a
    (19) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (20) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (87) sumadores -> . LITERAL MAS MAS
    (88) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 194
    CONSOLE         shift and go to state 17
    LET             shift and go to state 18
    LITERAL         shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    INTERFACE       shift and go to state 23
    CONTINUE        shift and go to state 24
    BREAK           shift and go to state 25
    RETURN          shift and go to state 26
    FUNCTION        shift and go to state 27

    instruccion                    shift and go to state 28
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    sumadores                      shift and go to state 16

state 179

    (54) for_each_dec -> LET LITERAL OF a .
    (59) a -> a . OR b

    R_PAREN         reduce using rule 54 (for_each_dec -> LET LITERAL OF a .)
    OR              shift and go to state 85


state 180

    (55) for_each_dec -> LET LITERAL COLON type . OF a
    (37) assignacion_instruction -> LITERAL COLON type . IGUAL a
    (38) assignacion_instruction -> LITERAL COLON type .

    OF              shift and go to state 195
    IGUAL           shift and go to state 153
    COMA            reduce using rule 38 (assignacion_instruction -> LITERAL COLON type .)
    SEMI_COLON      reduce using rule 38 (assignacion_instruction -> LITERAL COLON type .)


state 181

    (32) interface_atributo -> LITERAL COLON . type
    (40) type -> . NUMBER
    (41) type -> . STRING
    (42) type -> . BOOLEAN
    (43) type -> . ANY
    (44) type -> . LITERAL

    NUMBER          shift and go to state 109
    STRING          shift and go to state 110
    BOOLEAN         shift and go to state 111
    ANY             shift and go to state 112
    LITERAL         shift and go to state 107

    type                           shift and go to state 196

state 182

    (30) interface_atributos -> interface_atributos interface_atributo sc .

    R_LLAVE         reduce using rule 30 (interface_atributos -> interface_atributos interface_atributo sc .)
    LITERAL         reduce using rule 30 (interface_atributos -> interface_atributos interface_atributo sc .)


state 183

    (80) f -> g PUNTO nativeFun L_PAREN expresion . R_PAREN
    (57) expresion -> expresion . COMA a

    R_PAREN         shift and go to state 197
    COMA            shift and go to state 172


state 184

    (90) atributos_assi -> atributos_assi COMA LITERAL COLON . a
    (59) a -> . a OR b
    (60) a -> . b
    (61) b -> . b AND c
    (62) b -> . c
    (63) c -> . NOT d
    (64) c -> . d
    (65) d -> . d DISTINTO_QUE e
    (66) d -> . d MENOR_QUE e
    (67) d -> . d MENOR_IGUAL_QUE e
    (68) d -> . d MAYOR_QUE e
    (69) d -> . d MAYOR_IGUAL_QUE e
    (70) d -> . d TRIPLE_IGUAL e
    (71) d -> . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 57
    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    a                              shift and go to state 198
    b                              shift and go to state 55
    c                              shift and go to state 56
    d                              shift and go to state 58
    e                              shift and go to state 59
    f                              shift and go to state 60
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 185

    (23) parameter_pro -> LITERAL COLON type .

    R_PAREN         reduce using rule 23 (parameter_pro -> LITERAL COLON type .)
    COMA            reduce using rule 23 (parameter_pro -> LITERAL COLON type .)


state 186

    (19) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . sumadores sc
    (56) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (34) declaration_instruction -> . LET declaracion_list
    (45) assig_pro -> . LITERAL IGUAL a
    (46) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (50) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (51) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (52) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (53) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (29) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (25) continue_pro -> . CONTINUE
    (26) break_pro -> . BREAK
    (27) return_pro -> . RETURN
    (28) return_pro -> . RETURN a
    (19) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (20) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (87) sumadores -> . LITERAL MAS MAS
    (88) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 17
    LET             shift and go to state 18
    LITERAL         shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    INTERFACE       shift and go to state 23
    CONTINUE        shift and go to state 24
    BREAK           shift and go to state 25
    RETURN          shift and go to state 26
    FUNCTION        shift and go to state 27

    instrucciones                  shift and go to state 199
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    sumadores                      shift and go to state 16

state 187

    (21) parameters_pro -> parameters_pro COMA parameter_pro .

    R_PAREN         reduce using rule 21 (parameters_pro -> parameters_pro COMA parameter_pro .)
    COMA            reduce using rule 21 (parameters_pro -> parameters_pro COMA parameter_pro .)


state 188

    (20) function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . sumadores sc
    (56) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (34) declaration_instruction -> . LET declaracion_list
    (45) assig_pro -> . LITERAL IGUAL a
    (46) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (50) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (51) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (52) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (53) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (29) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (25) continue_pro -> . CONTINUE
    (26) break_pro -> . BREAK
    (27) return_pro -> . RETURN
    (28) return_pro -> . RETURN a
    (19) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (20) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (87) sumadores -> . LITERAL MAS MAS
    (88) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 200
    CONSOLE         shift and go to state 17
    LET             shift and go to state 18
    LITERAL         shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    INTERFACE       shift and go to state 23
    CONTINUE        shift and go to state 24
    BREAK           shift and go to state 25
    RETURN          shift and go to state 26
    FUNCTION        shift and go to state 27

    instruccion                    shift and go to state 28
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    sumadores                      shift and go to state 16

state 189

    (57) expresion -> expresion COMA a .
    (59) a -> a . OR b

    R_PAREN         reduce using rule 57 (expresion -> expresion COMA a .)
    COMA            reduce using rule 57 (expresion -> expresion COMA a .)
    OR              shift and go to state 85


state 190

    (46) if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE . else_pro
    (47) else_pro -> . ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (48) else_pro -> . ELSE L_LLAVE instrucciones R_LLAVE
    (49) else_pro -> .

    ELSE            shift and go to state 202
    SEMI_COLON      reduce using rule 49 (else_pro -> .)
    CONSOLE         reduce using rule 49 (else_pro -> .)
    LET             reduce using rule 49 (else_pro -> .)
    LITERAL         reduce using rule 49 (else_pro -> .)
    IF              reduce using rule 49 (else_pro -> .)
    WHILE           reduce using rule 49 (else_pro -> .)
    FOR             reduce using rule 49 (else_pro -> .)
    INTERFACE       reduce using rule 49 (else_pro -> .)
    CONTINUE        reduce using rule 49 (else_pro -> .)
    BREAK           reduce using rule 49 (else_pro -> .)
    RETURN          reduce using rule 49 (else_pro -> .)
    FUNCTION        reduce using rule 49 (else_pro -> .)
    $end            reduce using rule 49 (else_pro -> .)
    R_LLAVE         reduce using rule 49 (else_pro -> .)

    else_pro                       shift and go to state 201

state 191

    (50) while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 50 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 50 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 50 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 50 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 50 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 50 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 50 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 50 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONTINUE        reduce using rule 50 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    BREAK           reduce using rule 50 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    RETURN          reduce using rule 50 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FUNCTION        reduce using rule 50 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 50 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 50 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 192

    (51) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro . R_PAREN L_LLAVE instrucciones R_LLAVE

    R_PAREN         shift and go to state 203


state 193

    (52) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro . R_PAREN L_LLAVE instrucciones R_LLAVE

    R_PAREN         shift and go to state 204


state 194

    (53) for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 53 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 53 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 53 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 53 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 53 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 53 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 53 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 53 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONTINUE        reduce using rule 53 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    BREAK           reduce using rule 53 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    RETURN          reduce using rule 53 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FUNCTION        reduce using rule 53 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 53 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 53 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 195

    (55) for_each_dec -> LET LITERAL COLON type OF . a
    (59) a -> . a OR b
    (60) a -> . b
    (61) b -> . b AND c
    (62) b -> . c
    (63) c -> . NOT d
    (64) c -> . d
    (65) d -> . d DISTINTO_QUE e
    (66) d -> . d MENOR_QUE e
    (67) d -> . d MENOR_IGUAL_QUE e
    (68) d -> . d MAYOR_QUE e
    (69) d -> . d MAYOR_IGUAL_QUE e
    (70) d -> . d TRIPLE_IGUAL e
    (71) d -> . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 57
    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    a                              shift and go to state 205
    b                              shift and go to state 55
    c                              shift and go to state 56
    d                              shift and go to state 58
    e                              shift and go to state 59
    f                              shift and go to state 60
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 196

    (32) interface_atributo -> LITERAL COLON type .

    SEMI_COLON      reduce using rule 32 (interface_atributo -> LITERAL COLON type .)
    R_LLAVE         reduce using rule 32 (interface_atributo -> LITERAL COLON type .)
    LITERAL         reduce using rule 32 (interface_atributo -> LITERAL COLON type .)


state 197

    (80) f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .

    TIMES           reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    DIVIDE          reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MOD             reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    POTENCIA        reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MAS             reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MENOS           reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    DISTINTO_QUE    reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MENOR_QUE       reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MENOR_IGUAL_QUE reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MAYOR_QUE       reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MAYOR_IGUAL_QUE reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    TRIPLE_IGUAL    reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    AND             reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    OR              reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    SEMI_COLON      reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    CONSOLE         reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    LET             reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    LITERAL         reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    IF              reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    WHILE           reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    FOR             reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    INTERFACE       reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    CONTINUE        reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    BREAK           reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    RETURN          reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    FUNCTION        reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    $end            reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    R_LLAVE         reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    R_PAREN         reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    COMA            reduce using rule 80 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)


state 198

    (90) atributos_assi -> atributos_assi COMA LITERAL COLON a .
    (59) a -> a . OR b

    R_LLAVE         reduce using rule 90 (atributos_assi -> atributos_assi COMA LITERAL COLON a .)
    COMA            reduce using rule 90 (atributos_assi -> atributos_assi COMA LITERAL COLON a .)
    OR              shift and go to state 85


state 199

    (19) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . sumadores sc
    (56) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (34) declaration_instruction -> . LET declaracion_list
    (45) assig_pro -> . LITERAL IGUAL a
    (46) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (50) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (51) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (52) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (53) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (29) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (25) continue_pro -> . CONTINUE
    (26) break_pro -> . BREAK
    (27) return_pro -> . RETURN
    (28) return_pro -> . RETURN a
    (19) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (20) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (87) sumadores -> . LITERAL MAS MAS
    (88) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 206
    CONSOLE         shift and go to state 17
    LET             shift and go to state 18
    LITERAL         shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    INTERFACE       shift and go to state 23
    CONTINUE        shift and go to state 24
    BREAK           shift and go to state 25
    RETURN          shift and go to state 26
    FUNCTION        shift and go to state 27

    instruccion                    shift and go to state 28
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    sumadores                      shift and go to state 16

state 200

    (20) function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONTINUE        reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    BREAK           reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    RETURN          reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FUNCTION        reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 201

    (46) if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .

    SEMI_COLON      reduce using rule 46 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    CONSOLE         reduce using rule 46 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    LET             reduce using rule 46 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    LITERAL         reduce using rule 46 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    IF              reduce using rule 46 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    WHILE           reduce using rule 46 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    FOR             reduce using rule 46 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    INTERFACE       reduce using rule 46 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    CONTINUE        reduce using rule 46 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    BREAK           reduce using rule 46 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    RETURN          reduce using rule 46 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    FUNCTION        reduce using rule 46 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    $end            reduce using rule 46 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    R_LLAVE         reduce using rule 46 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)


state 202

    (47) else_pro -> ELSE . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (48) else_pro -> ELSE . L_LLAVE instrucciones R_LLAVE

    IF              shift and go to state 207
    L_LLAVE         shift and go to state 208


state 203

    (51) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 209


state 204

    (52) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 210


state 205

    (55) for_each_dec -> LET LITERAL COLON type OF a .
    (59) a -> a . OR b

    R_PAREN         reduce using rule 55 (for_each_dec -> LET LITERAL COLON type OF a .)
    OR              shift and go to state 85


state 206

    (19) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 19 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 19 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 19 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 19 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 19 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 19 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 19 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 19 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONTINUE        reduce using rule 19 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    BREAK           reduce using rule 19 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    RETURN          reduce using rule 19 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FUNCTION        reduce using rule 19 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 19 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 19 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 207

    (47) else_pro -> ELSE IF . L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro

    L_PAREN         shift and go to state 211


state 208

    (48) else_pro -> ELSE L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . sumadores sc
    (56) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (34) declaration_instruction -> . LET declaracion_list
    (45) assig_pro -> . LITERAL IGUAL a
    (46) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (50) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (51) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (52) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (53) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (29) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (25) continue_pro -> . CONTINUE
    (26) break_pro -> . BREAK
    (27) return_pro -> . RETURN
    (28) return_pro -> . RETURN a
    (19) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (20) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (87) sumadores -> . LITERAL MAS MAS
    (88) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 17
    LET             shift and go to state 18
    LITERAL         shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    INTERFACE       shift and go to state 23
    CONTINUE        shift and go to state 24
    BREAK           shift and go to state 25
    RETURN          shift and go to state 26
    FUNCTION        shift and go to state 27

    instrucciones                  shift and go to state 212
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    sumadores                      shift and go to state 16

state 209

    (51) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . sumadores sc
    (56) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (34) declaration_instruction -> . LET declaracion_list
    (45) assig_pro -> . LITERAL IGUAL a
    (46) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (50) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (51) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (52) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (53) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (29) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (25) continue_pro -> . CONTINUE
    (26) break_pro -> . BREAK
    (27) return_pro -> . RETURN
    (28) return_pro -> . RETURN a
    (19) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (20) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (87) sumadores -> . LITERAL MAS MAS
    (88) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 17
    LET             shift and go to state 18
    LITERAL         shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    INTERFACE       shift and go to state 23
    CONTINUE        shift and go to state 24
    BREAK           shift and go to state 25
    RETURN          shift and go to state 26
    FUNCTION        shift and go to state 27

    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    instrucciones                  shift and go to state 213
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    sumadores                      shift and go to state 16

state 210

    (52) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . sumadores sc
    (56) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (34) declaration_instruction -> . LET declaracion_list
    (45) assig_pro -> . LITERAL IGUAL a
    (46) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (50) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (51) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (52) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (53) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (29) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (25) continue_pro -> . CONTINUE
    (26) break_pro -> . BREAK
    (27) return_pro -> . RETURN
    (28) return_pro -> . RETURN a
    (19) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (20) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (87) sumadores -> . LITERAL MAS MAS
    (88) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 17
    LET             shift and go to state 18
    LITERAL         shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    INTERFACE       shift and go to state 23
    CONTINUE        shift and go to state 24
    BREAK           shift and go to state 25
    RETURN          shift and go to state 26
    FUNCTION        shift and go to state 27

    assig_pro                      shift and go to state 6
    instrucciones                  shift and go to state 214
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    sumadores                      shift and go to state 16

state 211

    (47) else_pro -> ELSE IF L_PAREN . a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (59) a -> . a OR b
    (60) a -> . b
    (61) b -> . b AND c
    (62) b -> . c
    (63) c -> . NOT d
    (64) c -> . d
    (65) d -> . d DISTINTO_QUE e
    (66) d -> . d MENOR_QUE e
    (67) d -> . d MENOR_IGUAL_QUE e
    (68) d -> . d MAYOR_QUE e
    (69) d -> . d MAYOR_IGUAL_QUE e
    (70) d -> . d TRIPLE_IGUAL e
    (71) d -> . e
    (72) e -> . e MAS f
    (73) e -> . e MENOS f
    (74) e -> . f
    (75) f -> . f TIMES g
    (76) f -> . f DIVIDE g
    (77) f -> . f MOD g
    (78) f -> . f POTENCIA g
    (79) f -> . g
    (80) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (81) g -> . ENTERO
    (82) g -> . DECIMAL
    (83) g -> . CADENA
    (84) g -> . LITERAL
    (85) g -> . interface_assi
    (86) g -> . L_PAREN a R_PAREN
    (89) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 57
    ENTERO          shift and go to state 63
    DECIMAL         shift and go to state 64
    CADENA          shift and go to state 65
    LITERAL         shift and go to state 66
    L_PAREN         shift and go to state 62
    L_LLAVE         shift and go to state 68

    a                              shift and go to state 215
    b                              shift and go to state 55
    c                              shift and go to state 56
    d                              shift and go to state 58
    e                              shift and go to state 59
    f                              shift and go to state 60
    g                              shift and go to state 61
    interface_assi                 shift and go to state 67

state 212

    (48) else_pro -> ELSE L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . sumadores sc
    (56) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (34) declaration_instruction -> . LET declaracion_list
    (45) assig_pro -> . LITERAL IGUAL a
    (46) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (50) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (51) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (52) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (53) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (29) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (25) continue_pro -> . CONTINUE
    (26) break_pro -> . BREAK
    (27) return_pro -> . RETURN
    (28) return_pro -> . RETURN a
    (19) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (20) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (87) sumadores -> . LITERAL MAS MAS
    (88) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 216
    CONSOLE         shift and go to state 17
    LET             shift and go to state 18
    LITERAL         shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    INTERFACE       shift and go to state 23
    CONTINUE        shift and go to state 24
    BREAK           shift and go to state 25
    RETURN          shift and go to state 26
    FUNCTION        shift and go to state 27

    instruccion                    shift and go to state 28
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    sumadores                      shift and go to state 16

state 213

    (51) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . sumadores sc
    (56) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (34) declaration_instruction -> . LET declaracion_list
    (45) assig_pro -> . LITERAL IGUAL a
    (46) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (50) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (51) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (52) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (53) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (29) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (25) continue_pro -> . CONTINUE
    (26) break_pro -> . BREAK
    (27) return_pro -> . RETURN
    (28) return_pro -> . RETURN a
    (19) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (20) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (87) sumadores -> . LITERAL MAS MAS
    (88) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 217
    CONSOLE         shift and go to state 17
    LET             shift and go to state 18
    LITERAL         shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    INTERFACE       shift and go to state 23
    CONTINUE        shift and go to state 24
    BREAK           shift and go to state 25
    RETURN          shift and go to state 26
    FUNCTION        shift and go to state 27

    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    instruccion                    shift and go to state 28
    console_pro                    shift and go to state 4
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    sumadores                      shift and go to state 16

state 214

    (52) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . sumadores sc
    (56) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (34) declaration_instruction -> . LET declaracion_list
    (45) assig_pro -> . LITERAL IGUAL a
    (46) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (50) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (51) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (52) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (53) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (29) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (25) continue_pro -> . CONTINUE
    (26) break_pro -> . BREAK
    (27) return_pro -> . RETURN
    (28) return_pro -> . RETURN a
    (19) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (20) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (87) sumadores -> . LITERAL MAS MAS
    (88) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 218
    CONSOLE         shift and go to state 17
    LET             shift and go to state 18
    LITERAL         shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    INTERFACE       shift and go to state 23
    CONTINUE        shift and go to state 24
    BREAK           shift and go to state 25
    RETURN          shift and go to state 26
    FUNCTION        shift and go to state 27

    assig_pro                      shift and go to state 6
    instruccion                    shift and go to state 28
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    sumadores                      shift and go to state 16

state 215

    (47) else_pro -> ELSE IF L_PAREN a . R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (59) a -> a . OR b

    R_PAREN         shift and go to state 219
    OR              shift and go to state 85


state 216

    (48) else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 48 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 48 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 48 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 48 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 48 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 48 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 48 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 48 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    CONTINUE        reduce using rule 48 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    BREAK           reduce using rule 48 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    RETURN          reduce using rule 48 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    FUNCTION        reduce using rule 48 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 48 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 48 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)


state 217

    (51) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 51 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 51 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 51 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 51 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 51 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 51 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 51 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 51 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONTINUE        reduce using rule 51 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    BREAK           reduce using rule 51 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    RETURN          reduce using rule 51 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FUNCTION        reduce using rule 51 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 51 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 51 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 218

    (52) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 52 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 52 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 52 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 52 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 52 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 52 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 52 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 52 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONTINUE        reduce using rule 52 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    BREAK           reduce using rule 52 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    RETURN          reduce using rule 52 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FUNCTION        reduce using rule 52 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 52 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 52 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 219

    (47) else_pro -> ELSE IF L_PAREN a R_PAREN . L_LLAVE instrucciones R_LLAVE else_pro

    L_LLAVE         shift and go to state 220


state 220

    (47) else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE . instrucciones R_LLAVE else_pro
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . sumadores sc
    (56) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (34) declaration_instruction -> . LET declaracion_list
    (45) assig_pro -> . LITERAL IGUAL a
    (46) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (50) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (51) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (52) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (53) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (29) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (25) continue_pro -> . CONTINUE
    (26) break_pro -> . BREAK
    (27) return_pro -> . RETURN
    (28) return_pro -> . RETURN a
    (19) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (20) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (87) sumadores -> . LITERAL MAS MAS
    (88) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 17
    LET             shift and go to state 18
    LITERAL         shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    INTERFACE       shift and go to state 23
    CONTINUE        shift and go to state 24
    BREAK           shift and go to state 25
    RETURN          shift and go to state 26
    FUNCTION        shift and go to state 27

    instrucciones                  shift and go to state 221
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    sumadores                      shift and go to state 16

state 221

    (47) else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones . R_LLAVE else_pro
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . sumadores sc
    (56) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (34) declaration_instruction -> . LET declaracion_list
    (45) assig_pro -> . LITERAL IGUAL a
    (46) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (50) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (51) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (52) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (53) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (29) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (25) continue_pro -> . CONTINUE
    (26) break_pro -> . BREAK
    (27) return_pro -> . RETURN
    (28) return_pro -> . RETURN a
    (19) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (20) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (87) sumadores -> . LITERAL MAS MAS
    (88) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 222
    CONSOLE         shift and go to state 17
    LET             shift and go to state 18
    LITERAL         shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    INTERFACE       shift and go to state 23
    CONTINUE        shift and go to state 24
    BREAK           shift and go to state 25
    RETURN          shift and go to state 26
    FUNCTION        shift and go to state 27

    instruccion                    shift and go to state 28
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    sumadores                      shift and go to state 16

state 222

    (47) else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE . else_pro
    (47) else_pro -> . ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (48) else_pro -> . ELSE L_LLAVE instrucciones R_LLAVE
    (49) else_pro -> .

    ELSE            shift and go to state 202
    SEMI_COLON      reduce using rule 49 (else_pro -> .)
    CONSOLE         reduce using rule 49 (else_pro -> .)
    LET             reduce using rule 49 (else_pro -> .)
    LITERAL         reduce using rule 49 (else_pro -> .)
    IF              reduce using rule 49 (else_pro -> .)
    WHILE           reduce using rule 49 (else_pro -> .)
    FOR             reduce using rule 49 (else_pro -> .)
    INTERFACE       reduce using rule 49 (else_pro -> .)
    CONTINUE        reduce using rule 49 (else_pro -> .)
    BREAK           reduce using rule 49 (else_pro -> .)
    RETURN          reduce using rule 49 (else_pro -> .)
    FUNCTION        reduce using rule 49 (else_pro -> .)
    $end            reduce using rule 49 (else_pro -> .)
    R_LLAVE         reduce using rule 49 (else_pro -> .)

    else_pro                       shift and go to state 223

state 223

    (47) else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .

    SEMI_COLON      reduce using rule 47 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    CONSOLE         reduce using rule 47 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    LET             reduce using rule 47 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    LITERAL         reduce using rule 47 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    IF              reduce using rule 47 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    WHILE           reduce using rule 47 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    FOR             reduce using rule 47 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    INTERFACE       reduce using rule 47 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    CONTINUE        reduce using rule 47 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    BREAK           reduce using rule 47 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    RETURN          reduce using rule 47 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    FUNCTION        reduce using rule 47 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    $end            reduce using rule 47 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    R_LLAVE         reduce using rule 47 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LITERAL in state 26 resolved as shift
