Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BREAK
    CONTINUE
    FUNCTION
    INTERFACE
    L_CORCHETE
    NULL
    RETURN
    R_CORCHETE

Grammar

Rule 0     S' -> init
Rule 1     init -> instrucciones
Rule 2     instrucciones -> instrucciones instruccion
Rule 3     instrucciones -> instruccion
Rule 4     instruccion -> console_pro sc
Rule 5     instruccion -> declaration_instruction sc
Rule 6     instruccion -> assig_pro sc
Rule 7     instruccion -> if_pro sc
Rule 8     instruccion -> while_pro sc
Rule 9     instruccion -> for_pro sc
Rule 10    instruccion -> for_each_pro sc
Rule 11    instruccion -> sumadores sc
Rule 12    sc -> SEMI_COLON
Rule 13    sc -> <empty>
Rule 14    declaration_instruction -> LET declaracion_list
Rule 15    declaracion_list -> declaracion_list COMA assignacion_instruction
Rule 16    declaracion_list -> assignacion_instruction
Rule 17    assignacion_instruction -> LITERAL COLON type IGUAL a
Rule 18    assignacion_instruction -> LITERAL COLON type
Rule 19    assignacion_instruction -> LITERAL IGUAL a
Rule 20    type -> NUMBER
Rule 21    type -> STRING
Rule 22    type -> BOOLEAN
Rule 23    type -> ANY
Rule 24    assig_pro -> LITERAL IGUAL a
Rule 25    if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
Rule 26    else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
Rule 27    else_pro -> ELSE L_LLAVE instrucciones R_LLAVE
Rule 28    else_pro -> <empty>
Rule 29    while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 30    for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 31    for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 32    for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 33    for_each_dec -> LET LITERAL OF a
Rule 34    for_each_dec -> LET LITERAL COLON type OF a
Rule 35    console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
Rule 36    expresion -> expresion COMA a
Rule 37    expresion -> a
Rule 38    a -> a OR b
Rule 39    a -> b
Rule 40    b -> b AND c
Rule 41    b -> c
Rule 42    c -> NOT d
Rule 43    c -> d
Rule 44    d -> d DISTINTO_QUE e
Rule 45    d -> d MENOR_QUE e
Rule 46    d -> d MENOR_IGUAL_QUE e
Rule 47    d -> d MAYOR_QUE e
Rule 48    d -> d MAYOR_IGUAL_QUE e
Rule 49    d -> d TRIPLE_IGUAL e
Rule 50    d -> e
Rule 51    e -> e MAS f
Rule 52    e -> e MENOS f
Rule 53    e -> f
Rule 54    f -> f TIMES g
Rule 55    f -> f DIVIDE g
Rule 56    f -> f MOD g
Rule 57    f -> f POTENCIA g
Rule 58    f -> g
Rule 59    f -> g PUNTO nativeFun L_PAREN expresion R_PAREN
Rule 60    g -> ENTERO
Rule 61    g -> DECIMAL
Rule 62    g -> CADENA
Rule 63    g -> LITERAL
Rule 64    g -> L_PAREN a R_PAREN
Rule 65    sumadores -> LITERAL MAS MAS
Rule 66    sumadores -> LITERAL MENOS MENOS
Rule 67    nativeFun -> TOSTRING
Rule 68    nativeFun -> TOFIXED
Rule 69    nativeFun -> TOEXPONENTIAL
Rule 70    nativeFun -> TOLOWERCASE
Rule 71    nativeFun -> TOUPPERCASE
Rule 72    nativeFun -> SPLIT
Rule 73    nativeFun -> CONCAT

Terminals, with rules where they appear

AND                  : 40
ANY                  : 23
BOOLEAN              : 22
BREAK                : 
CADENA               : 62
COLON                : 17 18 34
COMA                 : 15 36
CONCAT               : 73
CONSOLE              : 35
CONTINUE             : 
DECIMAL              : 61
DISTINTO_QUE         : 44
DIVIDE               : 55
ELSE                 : 26 27
ENTERO               : 60
FOR                  : 30 31 32
FUNCTION             : 
IF                   : 25 26
IGUAL                : 17 19 24
INTERFACE            : 
LET                  : 14 33 34
LITERAL              : 17 18 19 24 33 34 63 65 66
LOG                  : 35
L_CORCHETE           : 
L_LLAVE              : 25 26 27 29 30 31 32
L_PAREN              : 25 26 29 30 31 32 35 59 64
MAS                  : 51 65 65
MAYOR_IGUAL_QUE      : 48
MAYOR_QUE            : 47
MENOR_IGUAL_QUE      : 46
MENOR_QUE            : 45
MENOS                : 52 66 66
MOD                  : 56
NOT                  : 42
NULL                 : 
NUMBER               : 20
OF                   : 33 34
OR                   : 38
POTENCIA             : 57
PUNTO                : 35 59
RETURN               : 
R_CORCHETE           : 
R_LLAVE              : 25 26 27 29 30 31 32
R_PAREN              : 25 26 29 30 31 32 35 59 64
SEMI_COLON           : 12 30 30 31 31
SPLIT                : 72
STRING               : 21
TIMES                : 54
TOEXPONENTIAL        : 69
TOFIXED              : 68
TOLOWERCASE          : 70
TOSTRING             : 67
TOUPPERCASE          : 71
TRIPLE_IGUAL         : 49
WHILE                : 29
error                : 

Nonterminals, with rules where they appear

a                    : 17 19 24 25 26 29 30 31 33 34 36 37 38 64
assig_pro            : 6 30 31 31
assignacion_instruction : 15 16
b                    : 38 39 40
c                    : 40 41
console_pro          : 4
d                    : 42 43 44 45 46 47 48 49
declaracion_list     : 14 15
declaration_instruction : 5 30
e                    : 44 45 46 47 48 49 50 51 52
else_pro             : 25 26
expresion            : 35 36 59
f                    : 51 52 53 54 55 56 57
for_each_dec         : 32
for_each_pro         : 10
for_pro              : 9
g                    : 54 55 56 57 58 59
if_pro               : 7
init                 : 0
instruccion          : 2 3
instrucciones        : 1 2 25 26 27 29 30 31 32
nativeFun            : 59
sc                   : 4 5 6 7 8 9 10 11
sumadores            : 11
type                 : 17 18 34
while_pro            : 8

Parsing method: LALR

state 0

    (0) S' -> . init
    (1) init -> . instrucciones
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . sumadores sc
    (35) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (14) declaration_instruction -> . LET declaracion_list
    (24) assig_pro -> . LITERAL IGUAL a
    (25) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (29) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (30) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (31) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (32) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (65) sumadores -> . LITERAL MAS MAS
    (66) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 12
    LET             shift and go to state 13
    LITERAL         shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17

    init                           shift and go to state 1
    instrucciones                  shift and go to state 2
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    sumadores                      shift and go to state 11

state 1

    (0) S' -> init .



state 2

    (1) init -> instrucciones .
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . sumadores sc
    (35) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (14) declaration_instruction -> . LET declaracion_list
    (24) assig_pro -> . LITERAL IGUAL a
    (25) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (29) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (30) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (31) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (32) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (65) sumadores -> . LITERAL MAS MAS
    (66) sumadores -> . LITERAL MENOS MENOS

    $end            reduce using rule 1 (init -> instrucciones .)
    CONSOLE         shift and go to state 12
    LET             shift and go to state 13
    LITERAL         shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17

    instruccion                    shift and go to state 18
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    sumadores                      shift and go to state 11

state 3

    (3) instrucciones -> instruccion .

    CONSOLE         reduce using rule 3 (instrucciones -> instruccion .)
    LET             reduce using rule 3 (instrucciones -> instruccion .)
    LITERAL         reduce using rule 3 (instrucciones -> instruccion .)
    IF              reduce using rule 3 (instrucciones -> instruccion .)
    WHILE           reduce using rule 3 (instrucciones -> instruccion .)
    FOR             reduce using rule 3 (instrucciones -> instruccion .)
    $end            reduce using rule 3 (instrucciones -> instruccion .)
    R_LLAVE         reduce using rule 3 (instrucciones -> instruccion .)


state 4

    (4) instruccion -> console_pro . sc
    (12) sc -> . SEMI_COLON
    (13) sc -> .

    SEMI_COLON      shift and go to state 20
    CONSOLE         reduce using rule 13 (sc -> .)
    LET             reduce using rule 13 (sc -> .)
    LITERAL         reduce using rule 13 (sc -> .)
    IF              reduce using rule 13 (sc -> .)
    WHILE           reduce using rule 13 (sc -> .)
    FOR             reduce using rule 13 (sc -> .)
    $end            reduce using rule 13 (sc -> .)
    R_LLAVE         reduce using rule 13 (sc -> .)

    sc                             shift and go to state 19

state 5

    (5) instruccion -> declaration_instruction . sc
    (12) sc -> . SEMI_COLON
    (13) sc -> .

    SEMI_COLON      shift and go to state 20
    CONSOLE         reduce using rule 13 (sc -> .)
    LET             reduce using rule 13 (sc -> .)
    LITERAL         reduce using rule 13 (sc -> .)
    IF              reduce using rule 13 (sc -> .)
    WHILE           reduce using rule 13 (sc -> .)
    FOR             reduce using rule 13 (sc -> .)
    $end            reduce using rule 13 (sc -> .)
    R_LLAVE         reduce using rule 13 (sc -> .)

    sc                             shift and go to state 21

state 6

    (6) instruccion -> assig_pro . sc
    (12) sc -> . SEMI_COLON
    (13) sc -> .

    SEMI_COLON      shift and go to state 20
    CONSOLE         reduce using rule 13 (sc -> .)
    LET             reduce using rule 13 (sc -> .)
    LITERAL         reduce using rule 13 (sc -> .)
    IF              reduce using rule 13 (sc -> .)
    WHILE           reduce using rule 13 (sc -> .)
    FOR             reduce using rule 13 (sc -> .)
    $end            reduce using rule 13 (sc -> .)
    R_LLAVE         reduce using rule 13 (sc -> .)

    sc                             shift and go to state 22

state 7

    (7) instruccion -> if_pro . sc
    (12) sc -> . SEMI_COLON
    (13) sc -> .

    SEMI_COLON      shift and go to state 20
    CONSOLE         reduce using rule 13 (sc -> .)
    LET             reduce using rule 13 (sc -> .)
    LITERAL         reduce using rule 13 (sc -> .)
    IF              reduce using rule 13 (sc -> .)
    WHILE           reduce using rule 13 (sc -> .)
    FOR             reduce using rule 13 (sc -> .)
    $end            reduce using rule 13 (sc -> .)
    R_LLAVE         reduce using rule 13 (sc -> .)

    sc                             shift and go to state 23

state 8

    (8) instruccion -> while_pro . sc
    (12) sc -> . SEMI_COLON
    (13) sc -> .

    SEMI_COLON      shift and go to state 20
    CONSOLE         reduce using rule 13 (sc -> .)
    LET             reduce using rule 13 (sc -> .)
    LITERAL         reduce using rule 13 (sc -> .)
    IF              reduce using rule 13 (sc -> .)
    WHILE           reduce using rule 13 (sc -> .)
    FOR             reduce using rule 13 (sc -> .)
    $end            reduce using rule 13 (sc -> .)
    R_LLAVE         reduce using rule 13 (sc -> .)

    sc                             shift and go to state 24

state 9

    (9) instruccion -> for_pro . sc
    (12) sc -> . SEMI_COLON
    (13) sc -> .

    SEMI_COLON      shift and go to state 20
    CONSOLE         reduce using rule 13 (sc -> .)
    LET             reduce using rule 13 (sc -> .)
    LITERAL         reduce using rule 13 (sc -> .)
    IF              reduce using rule 13 (sc -> .)
    WHILE           reduce using rule 13 (sc -> .)
    FOR             reduce using rule 13 (sc -> .)
    $end            reduce using rule 13 (sc -> .)
    R_LLAVE         reduce using rule 13 (sc -> .)

    sc                             shift and go to state 25

state 10

    (10) instruccion -> for_each_pro . sc
    (12) sc -> . SEMI_COLON
    (13) sc -> .

    SEMI_COLON      shift and go to state 20
    CONSOLE         reduce using rule 13 (sc -> .)
    LET             reduce using rule 13 (sc -> .)
    LITERAL         reduce using rule 13 (sc -> .)
    IF              reduce using rule 13 (sc -> .)
    WHILE           reduce using rule 13 (sc -> .)
    FOR             reduce using rule 13 (sc -> .)
    $end            reduce using rule 13 (sc -> .)
    R_LLAVE         reduce using rule 13 (sc -> .)

    sc                             shift and go to state 26

state 11

    (11) instruccion -> sumadores . sc
    (12) sc -> . SEMI_COLON
    (13) sc -> .

    SEMI_COLON      shift and go to state 20
    CONSOLE         reduce using rule 13 (sc -> .)
    LET             reduce using rule 13 (sc -> .)
    LITERAL         reduce using rule 13 (sc -> .)
    IF              reduce using rule 13 (sc -> .)
    WHILE           reduce using rule 13 (sc -> .)
    FOR             reduce using rule 13 (sc -> .)
    $end            reduce using rule 13 (sc -> .)
    R_LLAVE         reduce using rule 13 (sc -> .)

    sc                             shift and go to state 27

state 12

    (35) console_pro -> CONSOLE . PUNTO LOG L_PAREN expresion R_PAREN

    PUNTO           shift and go to state 28


state 13

    (14) declaration_instruction -> LET . declaracion_list
    (15) declaracion_list -> . declaracion_list COMA assignacion_instruction
    (16) declaracion_list -> . assignacion_instruction
    (17) assignacion_instruction -> . LITERAL COLON type IGUAL a
    (18) assignacion_instruction -> . LITERAL COLON type
    (19) assignacion_instruction -> . LITERAL IGUAL a

    LITERAL         shift and go to state 31

    declaracion_list               shift and go to state 29
    assignacion_instruction        shift and go to state 30

state 14

    (24) assig_pro -> LITERAL . IGUAL a
    (65) sumadores -> LITERAL . MAS MAS
    (66) sumadores -> LITERAL . MENOS MENOS

    IGUAL           shift and go to state 32
    MAS             shift and go to state 33
    MENOS           shift and go to state 34


state 15

    (25) if_pro -> IF . L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro

    L_PAREN         shift and go to state 35


state 16

    (29) while_pro -> WHILE . L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE

    L_PAREN         shift and go to state 36


state 17

    (30) for_pro -> FOR . L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (31) for_pro -> FOR . L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (32) for_each_pro -> FOR . L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE

    L_PAREN         shift and go to state 37


state 18

    (2) instrucciones -> instrucciones instruccion .

    CONSOLE         reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    LET             reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    LITERAL         reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    IF              reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    WHILE           reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    FOR             reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    $end            reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    R_LLAVE         reduce using rule 2 (instrucciones -> instrucciones instruccion .)


state 19

    (4) instruccion -> console_pro sc .

    CONSOLE         reduce using rule 4 (instruccion -> console_pro sc .)
    LET             reduce using rule 4 (instruccion -> console_pro sc .)
    LITERAL         reduce using rule 4 (instruccion -> console_pro sc .)
    IF              reduce using rule 4 (instruccion -> console_pro sc .)
    WHILE           reduce using rule 4 (instruccion -> console_pro sc .)
    FOR             reduce using rule 4 (instruccion -> console_pro sc .)
    $end            reduce using rule 4 (instruccion -> console_pro sc .)
    R_LLAVE         reduce using rule 4 (instruccion -> console_pro sc .)


state 20

    (12) sc -> SEMI_COLON .

    CONSOLE         reduce using rule 12 (sc -> SEMI_COLON .)
    LET             reduce using rule 12 (sc -> SEMI_COLON .)
    LITERAL         reduce using rule 12 (sc -> SEMI_COLON .)
    IF              reduce using rule 12 (sc -> SEMI_COLON .)
    WHILE           reduce using rule 12 (sc -> SEMI_COLON .)
    FOR             reduce using rule 12 (sc -> SEMI_COLON .)
    $end            reduce using rule 12 (sc -> SEMI_COLON .)
    R_LLAVE         reduce using rule 12 (sc -> SEMI_COLON .)


state 21

    (5) instruccion -> declaration_instruction sc .

    CONSOLE         reduce using rule 5 (instruccion -> declaration_instruction sc .)
    LET             reduce using rule 5 (instruccion -> declaration_instruction sc .)
    LITERAL         reduce using rule 5 (instruccion -> declaration_instruction sc .)
    IF              reduce using rule 5 (instruccion -> declaration_instruction sc .)
    WHILE           reduce using rule 5 (instruccion -> declaration_instruction sc .)
    FOR             reduce using rule 5 (instruccion -> declaration_instruction sc .)
    $end            reduce using rule 5 (instruccion -> declaration_instruction sc .)
    R_LLAVE         reduce using rule 5 (instruccion -> declaration_instruction sc .)


state 22

    (6) instruccion -> assig_pro sc .

    CONSOLE         reduce using rule 6 (instruccion -> assig_pro sc .)
    LET             reduce using rule 6 (instruccion -> assig_pro sc .)
    LITERAL         reduce using rule 6 (instruccion -> assig_pro sc .)
    IF              reduce using rule 6 (instruccion -> assig_pro sc .)
    WHILE           reduce using rule 6 (instruccion -> assig_pro sc .)
    FOR             reduce using rule 6 (instruccion -> assig_pro sc .)
    $end            reduce using rule 6 (instruccion -> assig_pro sc .)
    R_LLAVE         reduce using rule 6 (instruccion -> assig_pro sc .)


state 23

    (7) instruccion -> if_pro sc .

    CONSOLE         reduce using rule 7 (instruccion -> if_pro sc .)
    LET             reduce using rule 7 (instruccion -> if_pro sc .)
    LITERAL         reduce using rule 7 (instruccion -> if_pro sc .)
    IF              reduce using rule 7 (instruccion -> if_pro sc .)
    WHILE           reduce using rule 7 (instruccion -> if_pro sc .)
    FOR             reduce using rule 7 (instruccion -> if_pro sc .)
    $end            reduce using rule 7 (instruccion -> if_pro sc .)
    R_LLAVE         reduce using rule 7 (instruccion -> if_pro sc .)


state 24

    (8) instruccion -> while_pro sc .

    CONSOLE         reduce using rule 8 (instruccion -> while_pro sc .)
    LET             reduce using rule 8 (instruccion -> while_pro sc .)
    LITERAL         reduce using rule 8 (instruccion -> while_pro sc .)
    IF              reduce using rule 8 (instruccion -> while_pro sc .)
    WHILE           reduce using rule 8 (instruccion -> while_pro sc .)
    FOR             reduce using rule 8 (instruccion -> while_pro sc .)
    $end            reduce using rule 8 (instruccion -> while_pro sc .)
    R_LLAVE         reduce using rule 8 (instruccion -> while_pro sc .)


state 25

    (9) instruccion -> for_pro sc .

    CONSOLE         reduce using rule 9 (instruccion -> for_pro sc .)
    LET             reduce using rule 9 (instruccion -> for_pro sc .)
    LITERAL         reduce using rule 9 (instruccion -> for_pro sc .)
    IF              reduce using rule 9 (instruccion -> for_pro sc .)
    WHILE           reduce using rule 9 (instruccion -> for_pro sc .)
    FOR             reduce using rule 9 (instruccion -> for_pro sc .)
    $end            reduce using rule 9 (instruccion -> for_pro sc .)
    R_LLAVE         reduce using rule 9 (instruccion -> for_pro sc .)


state 26

    (10) instruccion -> for_each_pro sc .

    CONSOLE         reduce using rule 10 (instruccion -> for_each_pro sc .)
    LET             reduce using rule 10 (instruccion -> for_each_pro sc .)
    LITERAL         reduce using rule 10 (instruccion -> for_each_pro sc .)
    IF              reduce using rule 10 (instruccion -> for_each_pro sc .)
    WHILE           reduce using rule 10 (instruccion -> for_each_pro sc .)
    FOR             reduce using rule 10 (instruccion -> for_each_pro sc .)
    $end            reduce using rule 10 (instruccion -> for_each_pro sc .)
    R_LLAVE         reduce using rule 10 (instruccion -> for_each_pro sc .)


state 27

    (11) instruccion -> sumadores sc .

    CONSOLE         reduce using rule 11 (instruccion -> sumadores sc .)
    LET             reduce using rule 11 (instruccion -> sumadores sc .)
    LITERAL         reduce using rule 11 (instruccion -> sumadores sc .)
    IF              reduce using rule 11 (instruccion -> sumadores sc .)
    WHILE           reduce using rule 11 (instruccion -> sumadores sc .)
    FOR             reduce using rule 11 (instruccion -> sumadores sc .)
    $end            reduce using rule 11 (instruccion -> sumadores sc .)
    R_LLAVE         reduce using rule 11 (instruccion -> sumadores sc .)


state 28

    (35) console_pro -> CONSOLE PUNTO . LOG L_PAREN expresion R_PAREN

    LOG             shift and go to state 38


state 29

    (14) declaration_instruction -> LET declaracion_list .
    (15) declaracion_list -> declaracion_list . COMA assignacion_instruction

    SEMI_COLON      reduce using rule 14 (declaration_instruction -> LET declaracion_list .)
    CONSOLE         reduce using rule 14 (declaration_instruction -> LET declaracion_list .)
    LET             reduce using rule 14 (declaration_instruction -> LET declaracion_list .)
    LITERAL         reduce using rule 14 (declaration_instruction -> LET declaracion_list .)
    IF              reduce using rule 14 (declaration_instruction -> LET declaracion_list .)
    WHILE           reduce using rule 14 (declaration_instruction -> LET declaracion_list .)
    FOR             reduce using rule 14 (declaration_instruction -> LET declaracion_list .)
    $end            reduce using rule 14 (declaration_instruction -> LET declaracion_list .)
    R_LLAVE         reduce using rule 14 (declaration_instruction -> LET declaracion_list .)
    COMA            shift and go to state 39


state 30

    (16) declaracion_list -> assignacion_instruction .

    COMA            reduce using rule 16 (declaracion_list -> assignacion_instruction .)
    SEMI_COLON      reduce using rule 16 (declaracion_list -> assignacion_instruction .)
    CONSOLE         reduce using rule 16 (declaracion_list -> assignacion_instruction .)
    LET             reduce using rule 16 (declaracion_list -> assignacion_instruction .)
    LITERAL         reduce using rule 16 (declaracion_list -> assignacion_instruction .)
    IF              reduce using rule 16 (declaracion_list -> assignacion_instruction .)
    WHILE           reduce using rule 16 (declaracion_list -> assignacion_instruction .)
    FOR             reduce using rule 16 (declaracion_list -> assignacion_instruction .)
    $end            reduce using rule 16 (declaracion_list -> assignacion_instruction .)
    R_LLAVE         reduce using rule 16 (declaracion_list -> assignacion_instruction .)


state 31

    (17) assignacion_instruction -> LITERAL . COLON type IGUAL a
    (18) assignacion_instruction -> LITERAL . COLON type
    (19) assignacion_instruction -> LITERAL . IGUAL a

    COLON           shift and go to state 40
    IGUAL           shift and go to state 41


state 32

    (24) assig_pro -> LITERAL IGUAL . a
    (38) a -> . a OR b
    (39) a -> . b
    (40) b -> . b AND c
    (41) b -> . c
    (42) c -> . NOT d
    (43) c -> . d
    (44) d -> . d DISTINTO_QUE e
    (45) d -> . d MENOR_QUE e
    (46) d -> . d MENOR_IGUAL_QUE e
    (47) d -> . d MAYOR_QUE e
    (48) d -> . d MAYOR_IGUAL_QUE e
    (49) d -> . d TRIPLE_IGUAL e
    (50) d -> . e
    (51) e -> . e MAS f
    (52) e -> . e MENOS f
    (53) e -> . f
    (54) f -> . f TIMES g
    (55) f -> . f DIVIDE g
    (56) f -> . f MOD g
    (57) f -> . f POTENCIA g
    (58) f -> . g
    (59) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    NOT             shift and go to state 46
    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    a                              shift and go to state 43
    b                              shift and go to state 44
    c                              shift and go to state 45
    d                              shift and go to state 47
    e                              shift and go to state 48
    f                              shift and go to state 49
    g                              shift and go to state 50

state 33

    (65) sumadores -> LITERAL MAS . MAS

    MAS             shift and go to state 55


state 34

    (66) sumadores -> LITERAL MENOS . MENOS

    MENOS           shift and go to state 56


state 35

    (25) if_pro -> IF L_PAREN . a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (38) a -> . a OR b
    (39) a -> . b
    (40) b -> . b AND c
    (41) b -> . c
    (42) c -> . NOT d
    (43) c -> . d
    (44) d -> . d DISTINTO_QUE e
    (45) d -> . d MENOR_QUE e
    (46) d -> . d MENOR_IGUAL_QUE e
    (47) d -> . d MAYOR_QUE e
    (48) d -> . d MAYOR_IGUAL_QUE e
    (49) d -> . d TRIPLE_IGUAL e
    (50) d -> . e
    (51) e -> . e MAS f
    (52) e -> . e MENOS f
    (53) e -> . f
    (54) f -> . f TIMES g
    (55) f -> . f DIVIDE g
    (56) f -> . f MOD g
    (57) f -> . f POTENCIA g
    (58) f -> . g
    (59) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    NOT             shift and go to state 46
    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    a                              shift and go to state 57
    b                              shift and go to state 44
    c                              shift and go to state 45
    d                              shift and go to state 47
    e                              shift and go to state 48
    f                              shift and go to state 49
    g                              shift and go to state 50

state 36

    (29) while_pro -> WHILE L_PAREN . a R_PAREN L_LLAVE instrucciones R_LLAVE
    (38) a -> . a OR b
    (39) a -> . b
    (40) b -> . b AND c
    (41) b -> . c
    (42) c -> . NOT d
    (43) c -> . d
    (44) d -> . d DISTINTO_QUE e
    (45) d -> . d MENOR_QUE e
    (46) d -> . d MENOR_IGUAL_QUE e
    (47) d -> . d MAYOR_QUE e
    (48) d -> . d MAYOR_IGUAL_QUE e
    (49) d -> . d TRIPLE_IGUAL e
    (50) d -> . e
    (51) e -> . e MAS f
    (52) e -> . e MENOS f
    (53) e -> . f
    (54) f -> . f TIMES g
    (55) f -> . f DIVIDE g
    (56) f -> . f MOD g
    (57) f -> . f POTENCIA g
    (58) f -> . g
    (59) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    NOT             shift and go to state 46
    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    a                              shift and go to state 58
    b                              shift and go to state 44
    c                              shift and go to state 45
    d                              shift and go to state 47
    e                              shift and go to state 48
    f                              shift and go to state 49
    g                              shift and go to state 50

state 37

    (30) for_pro -> FOR L_PAREN . declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (31) for_pro -> FOR L_PAREN . assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (32) for_each_pro -> FOR L_PAREN . for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (14) declaration_instruction -> . LET declaracion_list
    (24) assig_pro -> . LITERAL IGUAL a
    (33) for_each_dec -> . LET LITERAL OF a
    (34) for_each_dec -> . LET LITERAL COLON type OF a

    LET             shift and go to state 62
    LITERAL         shift and go to state 63

    declaration_instruction        shift and go to state 59
    assig_pro                      shift and go to state 60
    for_each_dec                   shift and go to state 61

state 38

    (35) console_pro -> CONSOLE PUNTO LOG . L_PAREN expresion R_PAREN

    L_PAREN         shift and go to state 64


state 39

    (15) declaracion_list -> declaracion_list COMA . assignacion_instruction
    (17) assignacion_instruction -> . LITERAL COLON type IGUAL a
    (18) assignacion_instruction -> . LITERAL COLON type
    (19) assignacion_instruction -> . LITERAL IGUAL a

    LITERAL         shift and go to state 31

    assignacion_instruction        shift and go to state 65

state 40

    (17) assignacion_instruction -> LITERAL COLON . type IGUAL a
    (18) assignacion_instruction -> LITERAL COLON . type
    (20) type -> . NUMBER
    (21) type -> . STRING
    (22) type -> . BOOLEAN
    (23) type -> . ANY

    NUMBER          shift and go to state 67
    STRING          shift and go to state 68
    BOOLEAN         shift and go to state 69
    ANY             shift and go to state 70

    type                           shift and go to state 66

state 41

    (19) assignacion_instruction -> LITERAL IGUAL . a
    (38) a -> . a OR b
    (39) a -> . b
    (40) b -> . b AND c
    (41) b -> . c
    (42) c -> . NOT d
    (43) c -> . d
    (44) d -> . d DISTINTO_QUE e
    (45) d -> . d MENOR_QUE e
    (46) d -> . d MENOR_IGUAL_QUE e
    (47) d -> . d MAYOR_QUE e
    (48) d -> . d MAYOR_IGUAL_QUE e
    (49) d -> . d TRIPLE_IGUAL e
    (50) d -> . e
    (51) e -> . e MAS f
    (52) e -> . e MENOS f
    (53) e -> . f
    (54) f -> . f TIMES g
    (55) f -> . f DIVIDE g
    (56) f -> . f MOD g
    (57) f -> . f POTENCIA g
    (58) f -> . g
    (59) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    NOT             shift and go to state 46
    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    a                              shift and go to state 71
    b                              shift and go to state 44
    c                              shift and go to state 45
    d                              shift and go to state 47
    e                              shift and go to state 48
    f                              shift and go to state 49
    g                              shift and go to state 50

state 42

    (63) g -> LITERAL .

    PUNTO           reduce using rule 63 (g -> LITERAL .)
    TIMES           reduce using rule 63 (g -> LITERAL .)
    DIVIDE          reduce using rule 63 (g -> LITERAL .)
    MOD             reduce using rule 63 (g -> LITERAL .)
    POTENCIA        reduce using rule 63 (g -> LITERAL .)
    MAS             reduce using rule 63 (g -> LITERAL .)
    MENOS           reduce using rule 63 (g -> LITERAL .)
    DISTINTO_QUE    reduce using rule 63 (g -> LITERAL .)
    MENOR_QUE       reduce using rule 63 (g -> LITERAL .)
    MENOR_IGUAL_QUE reduce using rule 63 (g -> LITERAL .)
    MAYOR_QUE       reduce using rule 63 (g -> LITERAL .)
    MAYOR_IGUAL_QUE reduce using rule 63 (g -> LITERAL .)
    TRIPLE_IGUAL    reduce using rule 63 (g -> LITERAL .)
    AND             reduce using rule 63 (g -> LITERAL .)
    OR              reduce using rule 63 (g -> LITERAL .)
    SEMI_COLON      reduce using rule 63 (g -> LITERAL .)
    CONSOLE         reduce using rule 63 (g -> LITERAL .)
    LET             reduce using rule 63 (g -> LITERAL .)
    LITERAL         reduce using rule 63 (g -> LITERAL .)
    IF              reduce using rule 63 (g -> LITERAL .)
    WHILE           reduce using rule 63 (g -> LITERAL .)
    FOR             reduce using rule 63 (g -> LITERAL .)
    $end            reduce using rule 63 (g -> LITERAL .)
    R_LLAVE         reduce using rule 63 (g -> LITERAL .)
    R_PAREN         reduce using rule 63 (g -> LITERAL .)
    COMA            reduce using rule 63 (g -> LITERAL .)


state 43

    (24) assig_pro -> LITERAL IGUAL a .
    (38) a -> a . OR b

    SEMI_COLON      reduce using rule 24 (assig_pro -> LITERAL IGUAL a .)
    CONSOLE         reduce using rule 24 (assig_pro -> LITERAL IGUAL a .)
    LET             reduce using rule 24 (assig_pro -> LITERAL IGUAL a .)
    LITERAL         reduce using rule 24 (assig_pro -> LITERAL IGUAL a .)
    IF              reduce using rule 24 (assig_pro -> LITERAL IGUAL a .)
    WHILE           reduce using rule 24 (assig_pro -> LITERAL IGUAL a .)
    FOR             reduce using rule 24 (assig_pro -> LITERAL IGUAL a .)
    $end            reduce using rule 24 (assig_pro -> LITERAL IGUAL a .)
    R_LLAVE         reduce using rule 24 (assig_pro -> LITERAL IGUAL a .)
    R_PAREN         reduce using rule 24 (assig_pro -> LITERAL IGUAL a .)
    OR              shift and go to state 72


state 44

    (39) a -> b .
    (40) b -> b . AND c

    OR              reduce using rule 39 (a -> b .)
    SEMI_COLON      reduce using rule 39 (a -> b .)
    CONSOLE         reduce using rule 39 (a -> b .)
    LET             reduce using rule 39 (a -> b .)
    LITERAL         reduce using rule 39 (a -> b .)
    IF              reduce using rule 39 (a -> b .)
    WHILE           reduce using rule 39 (a -> b .)
    FOR             reduce using rule 39 (a -> b .)
    $end            reduce using rule 39 (a -> b .)
    R_LLAVE         reduce using rule 39 (a -> b .)
    R_PAREN         reduce using rule 39 (a -> b .)
    COMA            reduce using rule 39 (a -> b .)
    AND             shift and go to state 73


state 45

    (41) b -> c .

    AND             reduce using rule 41 (b -> c .)
    OR              reduce using rule 41 (b -> c .)
    SEMI_COLON      reduce using rule 41 (b -> c .)
    CONSOLE         reduce using rule 41 (b -> c .)
    LET             reduce using rule 41 (b -> c .)
    LITERAL         reduce using rule 41 (b -> c .)
    IF              reduce using rule 41 (b -> c .)
    WHILE           reduce using rule 41 (b -> c .)
    FOR             reduce using rule 41 (b -> c .)
    $end            reduce using rule 41 (b -> c .)
    R_LLAVE         reduce using rule 41 (b -> c .)
    R_PAREN         reduce using rule 41 (b -> c .)
    COMA            reduce using rule 41 (b -> c .)


state 46

    (42) c -> NOT . d
    (44) d -> . d DISTINTO_QUE e
    (45) d -> . d MENOR_QUE e
    (46) d -> . d MENOR_IGUAL_QUE e
    (47) d -> . d MAYOR_QUE e
    (48) d -> . d MAYOR_IGUAL_QUE e
    (49) d -> . d TRIPLE_IGUAL e
    (50) d -> . e
    (51) e -> . e MAS f
    (52) e -> . e MENOS f
    (53) e -> . f
    (54) f -> . f TIMES g
    (55) f -> . f DIVIDE g
    (56) f -> . f MOD g
    (57) f -> . f POTENCIA g
    (58) f -> . g
    (59) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    d                              shift and go to state 74
    e                              shift and go to state 48
    f                              shift and go to state 49
    g                              shift and go to state 50

state 47

    (43) c -> d .
    (44) d -> d . DISTINTO_QUE e
    (45) d -> d . MENOR_QUE e
    (46) d -> d . MENOR_IGUAL_QUE e
    (47) d -> d . MAYOR_QUE e
    (48) d -> d . MAYOR_IGUAL_QUE e
    (49) d -> d . TRIPLE_IGUAL e

    AND             reduce using rule 43 (c -> d .)
    OR              reduce using rule 43 (c -> d .)
    SEMI_COLON      reduce using rule 43 (c -> d .)
    CONSOLE         reduce using rule 43 (c -> d .)
    LET             reduce using rule 43 (c -> d .)
    LITERAL         reduce using rule 43 (c -> d .)
    IF              reduce using rule 43 (c -> d .)
    WHILE           reduce using rule 43 (c -> d .)
    FOR             reduce using rule 43 (c -> d .)
    $end            reduce using rule 43 (c -> d .)
    R_LLAVE         reduce using rule 43 (c -> d .)
    R_PAREN         reduce using rule 43 (c -> d .)
    COMA            reduce using rule 43 (c -> d .)
    DISTINTO_QUE    shift and go to state 75
    MENOR_QUE       shift and go to state 76
    MENOR_IGUAL_QUE shift and go to state 77
    MAYOR_QUE       shift and go to state 78
    MAYOR_IGUAL_QUE shift and go to state 79
    TRIPLE_IGUAL    shift and go to state 80


state 48

    (50) d -> e .
    (51) e -> e . MAS f
    (52) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 50 (d -> e .)
    MENOR_QUE       reduce using rule 50 (d -> e .)
    MENOR_IGUAL_QUE reduce using rule 50 (d -> e .)
    MAYOR_QUE       reduce using rule 50 (d -> e .)
    MAYOR_IGUAL_QUE reduce using rule 50 (d -> e .)
    TRIPLE_IGUAL    reduce using rule 50 (d -> e .)
    AND             reduce using rule 50 (d -> e .)
    OR              reduce using rule 50 (d -> e .)
    SEMI_COLON      reduce using rule 50 (d -> e .)
    CONSOLE         reduce using rule 50 (d -> e .)
    LET             reduce using rule 50 (d -> e .)
    LITERAL         reduce using rule 50 (d -> e .)
    IF              reduce using rule 50 (d -> e .)
    WHILE           reduce using rule 50 (d -> e .)
    FOR             reduce using rule 50 (d -> e .)
    $end            reduce using rule 50 (d -> e .)
    R_LLAVE         reduce using rule 50 (d -> e .)
    R_PAREN         reduce using rule 50 (d -> e .)
    COMA            reduce using rule 50 (d -> e .)
    MAS             shift and go to state 81
    MENOS           shift and go to state 82


state 49

    (53) e -> f .
    (54) f -> f . TIMES g
    (55) f -> f . DIVIDE g
    (56) f -> f . MOD g
    (57) f -> f . POTENCIA g

    MAS             reduce using rule 53 (e -> f .)
    MENOS           reduce using rule 53 (e -> f .)
    DISTINTO_QUE    reduce using rule 53 (e -> f .)
    MENOR_QUE       reduce using rule 53 (e -> f .)
    MENOR_IGUAL_QUE reduce using rule 53 (e -> f .)
    MAYOR_QUE       reduce using rule 53 (e -> f .)
    MAYOR_IGUAL_QUE reduce using rule 53 (e -> f .)
    TRIPLE_IGUAL    reduce using rule 53 (e -> f .)
    AND             reduce using rule 53 (e -> f .)
    OR              reduce using rule 53 (e -> f .)
    SEMI_COLON      reduce using rule 53 (e -> f .)
    CONSOLE         reduce using rule 53 (e -> f .)
    LET             reduce using rule 53 (e -> f .)
    LITERAL         reduce using rule 53 (e -> f .)
    IF              reduce using rule 53 (e -> f .)
    WHILE           reduce using rule 53 (e -> f .)
    FOR             reduce using rule 53 (e -> f .)
    $end            reduce using rule 53 (e -> f .)
    R_LLAVE         reduce using rule 53 (e -> f .)
    R_PAREN         reduce using rule 53 (e -> f .)
    COMA            reduce using rule 53 (e -> f .)
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 84
    MOD             shift and go to state 85
    POTENCIA        shift and go to state 86


state 50

    (58) f -> g .
    (59) f -> g . PUNTO nativeFun L_PAREN expresion R_PAREN

    TIMES           reduce using rule 58 (f -> g .)
    DIVIDE          reduce using rule 58 (f -> g .)
    MOD             reduce using rule 58 (f -> g .)
    POTENCIA        reduce using rule 58 (f -> g .)
    MAS             reduce using rule 58 (f -> g .)
    MENOS           reduce using rule 58 (f -> g .)
    DISTINTO_QUE    reduce using rule 58 (f -> g .)
    MENOR_QUE       reduce using rule 58 (f -> g .)
    MENOR_IGUAL_QUE reduce using rule 58 (f -> g .)
    MAYOR_QUE       reduce using rule 58 (f -> g .)
    MAYOR_IGUAL_QUE reduce using rule 58 (f -> g .)
    TRIPLE_IGUAL    reduce using rule 58 (f -> g .)
    AND             reduce using rule 58 (f -> g .)
    OR              reduce using rule 58 (f -> g .)
    SEMI_COLON      reduce using rule 58 (f -> g .)
    CONSOLE         reduce using rule 58 (f -> g .)
    LET             reduce using rule 58 (f -> g .)
    LITERAL         reduce using rule 58 (f -> g .)
    IF              reduce using rule 58 (f -> g .)
    WHILE           reduce using rule 58 (f -> g .)
    FOR             reduce using rule 58 (f -> g .)
    $end            reduce using rule 58 (f -> g .)
    R_LLAVE         reduce using rule 58 (f -> g .)
    R_PAREN         reduce using rule 58 (f -> g .)
    COMA            reduce using rule 58 (f -> g .)
    PUNTO           shift and go to state 87


state 51

    (64) g -> L_PAREN . a R_PAREN
    (38) a -> . a OR b
    (39) a -> . b
    (40) b -> . b AND c
    (41) b -> . c
    (42) c -> . NOT d
    (43) c -> . d
    (44) d -> . d DISTINTO_QUE e
    (45) d -> . d MENOR_QUE e
    (46) d -> . d MENOR_IGUAL_QUE e
    (47) d -> . d MAYOR_QUE e
    (48) d -> . d MAYOR_IGUAL_QUE e
    (49) d -> . d TRIPLE_IGUAL e
    (50) d -> . e
    (51) e -> . e MAS f
    (52) e -> . e MENOS f
    (53) e -> . f
    (54) f -> . f TIMES g
    (55) f -> . f DIVIDE g
    (56) f -> . f MOD g
    (57) f -> . f POTENCIA g
    (58) f -> . g
    (59) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    NOT             shift and go to state 46
    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    a                              shift and go to state 88
    b                              shift and go to state 44
    c                              shift and go to state 45
    d                              shift and go to state 47
    e                              shift and go to state 48
    f                              shift and go to state 49
    g                              shift and go to state 50

state 52

    (60) g -> ENTERO .

    PUNTO           reduce using rule 60 (g -> ENTERO .)
    TIMES           reduce using rule 60 (g -> ENTERO .)
    DIVIDE          reduce using rule 60 (g -> ENTERO .)
    MOD             reduce using rule 60 (g -> ENTERO .)
    POTENCIA        reduce using rule 60 (g -> ENTERO .)
    MAS             reduce using rule 60 (g -> ENTERO .)
    MENOS           reduce using rule 60 (g -> ENTERO .)
    DISTINTO_QUE    reduce using rule 60 (g -> ENTERO .)
    MENOR_QUE       reduce using rule 60 (g -> ENTERO .)
    MENOR_IGUAL_QUE reduce using rule 60 (g -> ENTERO .)
    MAYOR_QUE       reduce using rule 60 (g -> ENTERO .)
    MAYOR_IGUAL_QUE reduce using rule 60 (g -> ENTERO .)
    TRIPLE_IGUAL    reduce using rule 60 (g -> ENTERO .)
    AND             reduce using rule 60 (g -> ENTERO .)
    OR              reduce using rule 60 (g -> ENTERO .)
    SEMI_COLON      reduce using rule 60 (g -> ENTERO .)
    CONSOLE         reduce using rule 60 (g -> ENTERO .)
    LET             reduce using rule 60 (g -> ENTERO .)
    LITERAL         reduce using rule 60 (g -> ENTERO .)
    IF              reduce using rule 60 (g -> ENTERO .)
    WHILE           reduce using rule 60 (g -> ENTERO .)
    FOR             reduce using rule 60 (g -> ENTERO .)
    $end            reduce using rule 60 (g -> ENTERO .)
    R_LLAVE         reduce using rule 60 (g -> ENTERO .)
    R_PAREN         reduce using rule 60 (g -> ENTERO .)
    COMA            reduce using rule 60 (g -> ENTERO .)


state 53

    (61) g -> DECIMAL .

    PUNTO           reduce using rule 61 (g -> DECIMAL .)
    TIMES           reduce using rule 61 (g -> DECIMAL .)
    DIVIDE          reduce using rule 61 (g -> DECIMAL .)
    MOD             reduce using rule 61 (g -> DECIMAL .)
    POTENCIA        reduce using rule 61 (g -> DECIMAL .)
    MAS             reduce using rule 61 (g -> DECIMAL .)
    MENOS           reduce using rule 61 (g -> DECIMAL .)
    DISTINTO_QUE    reduce using rule 61 (g -> DECIMAL .)
    MENOR_QUE       reduce using rule 61 (g -> DECIMAL .)
    MENOR_IGUAL_QUE reduce using rule 61 (g -> DECIMAL .)
    MAYOR_QUE       reduce using rule 61 (g -> DECIMAL .)
    MAYOR_IGUAL_QUE reduce using rule 61 (g -> DECIMAL .)
    TRIPLE_IGUAL    reduce using rule 61 (g -> DECIMAL .)
    AND             reduce using rule 61 (g -> DECIMAL .)
    OR              reduce using rule 61 (g -> DECIMAL .)
    SEMI_COLON      reduce using rule 61 (g -> DECIMAL .)
    CONSOLE         reduce using rule 61 (g -> DECIMAL .)
    LET             reduce using rule 61 (g -> DECIMAL .)
    LITERAL         reduce using rule 61 (g -> DECIMAL .)
    IF              reduce using rule 61 (g -> DECIMAL .)
    WHILE           reduce using rule 61 (g -> DECIMAL .)
    FOR             reduce using rule 61 (g -> DECIMAL .)
    $end            reduce using rule 61 (g -> DECIMAL .)
    R_LLAVE         reduce using rule 61 (g -> DECIMAL .)
    R_PAREN         reduce using rule 61 (g -> DECIMAL .)
    COMA            reduce using rule 61 (g -> DECIMAL .)


state 54

    (62) g -> CADENA .

    PUNTO           reduce using rule 62 (g -> CADENA .)
    TIMES           reduce using rule 62 (g -> CADENA .)
    DIVIDE          reduce using rule 62 (g -> CADENA .)
    MOD             reduce using rule 62 (g -> CADENA .)
    POTENCIA        reduce using rule 62 (g -> CADENA .)
    MAS             reduce using rule 62 (g -> CADENA .)
    MENOS           reduce using rule 62 (g -> CADENA .)
    DISTINTO_QUE    reduce using rule 62 (g -> CADENA .)
    MENOR_QUE       reduce using rule 62 (g -> CADENA .)
    MENOR_IGUAL_QUE reduce using rule 62 (g -> CADENA .)
    MAYOR_QUE       reduce using rule 62 (g -> CADENA .)
    MAYOR_IGUAL_QUE reduce using rule 62 (g -> CADENA .)
    TRIPLE_IGUAL    reduce using rule 62 (g -> CADENA .)
    AND             reduce using rule 62 (g -> CADENA .)
    OR              reduce using rule 62 (g -> CADENA .)
    SEMI_COLON      reduce using rule 62 (g -> CADENA .)
    CONSOLE         reduce using rule 62 (g -> CADENA .)
    LET             reduce using rule 62 (g -> CADENA .)
    LITERAL         reduce using rule 62 (g -> CADENA .)
    IF              reduce using rule 62 (g -> CADENA .)
    WHILE           reduce using rule 62 (g -> CADENA .)
    FOR             reduce using rule 62 (g -> CADENA .)
    $end            reduce using rule 62 (g -> CADENA .)
    R_LLAVE         reduce using rule 62 (g -> CADENA .)
    R_PAREN         reduce using rule 62 (g -> CADENA .)
    COMA            reduce using rule 62 (g -> CADENA .)


state 55

    (65) sumadores -> LITERAL MAS MAS .

    SEMI_COLON      reduce using rule 65 (sumadores -> LITERAL MAS MAS .)
    CONSOLE         reduce using rule 65 (sumadores -> LITERAL MAS MAS .)
    LET             reduce using rule 65 (sumadores -> LITERAL MAS MAS .)
    LITERAL         reduce using rule 65 (sumadores -> LITERAL MAS MAS .)
    IF              reduce using rule 65 (sumadores -> LITERAL MAS MAS .)
    WHILE           reduce using rule 65 (sumadores -> LITERAL MAS MAS .)
    FOR             reduce using rule 65 (sumadores -> LITERAL MAS MAS .)
    $end            reduce using rule 65 (sumadores -> LITERAL MAS MAS .)
    R_LLAVE         reduce using rule 65 (sumadores -> LITERAL MAS MAS .)


state 56

    (66) sumadores -> LITERAL MENOS MENOS .

    SEMI_COLON      reduce using rule 66 (sumadores -> LITERAL MENOS MENOS .)
    CONSOLE         reduce using rule 66 (sumadores -> LITERAL MENOS MENOS .)
    LET             reduce using rule 66 (sumadores -> LITERAL MENOS MENOS .)
    LITERAL         reduce using rule 66 (sumadores -> LITERAL MENOS MENOS .)
    IF              reduce using rule 66 (sumadores -> LITERAL MENOS MENOS .)
    WHILE           reduce using rule 66 (sumadores -> LITERAL MENOS MENOS .)
    FOR             reduce using rule 66 (sumadores -> LITERAL MENOS MENOS .)
    $end            reduce using rule 66 (sumadores -> LITERAL MENOS MENOS .)
    R_LLAVE         reduce using rule 66 (sumadores -> LITERAL MENOS MENOS .)


state 57

    (25) if_pro -> IF L_PAREN a . R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (38) a -> a . OR b

    R_PAREN         shift and go to state 89
    OR              shift and go to state 72


state 58

    (29) while_pro -> WHILE L_PAREN a . R_PAREN L_LLAVE instrucciones R_LLAVE
    (38) a -> a . OR b

    R_PAREN         shift and go to state 90
    OR              shift and go to state 72


state 59

    (30) for_pro -> FOR L_PAREN declaration_instruction . SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE

    SEMI_COLON      shift and go to state 91


state 60

    (31) for_pro -> FOR L_PAREN assig_pro . SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE

    SEMI_COLON      shift and go to state 92


state 61

    (32) for_each_pro -> FOR L_PAREN for_each_dec . R_PAREN L_LLAVE instrucciones R_LLAVE

    R_PAREN         shift and go to state 93


state 62

    (14) declaration_instruction -> LET . declaracion_list
    (33) for_each_dec -> LET . LITERAL OF a
    (34) for_each_dec -> LET . LITERAL COLON type OF a
    (15) declaracion_list -> . declaracion_list COMA assignacion_instruction
    (16) declaracion_list -> . assignacion_instruction
    (17) assignacion_instruction -> . LITERAL COLON type IGUAL a
    (18) assignacion_instruction -> . LITERAL COLON type
    (19) assignacion_instruction -> . LITERAL IGUAL a

    LITERAL         shift and go to state 94

    declaracion_list               shift and go to state 29
    assignacion_instruction        shift and go to state 30

state 63

    (24) assig_pro -> LITERAL . IGUAL a

    IGUAL           shift and go to state 32


state 64

    (35) console_pro -> CONSOLE PUNTO LOG L_PAREN . expresion R_PAREN
    (36) expresion -> . expresion COMA a
    (37) expresion -> . a
    (38) a -> . a OR b
    (39) a -> . b
    (40) b -> . b AND c
    (41) b -> . c
    (42) c -> . NOT d
    (43) c -> . d
    (44) d -> . d DISTINTO_QUE e
    (45) d -> . d MENOR_QUE e
    (46) d -> . d MENOR_IGUAL_QUE e
    (47) d -> . d MAYOR_QUE e
    (48) d -> . d MAYOR_IGUAL_QUE e
    (49) d -> . d TRIPLE_IGUAL e
    (50) d -> . e
    (51) e -> . e MAS f
    (52) e -> . e MENOS f
    (53) e -> . f
    (54) f -> . f TIMES g
    (55) f -> . f DIVIDE g
    (56) f -> . f MOD g
    (57) f -> . f POTENCIA g
    (58) f -> . g
    (59) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    NOT             shift and go to state 46
    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    expresion                      shift and go to state 95
    a                              shift and go to state 96
    b                              shift and go to state 44
    c                              shift and go to state 45
    d                              shift and go to state 47
    e                              shift and go to state 48
    f                              shift and go to state 49
    g                              shift and go to state 50

state 65

    (15) declaracion_list -> declaracion_list COMA assignacion_instruction .

    COMA            reduce using rule 15 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    SEMI_COLON      reduce using rule 15 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    CONSOLE         reduce using rule 15 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    LET             reduce using rule 15 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    LITERAL         reduce using rule 15 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    IF              reduce using rule 15 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    WHILE           reduce using rule 15 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    FOR             reduce using rule 15 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    $end            reduce using rule 15 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    R_LLAVE         reduce using rule 15 (declaracion_list -> declaracion_list COMA assignacion_instruction .)


state 66

    (17) assignacion_instruction -> LITERAL COLON type . IGUAL a
    (18) assignacion_instruction -> LITERAL COLON type .

    IGUAL           shift and go to state 97
    COMA            reduce using rule 18 (assignacion_instruction -> LITERAL COLON type .)
    SEMI_COLON      reduce using rule 18 (assignacion_instruction -> LITERAL COLON type .)
    CONSOLE         reduce using rule 18 (assignacion_instruction -> LITERAL COLON type .)
    LET             reduce using rule 18 (assignacion_instruction -> LITERAL COLON type .)
    LITERAL         reduce using rule 18 (assignacion_instruction -> LITERAL COLON type .)
    IF              reduce using rule 18 (assignacion_instruction -> LITERAL COLON type .)
    WHILE           reduce using rule 18 (assignacion_instruction -> LITERAL COLON type .)
    FOR             reduce using rule 18 (assignacion_instruction -> LITERAL COLON type .)
    $end            reduce using rule 18 (assignacion_instruction -> LITERAL COLON type .)
    R_LLAVE         reduce using rule 18 (assignacion_instruction -> LITERAL COLON type .)


state 67

    (20) type -> NUMBER .

    IGUAL           reduce using rule 20 (type -> NUMBER .)
    COMA            reduce using rule 20 (type -> NUMBER .)
    SEMI_COLON      reduce using rule 20 (type -> NUMBER .)
    CONSOLE         reduce using rule 20 (type -> NUMBER .)
    LET             reduce using rule 20 (type -> NUMBER .)
    LITERAL         reduce using rule 20 (type -> NUMBER .)
    IF              reduce using rule 20 (type -> NUMBER .)
    WHILE           reduce using rule 20 (type -> NUMBER .)
    FOR             reduce using rule 20 (type -> NUMBER .)
    $end            reduce using rule 20 (type -> NUMBER .)
    R_LLAVE         reduce using rule 20 (type -> NUMBER .)
    OF              reduce using rule 20 (type -> NUMBER .)


state 68

    (21) type -> STRING .

    IGUAL           reduce using rule 21 (type -> STRING .)
    COMA            reduce using rule 21 (type -> STRING .)
    SEMI_COLON      reduce using rule 21 (type -> STRING .)
    CONSOLE         reduce using rule 21 (type -> STRING .)
    LET             reduce using rule 21 (type -> STRING .)
    LITERAL         reduce using rule 21 (type -> STRING .)
    IF              reduce using rule 21 (type -> STRING .)
    WHILE           reduce using rule 21 (type -> STRING .)
    FOR             reduce using rule 21 (type -> STRING .)
    $end            reduce using rule 21 (type -> STRING .)
    R_LLAVE         reduce using rule 21 (type -> STRING .)
    OF              reduce using rule 21 (type -> STRING .)


state 69

    (22) type -> BOOLEAN .

    IGUAL           reduce using rule 22 (type -> BOOLEAN .)
    COMA            reduce using rule 22 (type -> BOOLEAN .)
    SEMI_COLON      reduce using rule 22 (type -> BOOLEAN .)
    CONSOLE         reduce using rule 22 (type -> BOOLEAN .)
    LET             reduce using rule 22 (type -> BOOLEAN .)
    LITERAL         reduce using rule 22 (type -> BOOLEAN .)
    IF              reduce using rule 22 (type -> BOOLEAN .)
    WHILE           reduce using rule 22 (type -> BOOLEAN .)
    FOR             reduce using rule 22 (type -> BOOLEAN .)
    $end            reduce using rule 22 (type -> BOOLEAN .)
    R_LLAVE         reduce using rule 22 (type -> BOOLEAN .)
    OF              reduce using rule 22 (type -> BOOLEAN .)


state 70

    (23) type -> ANY .

    IGUAL           reduce using rule 23 (type -> ANY .)
    COMA            reduce using rule 23 (type -> ANY .)
    SEMI_COLON      reduce using rule 23 (type -> ANY .)
    CONSOLE         reduce using rule 23 (type -> ANY .)
    LET             reduce using rule 23 (type -> ANY .)
    LITERAL         reduce using rule 23 (type -> ANY .)
    IF              reduce using rule 23 (type -> ANY .)
    WHILE           reduce using rule 23 (type -> ANY .)
    FOR             reduce using rule 23 (type -> ANY .)
    $end            reduce using rule 23 (type -> ANY .)
    R_LLAVE         reduce using rule 23 (type -> ANY .)
    OF              reduce using rule 23 (type -> ANY .)


state 71

    (19) assignacion_instruction -> LITERAL IGUAL a .
    (38) a -> a . OR b

    COMA            reduce using rule 19 (assignacion_instruction -> LITERAL IGUAL a .)
    SEMI_COLON      reduce using rule 19 (assignacion_instruction -> LITERAL IGUAL a .)
    CONSOLE         reduce using rule 19 (assignacion_instruction -> LITERAL IGUAL a .)
    LET             reduce using rule 19 (assignacion_instruction -> LITERAL IGUAL a .)
    LITERAL         reduce using rule 19 (assignacion_instruction -> LITERAL IGUAL a .)
    IF              reduce using rule 19 (assignacion_instruction -> LITERAL IGUAL a .)
    WHILE           reduce using rule 19 (assignacion_instruction -> LITERAL IGUAL a .)
    FOR             reduce using rule 19 (assignacion_instruction -> LITERAL IGUAL a .)
    $end            reduce using rule 19 (assignacion_instruction -> LITERAL IGUAL a .)
    R_LLAVE         reduce using rule 19 (assignacion_instruction -> LITERAL IGUAL a .)
    OR              shift and go to state 72


state 72

    (38) a -> a OR . b
    (40) b -> . b AND c
    (41) b -> . c
    (42) c -> . NOT d
    (43) c -> . d
    (44) d -> . d DISTINTO_QUE e
    (45) d -> . d MENOR_QUE e
    (46) d -> . d MENOR_IGUAL_QUE e
    (47) d -> . d MAYOR_QUE e
    (48) d -> . d MAYOR_IGUAL_QUE e
    (49) d -> . d TRIPLE_IGUAL e
    (50) d -> . e
    (51) e -> . e MAS f
    (52) e -> . e MENOS f
    (53) e -> . f
    (54) f -> . f TIMES g
    (55) f -> . f DIVIDE g
    (56) f -> . f MOD g
    (57) f -> . f POTENCIA g
    (58) f -> . g
    (59) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    NOT             shift and go to state 46
    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    b                              shift and go to state 98
    c                              shift and go to state 45
    d                              shift and go to state 47
    e                              shift and go to state 48
    f                              shift and go to state 49
    g                              shift and go to state 50

state 73

    (40) b -> b AND . c
    (42) c -> . NOT d
    (43) c -> . d
    (44) d -> . d DISTINTO_QUE e
    (45) d -> . d MENOR_QUE e
    (46) d -> . d MENOR_IGUAL_QUE e
    (47) d -> . d MAYOR_QUE e
    (48) d -> . d MAYOR_IGUAL_QUE e
    (49) d -> . d TRIPLE_IGUAL e
    (50) d -> . e
    (51) e -> . e MAS f
    (52) e -> . e MENOS f
    (53) e -> . f
    (54) f -> . f TIMES g
    (55) f -> . f DIVIDE g
    (56) f -> . f MOD g
    (57) f -> . f POTENCIA g
    (58) f -> . g
    (59) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    NOT             shift and go to state 46
    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    c                              shift and go to state 99
    d                              shift and go to state 47
    e                              shift and go to state 48
    f                              shift and go to state 49
    g                              shift and go to state 50

state 74

    (42) c -> NOT d .
    (44) d -> d . DISTINTO_QUE e
    (45) d -> d . MENOR_QUE e
    (46) d -> d . MENOR_IGUAL_QUE e
    (47) d -> d . MAYOR_QUE e
    (48) d -> d . MAYOR_IGUAL_QUE e
    (49) d -> d . TRIPLE_IGUAL e

    AND             reduce using rule 42 (c -> NOT d .)
    OR              reduce using rule 42 (c -> NOT d .)
    SEMI_COLON      reduce using rule 42 (c -> NOT d .)
    CONSOLE         reduce using rule 42 (c -> NOT d .)
    LET             reduce using rule 42 (c -> NOT d .)
    LITERAL         reduce using rule 42 (c -> NOT d .)
    IF              reduce using rule 42 (c -> NOT d .)
    WHILE           reduce using rule 42 (c -> NOT d .)
    FOR             reduce using rule 42 (c -> NOT d .)
    $end            reduce using rule 42 (c -> NOT d .)
    R_LLAVE         reduce using rule 42 (c -> NOT d .)
    R_PAREN         reduce using rule 42 (c -> NOT d .)
    COMA            reduce using rule 42 (c -> NOT d .)
    DISTINTO_QUE    shift and go to state 75
    MENOR_QUE       shift and go to state 76
    MENOR_IGUAL_QUE shift and go to state 77
    MAYOR_QUE       shift and go to state 78
    MAYOR_IGUAL_QUE shift and go to state 79
    TRIPLE_IGUAL    shift and go to state 80


state 75

    (44) d -> d DISTINTO_QUE . e
    (51) e -> . e MAS f
    (52) e -> . e MENOS f
    (53) e -> . f
    (54) f -> . f TIMES g
    (55) f -> . f DIVIDE g
    (56) f -> . f MOD g
    (57) f -> . f POTENCIA g
    (58) f -> . g
    (59) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    e                              shift and go to state 100
    f                              shift and go to state 49
    g                              shift and go to state 50

state 76

    (45) d -> d MENOR_QUE . e
    (51) e -> . e MAS f
    (52) e -> . e MENOS f
    (53) e -> . f
    (54) f -> . f TIMES g
    (55) f -> . f DIVIDE g
    (56) f -> . f MOD g
    (57) f -> . f POTENCIA g
    (58) f -> . g
    (59) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    e                              shift and go to state 101
    f                              shift and go to state 49
    g                              shift and go to state 50

state 77

    (46) d -> d MENOR_IGUAL_QUE . e
    (51) e -> . e MAS f
    (52) e -> . e MENOS f
    (53) e -> . f
    (54) f -> . f TIMES g
    (55) f -> . f DIVIDE g
    (56) f -> . f MOD g
    (57) f -> . f POTENCIA g
    (58) f -> . g
    (59) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    e                              shift and go to state 102
    f                              shift and go to state 49
    g                              shift and go to state 50

state 78

    (47) d -> d MAYOR_QUE . e
    (51) e -> . e MAS f
    (52) e -> . e MENOS f
    (53) e -> . f
    (54) f -> . f TIMES g
    (55) f -> . f DIVIDE g
    (56) f -> . f MOD g
    (57) f -> . f POTENCIA g
    (58) f -> . g
    (59) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    e                              shift and go to state 103
    f                              shift and go to state 49
    g                              shift and go to state 50

state 79

    (48) d -> d MAYOR_IGUAL_QUE . e
    (51) e -> . e MAS f
    (52) e -> . e MENOS f
    (53) e -> . f
    (54) f -> . f TIMES g
    (55) f -> . f DIVIDE g
    (56) f -> . f MOD g
    (57) f -> . f POTENCIA g
    (58) f -> . g
    (59) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    e                              shift and go to state 104
    f                              shift and go to state 49
    g                              shift and go to state 50

state 80

    (49) d -> d TRIPLE_IGUAL . e
    (51) e -> . e MAS f
    (52) e -> . e MENOS f
    (53) e -> . f
    (54) f -> . f TIMES g
    (55) f -> . f DIVIDE g
    (56) f -> . f MOD g
    (57) f -> . f POTENCIA g
    (58) f -> . g
    (59) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    e                              shift and go to state 105
    f                              shift and go to state 49
    g                              shift and go to state 50

state 81

    (51) e -> e MAS . f
    (54) f -> . f TIMES g
    (55) f -> . f DIVIDE g
    (56) f -> . f MOD g
    (57) f -> . f POTENCIA g
    (58) f -> . g
    (59) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    f                              shift and go to state 106
    g                              shift and go to state 50

state 82

    (52) e -> e MENOS . f
    (54) f -> . f TIMES g
    (55) f -> . f DIVIDE g
    (56) f -> . f MOD g
    (57) f -> . f POTENCIA g
    (58) f -> . g
    (59) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    f                              shift and go to state 107
    g                              shift and go to state 50

state 83

    (54) f -> f TIMES . g
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    g                              shift and go to state 108

state 84

    (55) f -> f DIVIDE . g
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    g                              shift and go to state 109

state 85

    (56) f -> f MOD . g
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    g                              shift and go to state 110

state 86

    (57) f -> f POTENCIA . g
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    g                              shift and go to state 111

state 87

    (59) f -> g PUNTO . nativeFun L_PAREN expresion R_PAREN
    (67) nativeFun -> . TOSTRING
    (68) nativeFun -> . TOFIXED
    (69) nativeFun -> . TOEXPONENTIAL
    (70) nativeFun -> . TOLOWERCASE
    (71) nativeFun -> . TOUPPERCASE
    (72) nativeFun -> . SPLIT
    (73) nativeFun -> . CONCAT

    TOSTRING        shift and go to state 113
    TOFIXED         shift and go to state 114
    TOEXPONENTIAL   shift and go to state 115
    TOLOWERCASE     shift and go to state 116
    TOUPPERCASE     shift and go to state 117
    SPLIT           shift and go to state 118
    CONCAT          shift and go to state 119

    nativeFun                      shift and go to state 112

state 88

    (64) g -> L_PAREN a . R_PAREN
    (38) a -> a . OR b

    R_PAREN         shift and go to state 120
    OR              shift and go to state 72


state 89

    (25) if_pro -> IF L_PAREN a R_PAREN . L_LLAVE instrucciones R_LLAVE else_pro

    L_LLAVE         shift and go to state 121


state 90

    (29) while_pro -> WHILE L_PAREN a R_PAREN . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 122


state 91

    (30) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON . a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (38) a -> . a OR b
    (39) a -> . b
    (40) b -> . b AND c
    (41) b -> . c
    (42) c -> . NOT d
    (43) c -> . d
    (44) d -> . d DISTINTO_QUE e
    (45) d -> . d MENOR_QUE e
    (46) d -> . d MENOR_IGUAL_QUE e
    (47) d -> . d MAYOR_QUE e
    (48) d -> . d MAYOR_IGUAL_QUE e
    (49) d -> . d TRIPLE_IGUAL e
    (50) d -> . e
    (51) e -> . e MAS f
    (52) e -> . e MENOS f
    (53) e -> . f
    (54) f -> . f TIMES g
    (55) f -> . f DIVIDE g
    (56) f -> . f MOD g
    (57) f -> . f POTENCIA g
    (58) f -> . g
    (59) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    NOT             shift and go to state 46
    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    a                              shift and go to state 123
    b                              shift and go to state 44
    c                              shift and go to state 45
    d                              shift and go to state 47
    e                              shift and go to state 48
    f                              shift and go to state 49
    g                              shift and go to state 50

state 92

    (31) for_pro -> FOR L_PAREN assig_pro SEMI_COLON . a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (38) a -> . a OR b
    (39) a -> . b
    (40) b -> . b AND c
    (41) b -> . c
    (42) c -> . NOT d
    (43) c -> . d
    (44) d -> . d DISTINTO_QUE e
    (45) d -> . d MENOR_QUE e
    (46) d -> . d MENOR_IGUAL_QUE e
    (47) d -> . d MAYOR_QUE e
    (48) d -> . d MAYOR_IGUAL_QUE e
    (49) d -> . d TRIPLE_IGUAL e
    (50) d -> . e
    (51) e -> . e MAS f
    (52) e -> . e MENOS f
    (53) e -> . f
    (54) f -> . f TIMES g
    (55) f -> . f DIVIDE g
    (56) f -> . f MOD g
    (57) f -> . f POTENCIA g
    (58) f -> . g
    (59) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    NOT             shift and go to state 46
    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    a                              shift and go to state 124
    b                              shift and go to state 44
    c                              shift and go to state 45
    d                              shift and go to state 47
    e                              shift and go to state 48
    f                              shift and go to state 49
    g                              shift and go to state 50

state 93

    (32) for_each_pro -> FOR L_PAREN for_each_dec R_PAREN . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 125


state 94

    (33) for_each_dec -> LET LITERAL . OF a
    (34) for_each_dec -> LET LITERAL . COLON type OF a
    (17) assignacion_instruction -> LITERAL . COLON type IGUAL a
    (18) assignacion_instruction -> LITERAL . COLON type
    (19) assignacion_instruction -> LITERAL . IGUAL a

    OF              shift and go to state 126
    COLON           shift and go to state 127
    IGUAL           shift and go to state 41


state 95

    (35) console_pro -> CONSOLE PUNTO LOG L_PAREN expresion . R_PAREN
    (36) expresion -> expresion . COMA a

    R_PAREN         shift and go to state 128
    COMA            shift and go to state 129


state 96

    (37) expresion -> a .
    (38) a -> a . OR b

    R_PAREN         reduce using rule 37 (expresion -> a .)
    COMA            reduce using rule 37 (expresion -> a .)
    OR              shift and go to state 72


state 97

    (17) assignacion_instruction -> LITERAL COLON type IGUAL . a
    (38) a -> . a OR b
    (39) a -> . b
    (40) b -> . b AND c
    (41) b -> . c
    (42) c -> . NOT d
    (43) c -> . d
    (44) d -> . d DISTINTO_QUE e
    (45) d -> . d MENOR_QUE e
    (46) d -> . d MENOR_IGUAL_QUE e
    (47) d -> . d MAYOR_QUE e
    (48) d -> . d MAYOR_IGUAL_QUE e
    (49) d -> . d TRIPLE_IGUAL e
    (50) d -> . e
    (51) e -> . e MAS f
    (52) e -> . e MENOS f
    (53) e -> . f
    (54) f -> . f TIMES g
    (55) f -> . f DIVIDE g
    (56) f -> . f MOD g
    (57) f -> . f POTENCIA g
    (58) f -> . g
    (59) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    NOT             shift and go to state 46
    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    a                              shift and go to state 130
    b                              shift and go to state 44
    c                              shift and go to state 45
    d                              shift and go to state 47
    e                              shift and go to state 48
    f                              shift and go to state 49
    g                              shift and go to state 50

state 98

    (38) a -> a OR b .
    (40) b -> b . AND c

    OR              reduce using rule 38 (a -> a OR b .)
    SEMI_COLON      reduce using rule 38 (a -> a OR b .)
    CONSOLE         reduce using rule 38 (a -> a OR b .)
    LET             reduce using rule 38 (a -> a OR b .)
    LITERAL         reduce using rule 38 (a -> a OR b .)
    IF              reduce using rule 38 (a -> a OR b .)
    WHILE           reduce using rule 38 (a -> a OR b .)
    FOR             reduce using rule 38 (a -> a OR b .)
    $end            reduce using rule 38 (a -> a OR b .)
    R_LLAVE         reduce using rule 38 (a -> a OR b .)
    R_PAREN         reduce using rule 38 (a -> a OR b .)
    COMA            reduce using rule 38 (a -> a OR b .)
    AND             shift and go to state 73


state 99

    (40) b -> b AND c .

    AND             reduce using rule 40 (b -> b AND c .)
    OR              reduce using rule 40 (b -> b AND c .)
    SEMI_COLON      reduce using rule 40 (b -> b AND c .)
    CONSOLE         reduce using rule 40 (b -> b AND c .)
    LET             reduce using rule 40 (b -> b AND c .)
    LITERAL         reduce using rule 40 (b -> b AND c .)
    IF              reduce using rule 40 (b -> b AND c .)
    WHILE           reduce using rule 40 (b -> b AND c .)
    FOR             reduce using rule 40 (b -> b AND c .)
    $end            reduce using rule 40 (b -> b AND c .)
    R_LLAVE         reduce using rule 40 (b -> b AND c .)
    R_PAREN         reduce using rule 40 (b -> b AND c .)
    COMA            reduce using rule 40 (b -> b AND c .)


state 100

    (44) d -> d DISTINTO_QUE e .
    (51) e -> e . MAS f
    (52) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 44 (d -> d DISTINTO_QUE e .)
    MENOR_QUE       reduce using rule 44 (d -> d DISTINTO_QUE e .)
    MENOR_IGUAL_QUE reduce using rule 44 (d -> d DISTINTO_QUE e .)
    MAYOR_QUE       reduce using rule 44 (d -> d DISTINTO_QUE e .)
    MAYOR_IGUAL_QUE reduce using rule 44 (d -> d DISTINTO_QUE e .)
    TRIPLE_IGUAL    reduce using rule 44 (d -> d DISTINTO_QUE e .)
    AND             reduce using rule 44 (d -> d DISTINTO_QUE e .)
    OR              reduce using rule 44 (d -> d DISTINTO_QUE e .)
    SEMI_COLON      reduce using rule 44 (d -> d DISTINTO_QUE e .)
    CONSOLE         reduce using rule 44 (d -> d DISTINTO_QUE e .)
    LET             reduce using rule 44 (d -> d DISTINTO_QUE e .)
    LITERAL         reduce using rule 44 (d -> d DISTINTO_QUE e .)
    IF              reduce using rule 44 (d -> d DISTINTO_QUE e .)
    WHILE           reduce using rule 44 (d -> d DISTINTO_QUE e .)
    FOR             reduce using rule 44 (d -> d DISTINTO_QUE e .)
    $end            reduce using rule 44 (d -> d DISTINTO_QUE e .)
    R_LLAVE         reduce using rule 44 (d -> d DISTINTO_QUE e .)
    R_PAREN         reduce using rule 44 (d -> d DISTINTO_QUE e .)
    COMA            reduce using rule 44 (d -> d DISTINTO_QUE e .)
    MAS             shift and go to state 81
    MENOS           shift and go to state 82


state 101

    (45) d -> d MENOR_QUE e .
    (51) e -> e . MAS f
    (52) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 45 (d -> d MENOR_QUE e .)
    MENOR_QUE       reduce using rule 45 (d -> d MENOR_QUE e .)
    MENOR_IGUAL_QUE reduce using rule 45 (d -> d MENOR_QUE e .)
    MAYOR_QUE       reduce using rule 45 (d -> d MENOR_QUE e .)
    MAYOR_IGUAL_QUE reduce using rule 45 (d -> d MENOR_QUE e .)
    TRIPLE_IGUAL    reduce using rule 45 (d -> d MENOR_QUE e .)
    AND             reduce using rule 45 (d -> d MENOR_QUE e .)
    OR              reduce using rule 45 (d -> d MENOR_QUE e .)
    SEMI_COLON      reduce using rule 45 (d -> d MENOR_QUE e .)
    CONSOLE         reduce using rule 45 (d -> d MENOR_QUE e .)
    LET             reduce using rule 45 (d -> d MENOR_QUE e .)
    LITERAL         reduce using rule 45 (d -> d MENOR_QUE e .)
    IF              reduce using rule 45 (d -> d MENOR_QUE e .)
    WHILE           reduce using rule 45 (d -> d MENOR_QUE e .)
    FOR             reduce using rule 45 (d -> d MENOR_QUE e .)
    $end            reduce using rule 45 (d -> d MENOR_QUE e .)
    R_LLAVE         reduce using rule 45 (d -> d MENOR_QUE e .)
    R_PAREN         reduce using rule 45 (d -> d MENOR_QUE e .)
    COMA            reduce using rule 45 (d -> d MENOR_QUE e .)
    MAS             shift and go to state 81
    MENOS           shift and go to state 82


state 102

    (46) d -> d MENOR_IGUAL_QUE e .
    (51) e -> e . MAS f
    (52) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 46 (d -> d MENOR_IGUAL_QUE e .)
    MENOR_QUE       reduce using rule 46 (d -> d MENOR_IGUAL_QUE e .)
    MENOR_IGUAL_QUE reduce using rule 46 (d -> d MENOR_IGUAL_QUE e .)
    MAYOR_QUE       reduce using rule 46 (d -> d MENOR_IGUAL_QUE e .)
    MAYOR_IGUAL_QUE reduce using rule 46 (d -> d MENOR_IGUAL_QUE e .)
    TRIPLE_IGUAL    reduce using rule 46 (d -> d MENOR_IGUAL_QUE e .)
    AND             reduce using rule 46 (d -> d MENOR_IGUAL_QUE e .)
    OR              reduce using rule 46 (d -> d MENOR_IGUAL_QUE e .)
    SEMI_COLON      reduce using rule 46 (d -> d MENOR_IGUAL_QUE e .)
    CONSOLE         reduce using rule 46 (d -> d MENOR_IGUAL_QUE e .)
    LET             reduce using rule 46 (d -> d MENOR_IGUAL_QUE e .)
    LITERAL         reduce using rule 46 (d -> d MENOR_IGUAL_QUE e .)
    IF              reduce using rule 46 (d -> d MENOR_IGUAL_QUE e .)
    WHILE           reduce using rule 46 (d -> d MENOR_IGUAL_QUE e .)
    FOR             reduce using rule 46 (d -> d MENOR_IGUAL_QUE e .)
    $end            reduce using rule 46 (d -> d MENOR_IGUAL_QUE e .)
    R_LLAVE         reduce using rule 46 (d -> d MENOR_IGUAL_QUE e .)
    R_PAREN         reduce using rule 46 (d -> d MENOR_IGUAL_QUE e .)
    COMA            reduce using rule 46 (d -> d MENOR_IGUAL_QUE e .)
    MAS             shift and go to state 81
    MENOS           shift and go to state 82


state 103

    (47) d -> d MAYOR_QUE e .
    (51) e -> e . MAS f
    (52) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 47 (d -> d MAYOR_QUE e .)
    MENOR_QUE       reduce using rule 47 (d -> d MAYOR_QUE e .)
    MENOR_IGUAL_QUE reduce using rule 47 (d -> d MAYOR_QUE e .)
    MAYOR_QUE       reduce using rule 47 (d -> d MAYOR_QUE e .)
    MAYOR_IGUAL_QUE reduce using rule 47 (d -> d MAYOR_QUE e .)
    TRIPLE_IGUAL    reduce using rule 47 (d -> d MAYOR_QUE e .)
    AND             reduce using rule 47 (d -> d MAYOR_QUE e .)
    OR              reduce using rule 47 (d -> d MAYOR_QUE e .)
    SEMI_COLON      reduce using rule 47 (d -> d MAYOR_QUE e .)
    CONSOLE         reduce using rule 47 (d -> d MAYOR_QUE e .)
    LET             reduce using rule 47 (d -> d MAYOR_QUE e .)
    LITERAL         reduce using rule 47 (d -> d MAYOR_QUE e .)
    IF              reduce using rule 47 (d -> d MAYOR_QUE e .)
    WHILE           reduce using rule 47 (d -> d MAYOR_QUE e .)
    FOR             reduce using rule 47 (d -> d MAYOR_QUE e .)
    $end            reduce using rule 47 (d -> d MAYOR_QUE e .)
    R_LLAVE         reduce using rule 47 (d -> d MAYOR_QUE e .)
    R_PAREN         reduce using rule 47 (d -> d MAYOR_QUE e .)
    COMA            reduce using rule 47 (d -> d MAYOR_QUE e .)
    MAS             shift and go to state 81
    MENOS           shift and go to state 82


state 104

    (48) d -> d MAYOR_IGUAL_QUE e .
    (51) e -> e . MAS f
    (52) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 48 (d -> d MAYOR_IGUAL_QUE e .)
    MENOR_QUE       reduce using rule 48 (d -> d MAYOR_IGUAL_QUE e .)
    MENOR_IGUAL_QUE reduce using rule 48 (d -> d MAYOR_IGUAL_QUE e .)
    MAYOR_QUE       reduce using rule 48 (d -> d MAYOR_IGUAL_QUE e .)
    MAYOR_IGUAL_QUE reduce using rule 48 (d -> d MAYOR_IGUAL_QUE e .)
    TRIPLE_IGUAL    reduce using rule 48 (d -> d MAYOR_IGUAL_QUE e .)
    AND             reduce using rule 48 (d -> d MAYOR_IGUAL_QUE e .)
    OR              reduce using rule 48 (d -> d MAYOR_IGUAL_QUE e .)
    SEMI_COLON      reduce using rule 48 (d -> d MAYOR_IGUAL_QUE e .)
    CONSOLE         reduce using rule 48 (d -> d MAYOR_IGUAL_QUE e .)
    LET             reduce using rule 48 (d -> d MAYOR_IGUAL_QUE e .)
    LITERAL         reduce using rule 48 (d -> d MAYOR_IGUAL_QUE e .)
    IF              reduce using rule 48 (d -> d MAYOR_IGUAL_QUE e .)
    WHILE           reduce using rule 48 (d -> d MAYOR_IGUAL_QUE e .)
    FOR             reduce using rule 48 (d -> d MAYOR_IGUAL_QUE e .)
    $end            reduce using rule 48 (d -> d MAYOR_IGUAL_QUE e .)
    R_LLAVE         reduce using rule 48 (d -> d MAYOR_IGUAL_QUE e .)
    R_PAREN         reduce using rule 48 (d -> d MAYOR_IGUAL_QUE e .)
    COMA            reduce using rule 48 (d -> d MAYOR_IGUAL_QUE e .)
    MAS             shift and go to state 81
    MENOS           shift and go to state 82


state 105

    (49) d -> d TRIPLE_IGUAL e .
    (51) e -> e . MAS f
    (52) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 49 (d -> d TRIPLE_IGUAL e .)
    MENOR_QUE       reduce using rule 49 (d -> d TRIPLE_IGUAL e .)
    MENOR_IGUAL_QUE reduce using rule 49 (d -> d TRIPLE_IGUAL e .)
    MAYOR_QUE       reduce using rule 49 (d -> d TRIPLE_IGUAL e .)
    MAYOR_IGUAL_QUE reduce using rule 49 (d -> d TRIPLE_IGUAL e .)
    TRIPLE_IGUAL    reduce using rule 49 (d -> d TRIPLE_IGUAL e .)
    AND             reduce using rule 49 (d -> d TRIPLE_IGUAL e .)
    OR              reduce using rule 49 (d -> d TRIPLE_IGUAL e .)
    SEMI_COLON      reduce using rule 49 (d -> d TRIPLE_IGUAL e .)
    CONSOLE         reduce using rule 49 (d -> d TRIPLE_IGUAL e .)
    LET             reduce using rule 49 (d -> d TRIPLE_IGUAL e .)
    LITERAL         reduce using rule 49 (d -> d TRIPLE_IGUAL e .)
    IF              reduce using rule 49 (d -> d TRIPLE_IGUAL e .)
    WHILE           reduce using rule 49 (d -> d TRIPLE_IGUAL e .)
    FOR             reduce using rule 49 (d -> d TRIPLE_IGUAL e .)
    $end            reduce using rule 49 (d -> d TRIPLE_IGUAL e .)
    R_LLAVE         reduce using rule 49 (d -> d TRIPLE_IGUAL e .)
    R_PAREN         reduce using rule 49 (d -> d TRIPLE_IGUAL e .)
    COMA            reduce using rule 49 (d -> d TRIPLE_IGUAL e .)
    MAS             shift and go to state 81
    MENOS           shift and go to state 82


state 106

    (51) e -> e MAS f .
    (54) f -> f . TIMES g
    (55) f -> f . DIVIDE g
    (56) f -> f . MOD g
    (57) f -> f . POTENCIA g

    MAS             reduce using rule 51 (e -> e MAS f .)
    MENOS           reduce using rule 51 (e -> e MAS f .)
    DISTINTO_QUE    reduce using rule 51 (e -> e MAS f .)
    MENOR_QUE       reduce using rule 51 (e -> e MAS f .)
    MENOR_IGUAL_QUE reduce using rule 51 (e -> e MAS f .)
    MAYOR_QUE       reduce using rule 51 (e -> e MAS f .)
    MAYOR_IGUAL_QUE reduce using rule 51 (e -> e MAS f .)
    TRIPLE_IGUAL    reduce using rule 51 (e -> e MAS f .)
    AND             reduce using rule 51 (e -> e MAS f .)
    OR              reduce using rule 51 (e -> e MAS f .)
    SEMI_COLON      reduce using rule 51 (e -> e MAS f .)
    CONSOLE         reduce using rule 51 (e -> e MAS f .)
    LET             reduce using rule 51 (e -> e MAS f .)
    LITERAL         reduce using rule 51 (e -> e MAS f .)
    IF              reduce using rule 51 (e -> e MAS f .)
    WHILE           reduce using rule 51 (e -> e MAS f .)
    FOR             reduce using rule 51 (e -> e MAS f .)
    $end            reduce using rule 51 (e -> e MAS f .)
    R_LLAVE         reduce using rule 51 (e -> e MAS f .)
    R_PAREN         reduce using rule 51 (e -> e MAS f .)
    COMA            reduce using rule 51 (e -> e MAS f .)
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 84
    MOD             shift and go to state 85
    POTENCIA        shift and go to state 86


state 107

    (52) e -> e MENOS f .
    (54) f -> f . TIMES g
    (55) f -> f . DIVIDE g
    (56) f -> f . MOD g
    (57) f -> f . POTENCIA g

    MAS             reduce using rule 52 (e -> e MENOS f .)
    MENOS           reduce using rule 52 (e -> e MENOS f .)
    DISTINTO_QUE    reduce using rule 52 (e -> e MENOS f .)
    MENOR_QUE       reduce using rule 52 (e -> e MENOS f .)
    MENOR_IGUAL_QUE reduce using rule 52 (e -> e MENOS f .)
    MAYOR_QUE       reduce using rule 52 (e -> e MENOS f .)
    MAYOR_IGUAL_QUE reduce using rule 52 (e -> e MENOS f .)
    TRIPLE_IGUAL    reduce using rule 52 (e -> e MENOS f .)
    AND             reduce using rule 52 (e -> e MENOS f .)
    OR              reduce using rule 52 (e -> e MENOS f .)
    SEMI_COLON      reduce using rule 52 (e -> e MENOS f .)
    CONSOLE         reduce using rule 52 (e -> e MENOS f .)
    LET             reduce using rule 52 (e -> e MENOS f .)
    LITERAL         reduce using rule 52 (e -> e MENOS f .)
    IF              reduce using rule 52 (e -> e MENOS f .)
    WHILE           reduce using rule 52 (e -> e MENOS f .)
    FOR             reduce using rule 52 (e -> e MENOS f .)
    $end            reduce using rule 52 (e -> e MENOS f .)
    R_LLAVE         reduce using rule 52 (e -> e MENOS f .)
    R_PAREN         reduce using rule 52 (e -> e MENOS f .)
    COMA            reduce using rule 52 (e -> e MENOS f .)
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 84
    MOD             shift and go to state 85
    POTENCIA        shift and go to state 86


state 108

    (54) f -> f TIMES g .

    TIMES           reduce using rule 54 (f -> f TIMES g .)
    DIVIDE          reduce using rule 54 (f -> f TIMES g .)
    MOD             reduce using rule 54 (f -> f TIMES g .)
    POTENCIA        reduce using rule 54 (f -> f TIMES g .)
    MAS             reduce using rule 54 (f -> f TIMES g .)
    MENOS           reduce using rule 54 (f -> f TIMES g .)
    DISTINTO_QUE    reduce using rule 54 (f -> f TIMES g .)
    MENOR_QUE       reduce using rule 54 (f -> f TIMES g .)
    MENOR_IGUAL_QUE reduce using rule 54 (f -> f TIMES g .)
    MAYOR_QUE       reduce using rule 54 (f -> f TIMES g .)
    MAYOR_IGUAL_QUE reduce using rule 54 (f -> f TIMES g .)
    TRIPLE_IGUAL    reduce using rule 54 (f -> f TIMES g .)
    AND             reduce using rule 54 (f -> f TIMES g .)
    OR              reduce using rule 54 (f -> f TIMES g .)
    SEMI_COLON      reduce using rule 54 (f -> f TIMES g .)
    CONSOLE         reduce using rule 54 (f -> f TIMES g .)
    LET             reduce using rule 54 (f -> f TIMES g .)
    LITERAL         reduce using rule 54 (f -> f TIMES g .)
    IF              reduce using rule 54 (f -> f TIMES g .)
    WHILE           reduce using rule 54 (f -> f TIMES g .)
    FOR             reduce using rule 54 (f -> f TIMES g .)
    $end            reduce using rule 54 (f -> f TIMES g .)
    R_LLAVE         reduce using rule 54 (f -> f TIMES g .)
    R_PAREN         reduce using rule 54 (f -> f TIMES g .)
    COMA            reduce using rule 54 (f -> f TIMES g .)


state 109

    (55) f -> f DIVIDE g .

    TIMES           reduce using rule 55 (f -> f DIVIDE g .)
    DIVIDE          reduce using rule 55 (f -> f DIVIDE g .)
    MOD             reduce using rule 55 (f -> f DIVIDE g .)
    POTENCIA        reduce using rule 55 (f -> f DIVIDE g .)
    MAS             reduce using rule 55 (f -> f DIVIDE g .)
    MENOS           reduce using rule 55 (f -> f DIVIDE g .)
    DISTINTO_QUE    reduce using rule 55 (f -> f DIVIDE g .)
    MENOR_QUE       reduce using rule 55 (f -> f DIVIDE g .)
    MENOR_IGUAL_QUE reduce using rule 55 (f -> f DIVIDE g .)
    MAYOR_QUE       reduce using rule 55 (f -> f DIVIDE g .)
    MAYOR_IGUAL_QUE reduce using rule 55 (f -> f DIVIDE g .)
    TRIPLE_IGUAL    reduce using rule 55 (f -> f DIVIDE g .)
    AND             reduce using rule 55 (f -> f DIVIDE g .)
    OR              reduce using rule 55 (f -> f DIVIDE g .)
    SEMI_COLON      reduce using rule 55 (f -> f DIVIDE g .)
    CONSOLE         reduce using rule 55 (f -> f DIVIDE g .)
    LET             reduce using rule 55 (f -> f DIVIDE g .)
    LITERAL         reduce using rule 55 (f -> f DIVIDE g .)
    IF              reduce using rule 55 (f -> f DIVIDE g .)
    WHILE           reduce using rule 55 (f -> f DIVIDE g .)
    FOR             reduce using rule 55 (f -> f DIVIDE g .)
    $end            reduce using rule 55 (f -> f DIVIDE g .)
    R_LLAVE         reduce using rule 55 (f -> f DIVIDE g .)
    R_PAREN         reduce using rule 55 (f -> f DIVIDE g .)
    COMA            reduce using rule 55 (f -> f DIVIDE g .)


state 110

    (56) f -> f MOD g .

    TIMES           reduce using rule 56 (f -> f MOD g .)
    DIVIDE          reduce using rule 56 (f -> f MOD g .)
    MOD             reduce using rule 56 (f -> f MOD g .)
    POTENCIA        reduce using rule 56 (f -> f MOD g .)
    MAS             reduce using rule 56 (f -> f MOD g .)
    MENOS           reduce using rule 56 (f -> f MOD g .)
    DISTINTO_QUE    reduce using rule 56 (f -> f MOD g .)
    MENOR_QUE       reduce using rule 56 (f -> f MOD g .)
    MENOR_IGUAL_QUE reduce using rule 56 (f -> f MOD g .)
    MAYOR_QUE       reduce using rule 56 (f -> f MOD g .)
    MAYOR_IGUAL_QUE reduce using rule 56 (f -> f MOD g .)
    TRIPLE_IGUAL    reduce using rule 56 (f -> f MOD g .)
    AND             reduce using rule 56 (f -> f MOD g .)
    OR              reduce using rule 56 (f -> f MOD g .)
    SEMI_COLON      reduce using rule 56 (f -> f MOD g .)
    CONSOLE         reduce using rule 56 (f -> f MOD g .)
    LET             reduce using rule 56 (f -> f MOD g .)
    LITERAL         reduce using rule 56 (f -> f MOD g .)
    IF              reduce using rule 56 (f -> f MOD g .)
    WHILE           reduce using rule 56 (f -> f MOD g .)
    FOR             reduce using rule 56 (f -> f MOD g .)
    $end            reduce using rule 56 (f -> f MOD g .)
    R_LLAVE         reduce using rule 56 (f -> f MOD g .)
    R_PAREN         reduce using rule 56 (f -> f MOD g .)
    COMA            reduce using rule 56 (f -> f MOD g .)


state 111

    (57) f -> f POTENCIA g .

    TIMES           reduce using rule 57 (f -> f POTENCIA g .)
    DIVIDE          reduce using rule 57 (f -> f POTENCIA g .)
    MOD             reduce using rule 57 (f -> f POTENCIA g .)
    POTENCIA        reduce using rule 57 (f -> f POTENCIA g .)
    MAS             reduce using rule 57 (f -> f POTENCIA g .)
    MENOS           reduce using rule 57 (f -> f POTENCIA g .)
    DISTINTO_QUE    reduce using rule 57 (f -> f POTENCIA g .)
    MENOR_QUE       reduce using rule 57 (f -> f POTENCIA g .)
    MENOR_IGUAL_QUE reduce using rule 57 (f -> f POTENCIA g .)
    MAYOR_QUE       reduce using rule 57 (f -> f POTENCIA g .)
    MAYOR_IGUAL_QUE reduce using rule 57 (f -> f POTENCIA g .)
    TRIPLE_IGUAL    reduce using rule 57 (f -> f POTENCIA g .)
    AND             reduce using rule 57 (f -> f POTENCIA g .)
    OR              reduce using rule 57 (f -> f POTENCIA g .)
    SEMI_COLON      reduce using rule 57 (f -> f POTENCIA g .)
    CONSOLE         reduce using rule 57 (f -> f POTENCIA g .)
    LET             reduce using rule 57 (f -> f POTENCIA g .)
    LITERAL         reduce using rule 57 (f -> f POTENCIA g .)
    IF              reduce using rule 57 (f -> f POTENCIA g .)
    WHILE           reduce using rule 57 (f -> f POTENCIA g .)
    FOR             reduce using rule 57 (f -> f POTENCIA g .)
    $end            reduce using rule 57 (f -> f POTENCIA g .)
    R_LLAVE         reduce using rule 57 (f -> f POTENCIA g .)
    R_PAREN         reduce using rule 57 (f -> f POTENCIA g .)
    COMA            reduce using rule 57 (f -> f POTENCIA g .)


state 112

    (59) f -> g PUNTO nativeFun . L_PAREN expresion R_PAREN

    L_PAREN         shift and go to state 131


state 113

    (67) nativeFun -> TOSTRING .

    L_PAREN         reduce using rule 67 (nativeFun -> TOSTRING .)


state 114

    (68) nativeFun -> TOFIXED .

    L_PAREN         reduce using rule 68 (nativeFun -> TOFIXED .)


state 115

    (69) nativeFun -> TOEXPONENTIAL .

    L_PAREN         reduce using rule 69 (nativeFun -> TOEXPONENTIAL .)


state 116

    (70) nativeFun -> TOLOWERCASE .

    L_PAREN         reduce using rule 70 (nativeFun -> TOLOWERCASE .)


state 117

    (71) nativeFun -> TOUPPERCASE .

    L_PAREN         reduce using rule 71 (nativeFun -> TOUPPERCASE .)


state 118

    (72) nativeFun -> SPLIT .

    L_PAREN         reduce using rule 72 (nativeFun -> SPLIT .)


state 119

    (73) nativeFun -> CONCAT .

    L_PAREN         reduce using rule 73 (nativeFun -> CONCAT .)


state 120

    (64) g -> L_PAREN a R_PAREN .

    PUNTO           reduce using rule 64 (g -> L_PAREN a R_PAREN .)
    TIMES           reduce using rule 64 (g -> L_PAREN a R_PAREN .)
    DIVIDE          reduce using rule 64 (g -> L_PAREN a R_PAREN .)
    MOD             reduce using rule 64 (g -> L_PAREN a R_PAREN .)
    POTENCIA        reduce using rule 64 (g -> L_PAREN a R_PAREN .)
    MAS             reduce using rule 64 (g -> L_PAREN a R_PAREN .)
    MENOS           reduce using rule 64 (g -> L_PAREN a R_PAREN .)
    DISTINTO_QUE    reduce using rule 64 (g -> L_PAREN a R_PAREN .)
    MENOR_QUE       reduce using rule 64 (g -> L_PAREN a R_PAREN .)
    MENOR_IGUAL_QUE reduce using rule 64 (g -> L_PAREN a R_PAREN .)
    MAYOR_QUE       reduce using rule 64 (g -> L_PAREN a R_PAREN .)
    MAYOR_IGUAL_QUE reduce using rule 64 (g -> L_PAREN a R_PAREN .)
    TRIPLE_IGUAL    reduce using rule 64 (g -> L_PAREN a R_PAREN .)
    AND             reduce using rule 64 (g -> L_PAREN a R_PAREN .)
    OR              reduce using rule 64 (g -> L_PAREN a R_PAREN .)
    SEMI_COLON      reduce using rule 64 (g -> L_PAREN a R_PAREN .)
    CONSOLE         reduce using rule 64 (g -> L_PAREN a R_PAREN .)
    LET             reduce using rule 64 (g -> L_PAREN a R_PAREN .)
    LITERAL         reduce using rule 64 (g -> L_PAREN a R_PAREN .)
    IF              reduce using rule 64 (g -> L_PAREN a R_PAREN .)
    WHILE           reduce using rule 64 (g -> L_PAREN a R_PAREN .)
    FOR             reduce using rule 64 (g -> L_PAREN a R_PAREN .)
    $end            reduce using rule 64 (g -> L_PAREN a R_PAREN .)
    R_LLAVE         reduce using rule 64 (g -> L_PAREN a R_PAREN .)
    R_PAREN         reduce using rule 64 (g -> L_PAREN a R_PAREN .)
    COMA            reduce using rule 64 (g -> L_PAREN a R_PAREN .)


state 121

    (25) if_pro -> IF L_PAREN a R_PAREN L_LLAVE . instrucciones R_LLAVE else_pro
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . sumadores sc
    (35) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (14) declaration_instruction -> . LET declaracion_list
    (24) assig_pro -> . LITERAL IGUAL a
    (25) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (29) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (30) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (31) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (32) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (65) sumadores -> . LITERAL MAS MAS
    (66) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 12
    LET             shift and go to state 13
    LITERAL         shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17

    instrucciones                  shift and go to state 132
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    sumadores                      shift and go to state 11

state 122

    (29) while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . sumadores sc
    (35) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (14) declaration_instruction -> . LET declaracion_list
    (24) assig_pro -> . LITERAL IGUAL a
    (25) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (29) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (30) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (31) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (32) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (65) sumadores -> . LITERAL MAS MAS
    (66) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 12
    LET             shift and go to state 13
    LITERAL         shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17

    instrucciones                  shift and go to state 133
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    sumadores                      shift and go to state 11

state 123

    (30) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a . SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (38) a -> a . OR b

    SEMI_COLON      shift and go to state 134
    OR              shift and go to state 72


state 124

    (31) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a . SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (38) a -> a . OR b

    SEMI_COLON      shift and go to state 135
    OR              shift and go to state 72


state 125

    (32) for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . sumadores sc
    (35) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (14) declaration_instruction -> . LET declaracion_list
    (24) assig_pro -> . LITERAL IGUAL a
    (25) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (29) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (30) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (31) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (32) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (65) sumadores -> . LITERAL MAS MAS
    (66) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 12
    LET             shift and go to state 13
    LITERAL         shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17

    instrucciones                  shift and go to state 136
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    sumadores                      shift and go to state 11

state 126

    (33) for_each_dec -> LET LITERAL OF . a
    (38) a -> . a OR b
    (39) a -> . b
    (40) b -> . b AND c
    (41) b -> . c
    (42) c -> . NOT d
    (43) c -> . d
    (44) d -> . d DISTINTO_QUE e
    (45) d -> . d MENOR_QUE e
    (46) d -> . d MENOR_IGUAL_QUE e
    (47) d -> . d MAYOR_QUE e
    (48) d -> . d MAYOR_IGUAL_QUE e
    (49) d -> . d TRIPLE_IGUAL e
    (50) d -> . e
    (51) e -> . e MAS f
    (52) e -> . e MENOS f
    (53) e -> . f
    (54) f -> . f TIMES g
    (55) f -> . f DIVIDE g
    (56) f -> . f MOD g
    (57) f -> . f POTENCIA g
    (58) f -> . g
    (59) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    NOT             shift and go to state 46
    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    a                              shift and go to state 137
    b                              shift and go to state 44
    c                              shift and go to state 45
    d                              shift and go to state 47
    e                              shift and go to state 48
    f                              shift and go to state 49
    g                              shift and go to state 50

state 127

    (34) for_each_dec -> LET LITERAL COLON . type OF a
    (17) assignacion_instruction -> LITERAL COLON . type IGUAL a
    (18) assignacion_instruction -> LITERAL COLON . type
    (20) type -> . NUMBER
    (21) type -> . STRING
    (22) type -> . BOOLEAN
    (23) type -> . ANY

    NUMBER          shift and go to state 67
    STRING          shift and go to state 68
    BOOLEAN         shift and go to state 69
    ANY             shift and go to state 70

    type                           shift and go to state 138

state 128

    (35) console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .

    SEMI_COLON      reduce using rule 35 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    CONSOLE         reduce using rule 35 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    LET             reduce using rule 35 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    LITERAL         reduce using rule 35 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    IF              reduce using rule 35 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    WHILE           reduce using rule 35 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    FOR             reduce using rule 35 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    $end            reduce using rule 35 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    R_LLAVE         reduce using rule 35 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)


state 129

    (36) expresion -> expresion COMA . a
    (38) a -> . a OR b
    (39) a -> . b
    (40) b -> . b AND c
    (41) b -> . c
    (42) c -> . NOT d
    (43) c -> . d
    (44) d -> . d DISTINTO_QUE e
    (45) d -> . d MENOR_QUE e
    (46) d -> . d MENOR_IGUAL_QUE e
    (47) d -> . d MAYOR_QUE e
    (48) d -> . d MAYOR_IGUAL_QUE e
    (49) d -> . d TRIPLE_IGUAL e
    (50) d -> . e
    (51) e -> . e MAS f
    (52) e -> . e MENOS f
    (53) e -> . f
    (54) f -> . f TIMES g
    (55) f -> . f DIVIDE g
    (56) f -> . f MOD g
    (57) f -> . f POTENCIA g
    (58) f -> . g
    (59) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    NOT             shift and go to state 46
    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    a                              shift and go to state 139
    b                              shift and go to state 44
    c                              shift and go to state 45
    d                              shift and go to state 47
    e                              shift and go to state 48
    f                              shift and go to state 49
    g                              shift and go to state 50

state 130

    (17) assignacion_instruction -> LITERAL COLON type IGUAL a .
    (38) a -> a . OR b

    COMA            reduce using rule 17 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    SEMI_COLON      reduce using rule 17 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    CONSOLE         reduce using rule 17 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    LET             reduce using rule 17 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    LITERAL         reduce using rule 17 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    IF              reduce using rule 17 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    WHILE           reduce using rule 17 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    FOR             reduce using rule 17 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    $end            reduce using rule 17 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    R_LLAVE         reduce using rule 17 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    OR              shift and go to state 72


state 131

    (59) f -> g PUNTO nativeFun L_PAREN . expresion R_PAREN
    (36) expresion -> . expresion COMA a
    (37) expresion -> . a
    (38) a -> . a OR b
    (39) a -> . b
    (40) b -> . b AND c
    (41) b -> . c
    (42) c -> . NOT d
    (43) c -> . d
    (44) d -> . d DISTINTO_QUE e
    (45) d -> . d MENOR_QUE e
    (46) d -> . d MENOR_IGUAL_QUE e
    (47) d -> . d MAYOR_QUE e
    (48) d -> . d MAYOR_IGUAL_QUE e
    (49) d -> . d TRIPLE_IGUAL e
    (50) d -> . e
    (51) e -> . e MAS f
    (52) e -> . e MENOS f
    (53) e -> . f
    (54) f -> . f TIMES g
    (55) f -> . f DIVIDE g
    (56) f -> . f MOD g
    (57) f -> . f POTENCIA g
    (58) f -> . g
    (59) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    NOT             shift and go to state 46
    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    g                              shift and go to state 50
    expresion                      shift and go to state 140
    a                              shift and go to state 96
    b                              shift and go to state 44
    c                              shift and go to state 45
    d                              shift and go to state 47
    e                              shift and go to state 48
    f                              shift and go to state 49

state 132

    (25) if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones . R_LLAVE else_pro
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . sumadores sc
    (35) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (14) declaration_instruction -> . LET declaracion_list
    (24) assig_pro -> . LITERAL IGUAL a
    (25) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (29) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (30) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (31) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (32) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (65) sumadores -> . LITERAL MAS MAS
    (66) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 141
    CONSOLE         shift and go to state 12
    LET             shift and go to state 13
    LITERAL         shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17

    instruccion                    shift and go to state 18
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    sumadores                      shift and go to state 11

state 133

    (29) while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . sumadores sc
    (35) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (14) declaration_instruction -> . LET declaracion_list
    (24) assig_pro -> . LITERAL IGUAL a
    (25) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (29) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (30) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (31) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (32) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (65) sumadores -> . LITERAL MAS MAS
    (66) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 142
    CONSOLE         shift and go to state 12
    LET             shift and go to state 13
    LITERAL         shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17

    instruccion                    shift and go to state 18
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    sumadores                      shift and go to state 11

state 134

    (30) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON . assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) assig_pro -> . LITERAL IGUAL a

    LITERAL         shift and go to state 63

    assig_pro                      shift and go to state 143

state 135

    (31) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON . assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) assig_pro -> . LITERAL IGUAL a

    LITERAL         shift and go to state 63

    assig_pro                      shift and go to state 144

state 136

    (32) for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . sumadores sc
    (35) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (14) declaration_instruction -> . LET declaracion_list
    (24) assig_pro -> . LITERAL IGUAL a
    (25) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (29) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (30) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (31) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (32) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (65) sumadores -> . LITERAL MAS MAS
    (66) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 145
    CONSOLE         shift and go to state 12
    LET             shift and go to state 13
    LITERAL         shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17

    instruccion                    shift and go to state 18
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    sumadores                      shift and go to state 11

state 137

    (33) for_each_dec -> LET LITERAL OF a .
    (38) a -> a . OR b

    R_PAREN         reduce using rule 33 (for_each_dec -> LET LITERAL OF a .)
    OR              shift and go to state 72


state 138

    (34) for_each_dec -> LET LITERAL COLON type . OF a
    (17) assignacion_instruction -> LITERAL COLON type . IGUAL a
    (18) assignacion_instruction -> LITERAL COLON type .

    OF              shift and go to state 146
    IGUAL           shift and go to state 97
    COMA            reduce using rule 18 (assignacion_instruction -> LITERAL COLON type .)
    SEMI_COLON      reduce using rule 18 (assignacion_instruction -> LITERAL COLON type .)


state 139

    (36) expresion -> expresion COMA a .
    (38) a -> a . OR b

    R_PAREN         reduce using rule 36 (expresion -> expresion COMA a .)
    COMA            reduce using rule 36 (expresion -> expresion COMA a .)
    OR              shift and go to state 72


state 140

    (59) f -> g PUNTO nativeFun L_PAREN expresion . R_PAREN
    (36) expresion -> expresion . COMA a

    R_PAREN         shift and go to state 147
    COMA            shift and go to state 129


state 141

    (25) if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE . else_pro
    (26) else_pro -> . ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (27) else_pro -> . ELSE L_LLAVE instrucciones R_LLAVE
    (28) else_pro -> .

    ELSE            shift and go to state 149
    SEMI_COLON      reduce using rule 28 (else_pro -> .)
    CONSOLE         reduce using rule 28 (else_pro -> .)
    LET             reduce using rule 28 (else_pro -> .)
    LITERAL         reduce using rule 28 (else_pro -> .)
    IF              reduce using rule 28 (else_pro -> .)
    WHILE           reduce using rule 28 (else_pro -> .)
    FOR             reduce using rule 28 (else_pro -> .)
    $end            reduce using rule 28 (else_pro -> .)
    R_LLAVE         reduce using rule 28 (else_pro -> .)

    else_pro                       shift and go to state 148

state 142

    (29) while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 29 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 29 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 29 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 29 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 29 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 29 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 29 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 29 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 29 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 143

    (30) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro . R_PAREN L_LLAVE instrucciones R_LLAVE

    R_PAREN         shift and go to state 150


state 144

    (31) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro . R_PAREN L_LLAVE instrucciones R_LLAVE

    R_PAREN         shift and go to state 151


state 145

    (32) for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 32 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 32 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 32 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 32 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 32 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 32 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 32 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 32 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 32 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 146

    (34) for_each_dec -> LET LITERAL COLON type OF . a
    (38) a -> . a OR b
    (39) a -> . b
    (40) b -> . b AND c
    (41) b -> . c
    (42) c -> . NOT d
    (43) c -> . d
    (44) d -> . d DISTINTO_QUE e
    (45) d -> . d MENOR_QUE e
    (46) d -> . d MENOR_IGUAL_QUE e
    (47) d -> . d MAYOR_QUE e
    (48) d -> . d MAYOR_IGUAL_QUE e
    (49) d -> . d TRIPLE_IGUAL e
    (50) d -> . e
    (51) e -> . e MAS f
    (52) e -> . e MENOS f
    (53) e -> . f
    (54) f -> . f TIMES g
    (55) f -> . f DIVIDE g
    (56) f -> . f MOD g
    (57) f -> . f POTENCIA g
    (58) f -> . g
    (59) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    NOT             shift and go to state 46
    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    a                              shift and go to state 152
    b                              shift and go to state 44
    c                              shift and go to state 45
    d                              shift and go to state 47
    e                              shift and go to state 48
    f                              shift and go to state 49
    g                              shift and go to state 50

state 147

    (59) f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .

    TIMES           reduce using rule 59 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    DIVIDE          reduce using rule 59 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MOD             reduce using rule 59 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    POTENCIA        reduce using rule 59 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MAS             reduce using rule 59 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MENOS           reduce using rule 59 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    DISTINTO_QUE    reduce using rule 59 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MENOR_QUE       reduce using rule 59 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MENOR_IGUAL_QUE reduce using rule 59 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MAYOR_QUE       reduce using rule 59 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MAYOR_IGUAL_QUE reduce using rule 59 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    TRIPLE_IGUAL    reduce using rule 59 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    AND             reduce using rule 59 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    OR              reduce using rule 59 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    SEMI_COLON      reduce using rule 59 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    CONSOLE         reduce using rule 59 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    LET             reduce using rule 59 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    LITERAL         reduce using rule 59 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    IF              reduce using rule 59 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    WHILE           reduce using rule 59 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    FOR             reduce using rule 59 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    $end            reduce using rule 59 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    R_LLAVE         reduce using rule 59 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    R_PAREN         reduce using rule 59 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    COMA            reduce using rule 59 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)


state 148

    (25) if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .

    SEMI_COLON      reduce using rule 25 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    CONSOLE         reduce using rule 25 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    LET             reduce using rule 25 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    LITERAL         reduce using rule 25 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    IF              reduce using rule 25 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    WHILE           reduce using rule 25 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    FOR             reduce using rule 25 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    $end            reduce using rule 25 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    R_LLAVE         reduce using rule 25 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)


state 149

    (26) else_pro -> ELSE . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (27) else_pro -> ELSE . L_LLAVE instrucciones R_LLAVE

    IF              shift and go to state 153
    L_LLAVE         shift and go to state 154


state 150

    (30) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 155


state 151

    (31) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 156


state 152

    (34) for_each_dec -> LET LITERAL COLON type OF a .
    (38) a -> a . OR b

    R_PAREN         reduce using rule 34 (for_each_dec -> LET LITERAL COLON type OF a .)
    OR              shift and go to state 72


state 153

    (26) else_pro -> ELSE IF . L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro

    L_PAREN         shift and go to state 157


state 154

    (27) else_pro -> ELSE L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . sumadores sc
    (35) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (14) declaration_instruction -> . LET declaracion_list
    (24) assig_pro -> . LITERAL IGUAL a
    (25) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (29) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (30) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (31) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (32) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (65) sumadores -> . LITERAL MAS MAS
    (66) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 12
    LET             shift and go to state 13
    LITERAL         shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17

    instrucciones                  shift and go to state 158
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    sumadores                      shift and go to state 11

state 155

    (30) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . sumadores sc
    (35) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (14) declaration_instruction -> . LET declaracion_list
    (24) assig_pro -> . LITERAL IGUAL a
    (25) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (29) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (30) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (31) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (32) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (65) sumadores -> . LITERAL MAS MAS
    (66) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 12
    LET             shift and go to state 13
    LITERAL         shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17

    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    instrucciones                  shift and go to state 159
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    sumadores                      shift and go to state 11

state 156

    (31) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . sumadores sc
    (35) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (14) declaration_instruction -> . LET declaracion_list
    (24) assig_pro -> . LITERAL IGUAL a
    (25) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (29) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (30) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (31) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (32) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (65) sumadores -> . LITERAL MAS MAS
    (66) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 12
    LET             shift and go to state 13
    LITERAL         shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17

    assig_pro                      shift and go to state 6
    instrucciones                  shift and go to state 160
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    sumadores                      shift and go to state 11

state 157

    (26) else_pro -> ELSE IF L_PAREN . a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (38) a -> . a OR b
    (39) a -> . b
    (40) b -> . b AND c
    (41) b -> . c
    (42) c -> . NOT d
    (43) c -> . d
    (44) d -> . d DISTINTO_QUE e
    (45) d -> . d MENOR_QUE e
    (46) d -> . d MENOR_IGUAL_QUE e
    (47) d -> . d MAYOR_QUE e
    (48) d -> . d MAYOR_IGUAL_QUE e
    (49) d -> . d TRIPLE_IGUAL e
    (50) d -> . e
    (51) e -> . e MAS f
    (52) e -> . e MENOS f
    (53) e -> . f
    (54) f -> . f TIMES g
    (55) f -> . f DIVIDE g
    (56) f -> . f MOD g
    (57) f -> . f POTENCIA g
    (58) f -> . g
    (59) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (60) g -> . ENTERO
    (61) g -> . DECIMAL
    (62) g -> . CADENA
    (63) g -> . LITERAL
    (64) g -> . L_PAREN a R_PAREN

    NOT             shift and go to state 46
    ENTERO          shift and go to state 52
    DECIMAL         shift and go to state 53
    CADENA          shift and go to state 54
    LITERAL         shift and go to state 42
    L_PAREN         shift and go to state 51

    a                              shift and go to state 161
    b                              shift and go to state 44
    c                              shift and go to state 45
    d                              shift and go to state 47
    e                              shift and go to state 48
    f                              shift and go to state 49
    g                              shift and go to state 50

state 158

    (27) else_pro -> ELSE L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . sumadores sc
    (35) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (14) declaration_instruction -> . LET declaracion_list
    (24) assig_pro -> . LITERAL IGUAL a
    (25) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (29) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (30) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (31) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (32) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (65) sumadores -> . LITERAL MAS MAS
    (66) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 162
    CONSOLE         shift and go to state 12
    LET             shift and go to state 13
    LITERAL         shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17

    instruccion                    shift and go to state 18
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    sumadores                      shift and go to state 11

state 159

    (30) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . sumadores sc
    (35) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (14) declaration_instruction -> . LET declaracion_list
    (24) assig_pro -> . LITERAL IGUAL a
    (25) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (29) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (30) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (31) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (32) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (65) sumadores -> . LITERAL MAS MAS
    (66) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 163
    CONSOLE         shift and go to state 12
    LET             shift and go to state 13
    LITERAL         shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17

    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    instruccion                    shift and go to state 18
    console_pro                    shift and go to state 4
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    sumadores                      shift and go to state 11

state 160

    (31) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . sumadores sc
    (35) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (14) declaration_instruction -> . LET declaracion_list
    (24) assig_pro -> . LITERAL IGUAL a
    (25) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (29) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (30) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (31) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (32) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (65) sumadores -> . LITERAL MAS MAS
    (66) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 164
    CONSOLE         shift and go to state 12
    LET             shift and go to state 13
    LITERAL         shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17

    assig_pro                      shift and go to state 6
    instruccion                    shift and go to state 18
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    sumadores                      shift and go to state 11

state 161

    (26) else_pro -> ELSE IF L_PAREN a . R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (38) a -> a . OR b

    R_PAREN         shift and go to state 165
    OR              shift and go to state 72


state 162

    (27) else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 27 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 27 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 27 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 27 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 27 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 27 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 27 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 27 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 27 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)


state 163

    (30) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 30 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 30 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 30 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 30 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 30 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 30 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 30 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 30 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 30 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 164

    (31) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 31 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 31 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 31 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 31 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 31 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 31 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 31 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 31 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 31 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 165

    (26) else_pro -> ELSE IF L_PAREN a R_PAREN . L_LLAVE instrucciones R_LLAVE else_pro

    L_LLAVE         shift and go to state 166


state 166

    (26) else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE . instrucciones R_LLAVE else_pro
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . sumadores sc
    (35) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (14) declaration_instruction -> . LET declaracion_list
    (24) assig_pro -> . LITERAL IGUAL a
    (25) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (29) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (30) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (31) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (32) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (65) sumadores -> . LITERAL MAS MAS
    (66) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 12
    LET             shift and go to state 13
    LITERAL         shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17

    instrucciones                  shift and go to state 167
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    sumadores                      shift and go to state 11

state 167

    (26) else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones . R_LLAVE else_pro
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . sumadores sc
    (35) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (14) declaration_instruction -> . LET declaracion_list
    (24) assig_pro -> . LITERAL IGUAL a
    (25) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (29) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (30) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (31) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (32) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (65) sumadores -> . LITERAL MAS MAS
    (66) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 168
    CONSOLE         shift and go to state 12
    LET             shift and go to state 13
    LITERAL         shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17

    instruccion                    shift and go to state 18
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    sumadores                      shift and go to state 11

state 168

    (26) else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE . else_pro
    (26) else_pro -> . ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (27) else_pro -> . ELSE L_LLAVE instrucciones R_LLAVE
    (28) else_pro -> .

    ELSE            shift and go to state 149
    SEMI_COLON      reduce using rule 28 (else_pro -> .)
    CONSOLE         reduce using rule 28 (else_pro -> .)
    LET             reduce using rule 28 (else_pro -> .)
    LITERAL         reduce using rule 28 (else_pro -> .)
    IF              reduce using rule 28 (else_pro -> .)
    WHILE           reduce using rule 28 (else_pro -> .)
    FOR             reduce using rule 28 (else_pro -> .)
    $end            reduce using rule 28 (else_pro -> .)
    R_LLAVE         reduce using rule 28 (else_pro -> .)

    else_pro                       shift and go to state 169

state 169

    (26) else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .

    SEMI_COLON      reduce using rule 26 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    CONSOLE         reduce using rule 26 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    LET             reduce using rule 26 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    LITERAL         reduce using rule 26 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    IF              reduce using rule 26 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    WHILE           reduce using rule 26 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    FOR             reduce using rule 26 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    $end            reduce using rule 26 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    R_LLAVE         reduce using rule 26 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)

