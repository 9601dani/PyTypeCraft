Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    NULL

Grammar

Rule 0     S' -> init
Rule 1     init -> instrucciones
Rule 2     instrucciones -> instrucciones instruccion
Rule 3     instrucciones -> instruccion
Rule 4     instruccion -> console_pro sc
Rule 5     instruccion -> declaration_instruction sc
Rule 6     instruccion -> assig_pro sc
Rule 7     instruccion -> if_pro sc
Rule 8     instruccion -> while_pro sc
Rule 9     instruccion -> for_pro sc
Rule 10    instruccion -> for_each_pro sc
Rule 11    instruccion -> interface_pro sc
Rule 12    instruccion -> continue_pro sc
Rule 13    instruccion -> break_pro sc
Rule 14    instruccion -> return_pro sc
Rule 15    instruccion -> function_pro sc
Rule 16    instruccion -> call_function_pro sc
Rule 17    instruccion -> sumadores sc
Rule 18    sc -> SEMI_COLON
Rule 19    sc -> <empty>
Rule 20    function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 21    function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 22    call_function_pro -> LITERAL L_PAREN values R_PAREN
Rule 23    call_function_pro -> LITERAL L_PAREN R_PAREN
Rule 24    values -> values COMA a
Rule 25    values -> a
Rule 26    parameters_pro -> parameters_pro COMA parameter_pro
Rule 27    parameters_pro -> parameter_pro
Rule 28    parameter_pro -> LITERAL COLON type
Rule 29    parameter_pro -> LITERAL
Rule 30    continue_pro -> CONTINUE
Rule 31    break_pro -> BREAK
Rule 32    return_pro -> RETURN
Rule 33    return_pro -> RETURN a
Rule 34    interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
Rule 35    interface_atributos -> interface_atributos interface_atributo sc
Rule 36    interface_atributos -> <empty>
Rule 37    interface_atributo -> LITERAL COLON type
Rule 38    interface_atributo -> LITERAL
Rule 39    declaration_instruction -> LET declaracion_list
Rule 40    declaracion_list -> declaracion_list COMA assignacion_instruction
Rule 41    declaracion_list -> assignacion_instruction
Rule 42    assignacion_instruction -> LITERAL COLON type IGUAL a
Rule 43    assignacion_instruction -> LITERAL COLON type
Rule 44    assignacion_instruction -> LITERAL IGUAL a
Rule 45    type -> NUMBER
Rule 46    type -> STRING
Rule 47    type -> BOOLEAN
Rule 48    type -> ANY
Rule 49    type -> LITERAL
Rule 50    assig_pro -> LITERAL IGUAL a
Rule 51    if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
Rule 52    else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
Rule 53    else_pro -> ELSE L_LLAVE instrucciones R_LLAVE
Rule 54    else_pro -> <empty>
Rule 55    while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 56    for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 57    for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 58    inDec_pro -> assig_pro
Rule 59    inDec_pro -> sumadores
Rule 60    for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 61    for_each_dec -> LET LITERAL OF a
Rule 62    for_each_dec -> LET LITERAL COLON type OF a
Rule 63    console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
Rule 64    expresion -> expresion COMA a
Rule 65    expresion -> a
Rule 66    a -> a OR b
Rule 67    a -> b
Rule 68    b -> b AND c
Rule 69    b -> c
Rule 70    c -> NOT d
Rule 71    c -> d
Rule 72    d -> d DISTINTO_QUE e
Rule 73    d -> d MENOR_QUE e
Rule 74    d -> d MENOR_IGUAL_QUE e
Rule 75    d -> d MAYOR_QUE e
Rule 76    d -> d MAYOR_IGUAL_QUE e
Rule 77    d -> d TRIPLE_IGUAL e
Rule 78    d -> e
Rule 79    e -> e MAS f
Rule 80    e -> e MENOS f
Rule 81    e -> f
Rule 82    f -> MENOS g
Rule 83    f -> MAS g
Rule 84    f -> g
Rule 85    g -> g TIMES h
Rule 86    g -> g DIVIDE h
Rule 87    g -> g MOD h
Rule 88    g -> g POTENCIA h
Rule 89    g -> h
Rule 90    g -> h PUNTO nativeFun L_PAREN expresion R_PAREN
Rule 91    g -> h PUNTO nativeFun L_PAREN R_PAREN
Rule 92    h -> ENTERO
Rule 93    h -> DECIMAL
Rule 94    h -> CADENA
Rule 95    h -> LITERAL
Rule 96    h -> TRUE
Rule 97    h -> FALSE
Rule 98    h -> call_function_pro
Rule 99    h -> array_pro
Rule 100   h -> interface_assi
Rule 101   h -> L_PAREN a R_PAREN
Rule 102   h -> array_val_pro
Rule 103   array_val_pro -> LITERAL dimensions
Rule 104   dimensions -> dimensions L_CORCHETE a R_CORCHETE
Rule 105   dimensions -> L_CORCHETE a R_CORCHETE
Rule 106   sumadores -> LITERAL MAS MAS
Rule 107   sumadores -> LITERAL MENOS MENOS
Rule 108   interface_assi -> L_LLAVE atributos_assi R_LLAVE
Rule 109   atributos_assi -> atributos_assi COMA LITERAL COLON a
Rule 110   atributos_assi -> LITERAL COLON a
Rule 111   array_pro -> L_CORCHETE values R_CORCHETE
Rule 112   nativeFun -> TOSTRING
Rule 113   nativeFun -> TOFIXED
Rule 114   nativeFun -> TOEXPONENTIAL
Rule 115   nativeFun -> TOLOWERCASE
Rule 116   nativeFun -> TOUPPERCASE
Rule 117   nativeFun -> SPLIT
Rule 118   nativeFun -> CONCAT

Terminals, with rules where they appear

AND                  : 68
ANY                  : 48
BOOLEAN              : 47
BREAK                : 31
CADENA               : 94
COLON                : 28 37 42 43 62 109 110
COMA                 : 24 26 40 64 109
CONCAT               : 118
CONSOLE              : 63
CONTINUE             : 30
DECIMAL              : 93
DISTINTO_QUE         : 72
DIVIDE               : 86
ELSE                 : 52 53
ENTERO               : 92
FALSE                : 97
FOR                  : 56 57 60
FUNCTION             : 20 21
IF                   : 51 52
IGUAL                : 42 44 50
INTERFACE            : 34
LET                  : 39 61 62
LITERAL              : 20 21 22 23 28 29 34 37 38 42 43 44 49 50 61 62 95 103 106 107 109 110
LOG                  : 63
L_CORCHETE           : 104 105 111
L_LLAVE              : 20 21 34 51 52 53 55 56 57 60 108
L_PAREN              : 20 21 22 23 51 52 55 56 57 60 63 90 91 101
MAS                  : 79 83 106 106
MAYOR_IGUAL_QUE      : 76
MAYOR_QUE            : 75
MENOR_IGUAL_QUE      : 74
MENOR_QUE            : 73
MENOS                : 80 82 107 107
MOD                  : 87
NOT                  : 70
NULL                 : 
NUMBER               : 45
OF                   : 61 62
OR                   : 66
POTENCIA             : 88
PUNTO                : 63 90 91
RETURN               : 32 33
R_CORCHETE           : 104 105 111
R_LLAVE              : 20 21 34 51 52 53 55 56 57 60 108
R_PAREN              : 20 21 22 23 51 52 55 56 57 60 63 90 91 101
SEMI_COLON           : 18 56 56 57 57
SPLIT                : 117
STRING               : 46
TIMES                : 85
TOEXPONENTIAL        : 114
TOFIXED              : 113
TOLOWERCASE          : 115
TOSTRING             : 112
TOUPPERCASE          : 116
TRIPLE_IGUAL         : 77
TRUE                 : 96
WHILE                : 55
error                : 

Nonterminals, with rules where they appear

a                    : 24 25 33 42 44 50 51 52 55 56 57 61 62 64 65 66 101 104 105 109 110
array_pro            : 99
array_val_pro        : 102
assig_pro            : 6 57 58
assignacion_instruction : 40 41
atributos_assi       : 108 109
b                    : 66 67 68
break_pro            : 13
c                    : 68 69
call_function_pro    : 16 98
console_pro          : 4
continue_pro         : 12
d                    : 70 71 72 73 74 75 76 77
declaracion_list     : 39 40
declaration_instruction : 5 56
dimensions           : 103 104
e                    : 72 73 74 75 76 77 78 79 80
else_pro             : 51 52
expresion            : 63 64 90
f                    : 79 80 81
for_each_dec         : 60
for_each_pro         : 10
for_pro              : 9
function_pro         : 15
g                    : 82 83 84 85 86 87 88
h                    : 85 86 87 88 89 90 91
if_pro               : 7
inDec_pro            : 56 57
init                 : 0
instruccion          : 2 3
instrucciones        : 1 2 20 21 51 52 53 55 56 57 60
interface_assi       : 100
interface_atributo   : 35
interface_atributos  : 34 35
interface_pro        : 11
nativeFun            : 90 91
parameter_pro        : 26 27
parameters_pro       : 20 26
return_pro           : 14
sc                   : 4 5 6 7 8 9 10 11 12 13 14 15 16 17 35
sumadores            : 17 59
type                 : 28 37 42 43 62
values               : 22 24 111
while_pro            : 8

Parsing method: LALR

state 0

    (0) S' -> . init
    (1) init -> . instrucciones
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . call_function_pro sc
    (17) instruccion -> . sumadores sc
    (63) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (39) declaration_instruction -> . LET declaracion_list
    (50) assig_pro -> . LITERAL IGUAL a
    (51) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (55) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (56) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (57) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (60) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (34) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (30) continue_pro -> . CONTINUE
    (31) break_pro -> . BREAK
    (32) return_pro -> . RETURN
    (33) return_pro -> . RETURN a
    (20) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (21) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (106) sumadores -> . LITERAL MAS MAS
    (107) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 18
    LET             shift and go to state 19
    LITERAL         shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    INTERFACE       shift and go to state 24
    CONTINUE        shift and go to state 25
    BREAK           shift and go to state 26
    RETURN          shift and go to state 27
    FUNCTION        shift and go to state 28

    init                           shift and go to state 1
    instrucciones                  shift and go to state 2
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    call_function_pro              shift and go to state 16
    sumadores                      shift and go to state 17

state 1

    (0) S' -> init .



state 2

    (1) init -> instrucciones .
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . call_function_pro sc
    (17) instruccion -> . sumadores sc
    (63) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (39) declaration_instruction -> . LET declaracion_list
    (50) assig_pro -> . LITERAL IGUAL a
    (51) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (55) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (56) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (57) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (60) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (34) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (30) continue_pro -> . CONTINUE
    (31) break_pro -> . BREAK
    (32) return_pro -> . RETURN
    (33) return_pro -> . RETURN a
    (20) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (21) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (106) sumadores -> . LITERAL MAS MAS
    (107) sumadores -> . LITERAL MENOS MENOS

    $end            reduce using rule 1 (init -> instrucciones .)
    CONSOLE         shift and go to state 18
    LET             shift and go to state 19
    LITERAL         shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    INTERFACE       shift and go to state 24
    CONTINUE        shift and go to state 25
    BREAK           shift and go to state 26
    RETURN          shift and go to state 27
    FUNCTION        shift and go to state 28

    instruccion                    shift and go to state 29
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    call_function_pro              shift and go to state 16
    sumadores                      shift and go to state 17

state 3

    (3) instrucciones -> instruccion .

    CONSOLE         reduce using rule 3 (instrucciones -> instruccion .)
    LET             reduce using rule 3 (instrucciones -> instruccion .)
    LITERAL         reduce using rule 3 (instrucciones -> instruccion .)
    IF              reduce using rule 3 (instrucciones -> instruccion .)
    WHILE           reduce using rule 3 (instrucciones -> instruccion .)
    FOR             reduce using rule 3 (instrucciones -> instruccion .)
    INTERFACE       reduce using rule 3 (instrucciones -> instruccion .)
    CONTINUE        reduce using rule 3 (instrucciones -> instruccion .)
    BREAK           reduce using rule 3 (instrucciones -> instruccion .)
    RETURN          reduce using rule 3 (instrucciones -> instruccion .)
    FUNCTION        reduce using rule 3 (instrucciones -> instruccion .)
    $end            reduce using rule 3 (instrucciones -> instruccion .)
    R_LLAVE         reduce using rule 3 (instrucciones -> instruccion .)


state 4

    (4) instruccion -> console_pro . sc
    (18) sc -> . SEMI_COLON
    (19) sc -> .

    SEMI_COLON      shift and go to state 31
    CONSOLE         reduce using rule 19 (sc -> .)
    LET             reduce using rule 19 (sc -> .)
    LITERAL         reduce using rule 19 (sc -> .)
    IF              reduce using rule 19 (sc -> .)
    WHILE           reduce using rule 19 (sc -> .)
    FOR             reduce using rule 19 (sc -> .)
    INTERFACE       reduce using rule 19 (sc -> .)
    CONTINUE        reduce using rule 19 (sc -> .)
    BREAK           reduce using rule 19 (sc -> .)
    RETURN          reduce using rule 19 (sc -> .)
    FUNCTION        reduce using rule 19 (sc -> .)
    $end            reduce using rule 19 (sc -> .)
    R_LLAVE         reduce using rule 19 (sc -> .)

    sc                             shift and go to state 30

state 5

    (5) instruccion -> declaration_instruction . sc
    (18) sc -> . SEMI_COLON
    (19) sc -> .

    SEMI_COLON      shift and go to state 31
    CONSOLE         reduce using rule 19 (sc -> .)
    LET             reduce using rule 19 (sc -> .)
    LITERAL         reduce using rule 19 (sc -> .)
    IF              reduce using rule 19 (sc -> .)
    WHILE           reduce using rule 19 (sc -> .)
    FOR             reduce using rule 19 (sc -> .)
    INTERFACE       reduce using rule 19 (sc -> .)
    CONTINUE        reduce using rule 19 (sc -> .)
    BREAK           reduce using rule 19 (sc -> .)
    RETURN          reduce using rule 19 (sc -> .)
    FUNCTION        reduce using rule 19 (sc -> .)
    $end            reduce using rule 19 (sc -> .)
    R_LLAVE         reduce using rule 19 (sc -> .)

    sc                             shift and go to state 32

state 6

    (6) instruccion -> assig_pro . sc
    (18) sc -> . SEMI_COLON
    (19) sc -> .

    SEMI_COLON      shift and go to state 31
    CONSOLE         reduce using rule 19 (sc -> .)
    LET             reduce using rule 19 (sc -> .)
    LITERAL         reduce using rule 19 (sc -> .)
    IF              reduce using rule 19 (sc -> .)
    WHILE           reduce using rule 19 (sc -> .)
    FOR             reduce using rule 19 (sc -> .)
    INTERFACE       reduce using rule 19 (sc -> .)
    CONTINUE        reduce using rule 19 (sc -> .)
    BREAK           reduce using rule 19 (sc -> .)
    RETURN          reduce using rule 19 (sc -> .)
    FUNCTION        reduce using rule 19 (sc -> .)
    $end            reduce using rule 19 (sc -> .)
    R_LLAVE         reduce using rule 19 (sc -> .)

    sc                             shift and go to state 33

state 7

    (7) instruccion -> if_pro . sc
    (18) sc -> . SEMI_COLON
    (19) sc -> .

    SEMI_COLON      shift and go to state 31
    CONSOLE         reduce using rule 19 (sc -> .)
    LET             reduce using rule 19 (sc -> .)
    LITERAL         reduce using rule 19 (sc -> .)
    IF              reduce using rule 19 (sc -> .)
    WHILE           reduce using rule 19 (sc -> .)
    FOR             reduce using rule 19 (sc -> .)
    INTERFACE       reduce using rule 19 (sc -> .)
    CONTINUE        reduce using rule 19 (sc -> .)
    BREAK           reduce using rule 19 (sc -> .)
    RETURN          reduce using rule 19 (sc -> .)
    FUNCTION        reduce using rule 19 (sc -> .)
    $end            reduce using rule 19 (sc -> .)
    R_LLAVE         reduce using rule 19 (sc -> .)

    sc                             shift and go to state 34

state 8

    (8) instruccion -> while_pro . sc
    (18) sc -> . SEMI_COLON
    (19) sc -> .

    SEMI_COLON      shift and go to state 31
    CONSOLE         reduce using rule 19 (sc -> .)
    LET             reduce using rule 19 (sc -> .)
    LITERAL         reduce using rule 19 (sc -> .)
    IF              reduce using rule 19 (sc -> .)
    WHILE           reduce using rule 19 (sc -> .)
    FOR             reduce using rule 19 (sc -> .)
    INTERFACE       reduce using rule 19 (sc -> .)
    CONTINUE        reduce using rule 19 (sc -> .)
    BREAK           reduce using rule 19 (sc -> .)
    RETURN          reduce using rule 19 (sc -> .)
    FUNCTION        reduce using rule 19 (sc -> .)
    $end            reduce using rule 19 (sc -> .)
    R_LLAVE         reduce using rule 19 (sc -> .)

    sc                             shift and go to state 35

state 9

    (9) instruccion -> for_pro . sc
    (18) sc -> . SEMI_COLON
    (19) sc -> .

    SEMI_COLON      shift and go to state 31
    CONSOLE         reduce using rule 19 (sc -> .)
    LET             reduce using rule 19 (sc -> .)
    LITERAL         reduce using rule 19 (sc -> .)
    IF              reduce using rule 19 (sc -> .)
    WHILE           reduce using rule 19 (sc -> .)
    FOR             reduce using rule 19 (sc -> .)
    INTERFACE       reduce using rule 19 (sc -> .)
    CONTINUE        reduce using rule 19 (sc -> .)
    BREAK           reduce using rule 19 (sc -> .)
    RETURN          reduce using rule 19 (sc -> .)
    FUNCTION        reduce using rule 19 (sc -> .)
    $end            reduce using rule 19 (sc -> .)
    R_LLAVE         reduce using rule 19 (sc -> .)

    sc                             shift and go to state 36

state 10

    (10) instruccion -> for_each_pro . sc
    (18) sc -> . SEMI_COLON
    (19) sc -> .

    SEMI_COLON      shift and go to state 31
    CONSOLE         reduce using rule 19 (sc -> .)
    LET             reduce using rule 19 (sc -> .)
    LITERAL         reduce using rule 19 (sc -> .)
    IF              reduce using rule 19 (sc -> .)
    WHILE           reduce using rule 19 (sc -> .)
    FOR             reduce using rule 19 (sc -> .)
    INTERFACE       reduce using rule 19 (sc -> .)
    CONTINUE        reduce using rule 19 (sc -> .)
    BREAK           reduce using rule 19 (sc -> .)
    RETURN          reduce using rule 19 (sc -> .)
    FUNCTION        reduce using rule 19 (sc -> .)
    $end            reduce using rule 19 (sc -> .)
    R_LLAVE         reduce using rule 19 (sc -> .)

    sc                             shift and go to state 37

state 11

    (11) instruccion -> interface_pro . sc
    (18) sc -> . SEMI_COLON
    (19) sc -> .

    SEMI_COLON      shift and go to state 31
    CONSOLE         reduce using rule 19 (sc -> .)
    LET             reduce using rule 19 (sc -> .)
    LITERAL         reduce using rule 19 (sc -> .)
    IF              reduce using rule 19 (sc -> .)
    WHILE           reduce using rule 19 (sc -> .)
    FOR             reduce using rule 19 (sc -> .)
    INTERFACE       reduce using rule 19 (sc -> .)
    CONTINUE        reduce using rule 19 (sc -> .)
    BREAK           reduce using rule 19 (sc -> .)
    RETURN          reduce using rule 19 (sc -> .)
    FUNCTION        reduce using rule 19 (sc -> .)
    $end            reduce using rule 19 (sc -> .)
    R_LLAVE         reduce using rule 19 (sc -> .)

    sc                             shift and go to state 38

state 12

    (12) instruccion -> continue_pro . sc
    (18) sc -> . SEMI_COLON
    (19) sc -> .

    SEMI_COLON      shift and go to state 31
    CONSOLE         reduce using rule 19 (sc -> .)
    LET             reduce using rule 19 (sc -> .)
    LITERAL         reduce using rule 19 (sc -> .)
    IF              reduce using rule 19 (sc -> .)
    WHILE           reduce using rule 19 (sc -> .)
    FOR             reduce using rule 19 (sc -> .)
    INTERFACE       reduce using rule 19 (sc -> .)
    CONTINUE        reduce using rule 19 (sc -> .)
    BREAK           reduce using rule 19 (sc -> .)
    RETURN          reduce using rule 19 (sc -> .)
    FUNCTION        reduce using rule 19 (sc -> .)
    $end            reduce using rule 19 (sc -> .)
    R_LLAVE         reduce using rule 19 (sc -> .)

    sc                             shift and go to state 39

state 13

    (13) instruccion -> break_pro . sc
    (18) sc -> . SEMI_COLON
    (19) sc -> .

    SEMI_COLON      shift and go to state 31
    CONSOLE         reduce using rule 19 (sc -> .)
    LET             reduce using rule 19 (sc -> .)
    LITERAL         reduce using rule 19 (sc -> .)
    IF              reduce using rule 19 (sc -> .)
    WHILE           reduce using rule 19 (sc -> .)
    FOR             reduce using rule 19 (sc -> .)
    INTERFACE       reduce using rule 19 (sc -> .)
    CONTINUE        reduce using rule 19 (sc -> .)
    BREAK           reduce using rule 19 (sc -> .)
    RETURN          reduce using rule 19 (sc -> .)
    FUNCTION        reduce using rule 19 (sc -> .)
    $end            reduce using rule 19 (sc -> .)
    R_LLAVE         reduce using rule 19 (sc -> .)

    sc                             shift and go to state 40

state 14

    (14) instruccion -> return_pro . sc
    (18) sc -> . SEMI_COLON
    (19) sc -> .

    SEMI_COLON      shift and go to state 31
    CONSOLE         reduce using rule 19 (sc -> .)
    LET             reduce using rule 19 (sc -> .)
    LITERAL         reduce using rule 19 (sc -> .)
    IF              reduce using rule 19 (sc -> .)
    WHILE           reduce using rule 19 (sc -> .)
    FOR             reduce using rule 19 (sc -> .)
    INTERFACE       reduce using rule 19 (sc -> .)
    CONTINUE        reduce using rule 19 (sc -> .)
    BREAK           reduce using rule 19 (sc -> .)
    RETURN          reduce using rule 19 (sc -> .)
    FUNCTION        reduce using rule 19 (sc -> .)
    $end            reduce using rule 19 (sc -> .)
    R_LLAVE         reduce using rule 19 (sc -> .)

    sc                             shift and go to state 41

state 15

    (15) instruccion -> function_pro . sc
    (18) sc -> . SEMI_COLON
    (19) sc -> .

    SEMI_COLON      shift and go to state 31
    CONSOLE         reduce using rule 19 (sc -> .)
    LET             reduce using rule 19 (sc -> .)
    LITERAL         reduce using rule 19 (sc -> .)
    IF              reduce using rule 19 (sc -> .)
    WHILE           reduce using rule 19 (sc -> .)
    FOR             reduce using rule 19 (sc -> .)
    INTERFACE       reduce using rule 19 (sc -> .)
    CONTINUE        reduce using rule 19 (sc -> .)
    BREAK           reduce using rule 19 (sc -> .)
    RETURN          reduce using rule 19 (sc -> .)
    FUNCTION        reduce using rule 19 (sc -> .)
    $end            reduce using rule 19 (sc -> .)
    R_LLAVE         reduce using rule 19 (sc -> .)

    sc                             shift and go to state 42

state 16

    (16) instruccion -> call_function_pro . sc
    (18) sc -> . SEMI_COLON
    (19) sc -> .

    SEMI_COLON      shift and go to state 31
    CONSOLE         reduce using rule 19 (sc -> .)
    LET             reduce using rule 19 (sc -> .)
    LITERAL         reduce using rule 19 (sc -> .)
    IF              reduce using rule 19 (sc -> .)
    WHILE           reduce using rule 19 (sc -> .)
    FOR             reduce using rule 19 (sc -> .)
    INTERFACE       reduce using rule 19 (sc -> .)
    CONTINUE        reduce using rule 19 (sc -> .)
    BREAK           reduce using rule 19 (sc -> .)
    RETURN          reduce using rule 19 (sc -> .)
    FUNCTION        reduce using rule 19 (sc -> .)
    $end            reduce using rule 19 (sc -> .)
    R_LLAVE         reduce using rule 19 (sc -> .)

    sc                             shift and go to state 43

state 17

    (17) instruccion -> sumadores . sc
    (18) sc -> . SEMI_COLON
    (19) sc -> .

    SEMI_COLON      shift and go to state 31
    CONSOLE         reduce using rule 19 (sc -> .)
    LET             reduce using rule 19 (sc -> .)
    LITERAL         reduce using rule 19 (sc -> .)
    IF              reduce using rule 19 (sc -> .)
    WHILE           reduce using rule 19 (sc -> .)
    FOR             reduce using rule 19 (sc -> .)
    INTERFACE       reduce using rule 19 (sc -> .)
    CONTINUE        reduce using rule 19 (sc -> .)
    BREAK           reduce using rule 19 (sc -> .)
    RETURN          reduce using rule 19 (sc -> .)
    FUNCTION        reduce using rule 19 (sc -> .)
    $end            reduce using rule 19 (sc -> .)
    R_LLAVE         reduce using rule 19 (sc -> .)

    sc                             shift and go to state 44

state 18

    (63) console_pro -> CONSOLE . PUNTO LOG L_PAREN expresion R_PAREN

    PUNTO           shift and go to state 45


state 19

    (39) declaration_instruction -> LET . declaracion_list
    (40) declaracion_list -> . declaracion_list COMA assignacion_instruction
    (41) declaracion_list -> . assignacion_instruction
    (42) assignacion_instruction -> . LITERAL COLON type IGUAL a
    (43) assignacion_instruction -> . LITERAL COLON type
    (44) assignacion_instruction -> . LITERAL IGUAL a

    LITERAL         shift and go to state 48

    declaracion_list               shift and go to state 46
    assignacion_instruction        shift and go to state 47

state 20

    (50) assig_pro -> LITERAL . IGUAL a
    (22) call_function_pro -> LITERAL . L_PAREN values R_PAREN
    (23) call_function_pro -> LITERAL . L_PAREN R_PAREN
    (106) sumadores -> LITERAL . MAS MAS
    (107) sumadores -> LITERAL . MENOS MENOS

    IGUAL           shift and go to state 49
    L_PAREN         shift and go to state 50
    MAS             shift and go to state 51
    MENOS           shift and go to state 52


state 21

    (51) if_pro -> IF . L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro

    L_PAREN         shift and go to state 53


state 22

    (55) while_pro -> WHILE . L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE

    L_PAREN         shift and go to state 54


state 23

    (56) for_pro -> FOR . L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (57) for_pro -> FOR . L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (60) for_each_pro -> FOR . L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE

    L_PAREN         shift and go to state 55


state 24

    (34) interface_pro -> INTERFACE . LITERAL L_LLAVE interface_atributos R_LLAVE

    LITERAL         shift and go to state 56


state 25

    (30) continue_pro -> CONTINUE .

    SEMI_COLON      reduce using rule 30 (continue_pro -> CONTINUE .)
    CONSOLE         reduce using rule 30 (continue_pro -> CONTINUE .)
    LET             reduce using rule 30 (continue_pro -> CONTINUE .)
    LITERAL         reduce using rule 30 (continue_pro -> CONTINUE .)
    IF              reduce using rule 30 (continue_pro -> CONTINUE .)
    WHILE           reduce using rule 30 (continue_pro -> CONTINUE .)
    FOR             reduce using rule 30 (continue_pro -> CONTINUE .)
    INTERFACE       reduce using rule 30 (continue_pro -> CONTINUE .)
    CONTINUE        reduce using rule 30 (continue_pro -> CONTINUE .)
    BREAK           reduce using rule 30 (continue_pro -> CONTINUE .)
    RETURN          reduce using rule 30 (continue_pro -> CONTINUE .)
    FUNCTION        reduce using rule 30 (continue_pro -> CONTINUE .)
    $end            reduce using rule 30 (continue_pro -> CONTINUE .)
    R_LLAVE         reduce using rule 30 (continue_pro -> CONTINUE .)


state 26

    (31) break_pro -> BREAK .

    SEMI_COLON      reduce using rule 31 (break_pro -> BREAK .)
    CONSOLE         reduce using rule 31 (break_pro -> BREAK .)
    LET             reduce using rule 31 (break_pro -> BREAK .)
    LITERAL         reduce using rule 31 (break_pro -> BREAK .)
    IF              reduce using rule 31 (break_pro -> BREAK .)
    WHILE           reduce using rule 31 (break_pro -> BREAK .)
    FOR             reduce using rule 31 (break_pro -> BREAK .)
    INTERFACE       reduce using rule 31 (break_pro -> BREAK .)
    CONTINUE        reduce using rule 31 (break_pro -> BREAK .)
    BREAK           reduce using rule 31 (break_pro -> BREAK .)
    RETURN          reduce using rule 31 (break_pro -> BREAK .)
    FUNCTION        reduce using rule 31 (break_pro -> BREAK .)
    $end            reduce using rule 31 (break_pro -> BREAK .)
    R_LLAVE         reduce using rule 31 (break_pro -> BREAK .)


state 27

    (32) return_pro -> RETURN .
    (33) return_pro -> RETURN . a
    (66) a -> . a OR b
    (67) a -> . b
    (68) b -> . b AND c
    (69) b -> . c
    (70) c -> . NOT d
    (71) c -> . d
    (72) d -> . d DISTINTO_QUE e
    (73) d -> . d MENOR_QUE e
    (74) d -> . d MENOR_IGUAL_QUE e
    (75) d -> . d MAYOR_QUE e
    (76) d -> . d MAYOR_IGUAL_QUE e
    (77) d -> . d TRIPLE_IGUAL e
    (78) d -> . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

  ! shift/reduce conflict for LITERAL resolved as shift
    SEMI_COLON      reduce using rule 32 (return_pro -> RETURN .)
    CONSOLE         reduce using rule 32 (return_pro -> RETURN .)
    LET             reduce using rule 32 (return_pro -> RETURN .)
    IF              reduce using rule 32 (return_pro -> RETURN .)
    WHILE           reduce using rule 32 (return_pro -> RETURN .)
    FOR             reduce using rule 32 (return_pro -> RETURN .)
    INTERFACE       reduce using rule 32 (return_pro -> RETURN .)
    CONTINUE        reduce using rule 32 (return_pro -> RETURN .)
    BREAK           reduce using rule 32 (return_pro -> RETURN .)
    RETURN          reduce using rule 32 (return_pro -> RETURN .)
    FUNCTION        reduce using rule 32 (return_pro -> RETURN .)
    $end            reduce using rule 32 (return_pro -> RETURN .)
    R_LLAVE         reduce using rule 32 (return_pro -> RETURN .)
    NOT             shift and go to state 60
    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

  ! LITERAL         [ reduce using rule 32 (return_pro -> RETURN .) ]

    a                              shift and go to state 57
    b                              shift and go to state 58
    c                              shift and go to state 59
    d                              shift and go to state 61
    e                              shift and go to state 62
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 28

    (20) function_pro -> FUNCTION . LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (21) function_pro -> FUNCTION . LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE

    LITERAL         shift and go to state 81


state 29

    (2) instrucciones -> instrucciones instruccion .

    CONSOLE         reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    LET             reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    LITERAL         reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    IF              reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    WHILE           reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    FOR             reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    INTERFACE       reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    CONTINUE        reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    BREAK           reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    RETURN          reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    FUNCTION        reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    $end            reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    R_LLAVE         reduce using rule 2 (instrucciones -> instrucciones instruccion .)


state 30

    (4) instruccion -> console_pro sc .

    CONSOLE         reduce using rule 4 (instruccion -> console_pro sc .)
    LET             reduce using rule 4 (instruccion -> console_pro sc .)
    LITERAL         reduce using rule 4 (instruccion -> console_pro sc .)
    IF              reduce using rule 4 (instruccion -> console_pro sc .)
    WHILE           reduce using rule 4 (instruccion -> console_pro sc .)
    FOR             reduce using rule 4 (instruccion -> console_pro sc .)
    INTERFACE       reduce using rule 4 (instruccion -> console_pro sc .)
    CONTINUE        reduce using rule 4 (instruccion -> console_pro sc .)
    BREAK           reduce using rule 4 (instruccion -> console_pro sc .)
    RETURN          reduce using rule 4 (instruccion -> console_pro sc .)
    FUNCTION        reduce using rule 4 (instruccion -> console_pro sc .)
    $end            reduce using rule 4 (instruccion -> console_pro sc .)
    R_LLAVE         reduce using rule 4 (instruccion -> console_pro sc .)


state 31

    (18) sc -> SEMI_COLON .

    CONSOLE         reduce using rule 18 (sc -> SEMI_COLON .)
    LET             reduce using rule 18 (sc -> SEMI_COLON .)
    LITERAL         reduce using rule 18 (sc -> SEMI_COLON .)
    IF              reduce using rule 18 (sc -> SEMI_COLON .)
    WHILE           reduce using rule 18 (sc -> SEMI_COLON .)
    FOR             reduce using rule 18 (sc -> SEMI_COLON .)
    INTERFACE       reduce using rule 18 (sc -> SEMI_COLON .)
    CONTINUE        reduce using rule 18 (sc -> SEMI_COLON .)
    BREAK           reduce using rule 18 (sc -> SEMI_COLON .)
    RETURN          reduce using rule 18 (sc -> SEMI_COLON .)
    FUNCTION        reduce using rule 18 (sc -> SEMI_COLON .)
    $end            reduce using rule 18 (sc -> SEMI_COLON .)
    R_LLAVE         reduce using rule 18 (sc -> SEMI_COLON .)


state 32

    (5) instruccion -> declaration_instruction sc .

    CONSOLE         reduce using rule 5 (instruccion -> declaration_instruction sc .)
    LET             reduce using rule 5 (instruccion -> declaration_instruction sc .)
    LITERAL         reduce using rule 5 (instruccion -> declaration_instruction sc .)
    IF              reduce using rule 5 (instruccion -> declaration_instruction sc .)
    WHILE           reduce using rule 5 (instruccion -> declaration_instruction sc .)
    FOR             reduce using rule 5 (instruccion -> declaration_instruction sc .)
    INTERFACE       reduce using rule 5 (instruccion -> declaration_instruction sc .)
    CONTINUE        reduce using rule 5 (instruccion -> declaration_instruction sc .)
    BREAK           reduce using rule 5 (instruccion -> declaration_instruction sc .)
    RETURN          reduce using rule 5 (instruccion -> declaration_instruction sc .)
    FUNCTION        reduce using rule 5 (instruccion -> declaration_instruction sc .)
    $end            reduce using rule 5 (instruccion -> declaration_instruction sc .)
    R_LLAVE         reduce using rule 5 (instruccion -> declaration_instruction sc .)


state 33

    (6) instruccion -> assig_pro sc .

    CONSOLE         reduce using rule 6 (instruccion -> assig_pro sc .)
    LET             reduce using rule 6 (instruccion -> assig_pro sc .)
    LITERAL         reduce using rule 6 (instruccion -> assig_pro sc .)
    IF              reduce using rule 6 (instruccion -> assig_pro sc .)
    WHILE           reduce using rule 6 (instruccion -> assig_pro sc .)
    FOR             reduce using rule 6 (instruccion -> assig_pro sc .)
    INTERFACE       reduce using rule 6 (instruccion -> assig_pro sc .)
    CONTINUE        reduce using rule 6 (instruccion -> assig_pro sc .)
    BREAK           reduce using rule 6 (instruccion -> assig_pro sc .)
    RETURN          reduce using rule 6 (instruccion -> assig_pro sc .)
    FUNCTION        reduce using rule 6 (instruccion -> assig_pro sc .)
    $end            reduce using rule 6 (instruccion -> assig_pro sc .)
    R_LLAVE         reduce using rule 6 (instruccion -> assig_pro sc .)


state 34

    (7) instruccion -> if_pro sc .

    CONSOLE         reduce using rule 7 (instruccion -> if_pro sc .)
    LET             reduce using rule 7 (instruccion -> if_pro sc .)
    LITERAL         reduce using rule 7 (instruccion -> if_pro sc .)
    IF              reduce using rule 7 (instruccion -> if_pro sc .)
    WHILE           reduce using rule 7 (instruccion -> if_pro sc .)
    FOR             reduce using rule 7 (instruccion -> if_pro sc .)
    INTERFACE       reduce using rule 7 (instruccion -> if_pro sc .)
    CONTINUE        reduce using rule 7 (instruccion -> if_pro sc .)
    BREAK           reduce using rule 7 (instruccion -> if_pro sc .)
    RETURN          reduce using rule 7 (instruccion -> if_pro sc .)
    FUNCTION        reduce using rule 7 (instruccion -> if_pro sc .)
    $end            reduce using rule 7 (instruccion -> if_pro sc .)
    R_LLAVE         reduce using rule 7 (instruccion -> if_pro sc .)


state 35

    (8) instruccion -> while_pro sc .

    CONSOLE         reduce using rule 8 (instruccion -> while_pro sc .)
    LET             reduce using rule 8 (instruccion -> while_pro sc .)
    LITERAL         reduce using rule 8 (instruccion -> while_pro sc .)
    IF              reduce using rule 8 (instruccion -> while_pro sc .)
    WHILE           reduce using rule 8 (instruccion -> while_pro sc .)
    FOR             reduce using rule 8 (instruccion -> while_pro sc .)
    INTERFACE       reduce using rule 8 (instruccion -> while_pro sc .)
    CONTINUE        reduce using rule 8 (instruccion -> while_pro sc .)
    BREAK           reduce using rule 8 (instruccion -> while_pro sc .)
    RETURN          reduce using rule 8 (instruccion -> while_pro sc .)
    FUNCTION        reduce using rule 8 (instruccion -> while_pro sc .)
    $end            reduce using rule 8 (instruccion -> while_pro sc .)
    R_LLAVE         reduce using rule 8 (instruccion -> while_pro sc .)


state 36

    (9) instruccion -> for_pro sc .

    CONSOLE         reduce using rule 9 (instruccion -> for_pro sc .)
    LET             reduce using rule 9 (instruccion -> for_pro sc .)
    LITERAL         reduce using rule 9 (instruccion -> for_pro sc .)
    IF              reduce using rule 9 (instruccion -> for_pro sc .)
    WHILE           reduce using rule 9 (instruccion -> for_pro sc .)
    FOR             reduce using rule 9 (instruccion -> for_pro sc .)
    INTERFACE       reduce using rule 9 (instruccion -> for_pro sc .)
    CONTINUE        reduce using rule 9 (instruccion -> for_pro sc .)
    BREAK           reduce using rule 9 (instruccion -> for_pro sc .)
    RETURN          reduce using rule 9 (instruccion -> for_pro sc .)
    FUNCTION        reduce using rule 9 (instruccion -> for_pro sc .)
    $end            reduce using rule 9 (instruccion -> for_pro sc .)
    R_LLAVE         reduce using rule 9 (instruccion -> for_pro sc .)


state 37

    (10) instruccion -> for_each_pro sc .

    CONSOLE         reduce using rule 10 (instruccion -> for_each_pro sc .)
    LET             reduce using rule 10 (instruccion -> for_each_pro sc .)
    LITERAL         reduce using rule 10 (instruccion -> for_each_pro sc .)
    IF              reduce using rule 10 (instruccion -> for_each_pro sc .)
    WHILE           reduce using rule 10 (instruccion -> for_each_pro sc .)
    FOR             reduce using rule 10 (instruccion -> for_each_pro sc .)
    INTERFACE       reduce using rule 10 (instruccion -> for_each_pro sc .)
    CONTINUE        reduce using rule 10 (instruccion -> for_each_pro sc .)
    BREAK           reduce using rule 10 (instruccion -> for_each_pro sc .)
    RETURN          reduce using rule 10 (instruccion -> for_each_pro sc .)
    FUNCTION        reduce using rule 10 (instruccion -> for_each_pro sc .)
    $end            reduce using rule 10 (instruccion -> for_each_pro sc .)
    R_LLAVE         reduce using rule 10 (instruccion -> for_each_pro sc .)


state 38

    (11) instruccion -> interface_pro sc .

    CONSOLE         reduce using rule 11 (instruccion -> interface_pro sc .)
    LET             reduce using rule 11 (instruccion -> interface_pro sc .)
    LITERAL         reduce using rule 11 (instruccion -> interface_pro sc .)
    IF              reduce using rule 11 (instruccion -> interface_pro sc .)
    WHILE           reduce using rule 11 (instruccion -> interface_pro sc .)
    FOR             reduce using rule 11 (instruccion -> interface_pro sc .)
    INTERFACE       reduce using rule 11 (instruccion -> interface_pro sc .)
    CONTINUE        reduce using rule 11 (instruccion -> interface_pro sc .)
    BREAK           reduce using rule 11 (instruccion -> interface_pro sc .)
    RETURN          reduce using rule 11 (instruccion -> interface_pro sc .)
    FUNCTION        reduce using rule 11 (instruccion -> interface_pro sc .)
    $end            reduce using rule 11 (instruccion -> interface_pro sc .)
    R_LLAVE         reduce using rule 11 (instruccion -> interface_pro sc .)


state 39

    (12) instruccion -> continue_pro sc .

    CONSOLE         reduce using rule 12 (instruccion -> continue_pro sc .)
    LET             reduce using rule 12 (instruccion -> continue_pro sc .)
    LITERAL         reduce using rule 12 (instruccion -> continue_pro sc .)
    IF              reduce using rule 12 (instruccion -> continue_pro sc .)
    WHILE           reduce using rule 12 (instruccion -> continue_pro sc .)
    FOR             reduce using rule 12 (instruccion -> continue_pro sc .)
    INTERFACE       reduce using rule 12 (instruccion -> continue_pro sc .)
    CONTINUE        reduce using rule 12 (instruccion -> continue_pro sc .)
    BREAK           reduce using rule 12 (instruccion -> continue_pro sc .)
    RETURN          reduce using rule 12 (instruccion -> continue_pro sc .)
    FUNCTION        reduce using rule 12 (instruccion -> continue_pro sc .)
    $end            reduce using rule 12 (instruccion -> continue_pro sc .)
    R_LLAVE         reduce using rule 12 (instruccion -> continue_pro sc .)


state 40

    (13) instruccion -> break_pro sc .

    CONSOLE         reduce using rule 13 (instruccion -> break_pro sc .)
    LET             reduce using rule 13 (instruccion -> break_pro sc .)
    LITERAL         reduce using rule 13 (instruccion -> break_pro sc .)
    IF              reduce using rule 13 (instruccion -> break_pro sc .)
    WHILE           reduce using rule 13 (instruccion -> break_pro sc .)
    FOR             reduce using rule 13 (instruccion -> break_pro sc .)
    INTERFACE       reduce using rule 13 (instruccion -> break_pro sc .)
    CONTINUE        reduce using rule 13 (instruccion -> break_pro sc .)
    BREAK           reduce using rule 13 (instruccion -> break_pro sc .)
    RETURN          reduce using rule 13 (instruccion -> break_pro sc .)
    FUNCTION        reduce using rule 13 (instruccion -> break_pro sc .)
    $end            reduce using rule 13 (instruccion -> break_pro sc .)
    R_LLAVE         reduce using rule 13 (instruccion -> break_pro sc .)


state 41

    (14) instruccion -> return_pro sc .

    CONSOLE         reduce using rule 14 (instruccion -> return_pro sc .)
    LET             reduce using rule 14 (instruccion -> return_pro sc .)
    LITERAL         reduce using rule 14 (instruccion -> return_pro sc .)
    IF              reduce using rule 14 (instruccion -> return_pro sc .)
    WHILE           reduce using rule 14 (instruccion -> return_pro sc .)
    FOR             reduce using rule 14 (instruccion -> return_pro sc .)
    INTERFACE       reduce using rule 14 (instruccion -> return_pro sc .)
    CONTINUE        reduce using rule 14 (instruccion -> return_pro sc .)
    BREAK           reduce using rule 14 (instruccion -> return_pro sc .)
    RETURN          reduce using rule 14 (instruccion -> return_pro sc .)
    FUNCTION        reduce using rule 14 (instruccion -> return_pro sc .)
    $end            reduce using rule 14 (instruccion -> return_pro sc .)
    R_LLAVE         reduce using rule 14 (instruccion -> return_pro sc .)


state 42

    (15) instruccion -> function_pro sc .

    CONSOLE         reduce using rule 15 (instruccion -> function_pro sc .)
    LET             reduce using rule 15 (instruccion -> function_pro sc .)
    LITERAL         reduce using rule 15 (instruccion -> function_pro sc .)
    IF              reduce using rule 15 (instruccion -> function_pro sc .)
    WHILE           reduce using rule 15 (instruccion -> function_pro sc .)
    FOR             reduce using rule 15 (instruccion -> function_pro sc .)
    INTERFACE       reduce using rule 15 (instruccion -> function_pro sc .)
    CONTINUE        reduce using rule 15 (instruccion -> function_pro sc .)
    BREAK           reduce using rule 15 (instruccion -> function_pro sc .)
    RETURN          reduce using rule 15 (instruccion -> function_pro sc .)
    FUNCTION        reduce using rule 15 (instruccion -> function_pro sc .)
    $end            reduce using rule 15 (instruccion -> function_pro sc .)
    R_LLAVE         reduce using rule 15 (instruccion -> function_pro sc .)


state 43

    (16) instruccion -> call_function_pro sc .

    CONSOLE         reduce using rule 16 (instruccion -> call_function_pro sc .)
    LET             reduce using rule 16 (instruccion -> call_function_pro sc .)
    LITERAL         reduce using rule 16 (instruccion -> call_function_pro sc .)
    IF              reduce using rule 16 (instruccion -> call_function_pro sc .)
    WHILE           reduce using rule 16 (instruccion -> call_function_pro sc .)
    FOR             reduce using rule 16 (instruccion -> call_function_pro sc .)
    INTERFACE       reduce using rule 16 (instruccion -> call_function_pro sc .)
    CONTINUE        reduce using rule 16 (instruccion -> call_function_pro sc .)
    BREAK           reduce using rule 16 (instruccion -> call_function_pro sc .)
    RETURN          reduce using rule 16 (instruccion -> call_function_pro sc .)
    FUNCTION        reduce using rule 16 (instruccion -> call_function_pro sc .)
    $end            reduce using rule 16 (instruccion -> call_function_pro sc .)
    R_LLAVE         reduce using rule 16 (instruccion -> call_function_pro sc .)


state 44

    (17) instruccion -> sumadores sc .

    CONSOLE         reduce using rule 17 (instruccion -> sumadores sc .)
    LET             reduce using rule 17 (instruccion -> sumadores sc .)
    LITERAL         reduce using rule 17 (instruccion -> sumadores sc .)
    IF              reduce using rule 17 (instruccion -> sumadores sc .)
    WHILE           reduce using rule 17 (instruccion -> sumadores sc .)
    FOR             reduce using rule 17 (instruccion -> sumadores sc .)
    INTERFACE       reduce using rule 17 (instruccion -> sumadores sc .)
    CONTINUE        reduce using rule 17 (instruccion -> sumadores sc .)
    BREAK           reduce using rule 17 (instruccion -> sumadores sc .)
    RETURN          reduce using rule 17 (instruccion -> sumadores sc .)
    FUNCTION        reduce using rule 17 (instruccion -> sumadores sc .)
    $end            reduce using rule 17 (instruccion -> sumadores sc .)
    R_LLAVE         reduce using rule 17 (instruccion -> sumadores sc .)


state 45

    (63) console_pro -> CONSOLE PUNTO . LOG L_PAREN expresion R_PAREN

    LOG             shift and go to state 82


state 46

    (39) declaration_instruction -> LET declaracion_list .
    (40) declaracion_list -> declaracion_list . COMA assignacion_instruction

    SEMI_COLON      reduce using rule 39 (declaration_instruction -> LET declaracion_list .)
    CONSOLE         reduce using rule 39 (declaration_instruction -> LET declaracion_list .)
    LET             reduce using rule 39 (declaration_instruction -> LET declaracion_list .)
    LITERAL         reduce using rule 39 (declaration_instruction -> LET declaracion_list .)
    IF              reduce using rule 39 (declaration_instruction -> LET declaracion_list .)
    WHILE           reduce using rule 39 (declaration_instruction -> LET declaracion_list .)
    FOR             reduce using rule 39 (declaration_instruction -> LET declaracion_list .)
    INTERFACE       reduce using rule 39 (declaration_instruction -> LET declaracion_list .)
    CONTINUE        reduce using rule 39 (declaration_instruction -> LET declaracion_list .)
    BREAK           reduce using rule 39 (declaration_instruction -> LET declaracion_list .)
    RETURN          reduce using rule 39 (declaration_instruction -> LET declaracion_list .)
    FUNCTION        reduce using rule 39 (declaration_instruction -> LET declaracion_list .)
    $end            reduce using rule 39 (declaration_instruction -> LET declaracion_list .)
    R_LLAVE         reduce using rule 39 (declaration_instruction -> LET declaracion_list .)
    COMA            shift and go to state 83


state 47

    (41) declaracion_list -> assignacion_instruction .

    COMA            reduce using rule 41 (declaracion_list -> assignacion_instruction .)
    SEMI_COLON      reduce using rule 41 (declaracion_list -> assignacion_instruction .)
    CONSOLE         reduce using rule 41 (declaracion_list -> assignacion_instruction .)
    LET             reduce using rule 41 (declaracion_list -> assignacion_instruction .)
    LITERAL         reduce using rule 41 (declaracion_list -> assignacion_instruction .)
    IF              reduce using rule 41 (declaracion_list -> assignacion_instruction .)
    WHILE           reduce using rule 41 (declaracion_list -> assignacion_instruction .)
    FOR             reduce using rule 41 (declaracion_list -> assignacion_instruction .)
    INTERFACE       reduce using rule 41 (declaracion_list -> assignacion_instruction .)
    CONTINUE        reduce using rule 41 (declaracion_list -> assignacion_instruction .)
    BREAK           reduce using rule 41 (declaracion_list -> assignacion_instruction .)
    RETURN          reduce using rule 41 (declaracion_list -> assignacion_instruction .)
    FUNCTION        reduce using rule 41 (declaracion_list -> assignacion_instruction .)
    $end            reduce using rule 41 (declaracion_list -> assignacion_instruction .)
    R_LLAVE         reduce using rule 41 (declaracion_list -> assignacion_instruction .)


state 48

    (42) assignacion_instruction -> LITERAL . COLON type IGUAL a
    (43) assignacion_instruction -> LITERAL . COLON type
    (44) assignacion_instruction -> LITERAL . IGUAL a

    COLON           shift and go to state 84
    IGUAL           shift and go to state 85


state 49

    (50) assig_pro -> LITERAL IGUAL . a
    (66) a -> . a OR b
    (67) a -> . b
    (68) b -> . b AND c
    (69) b -> . c
    (70) c -> . NOT d
    (71) c -> . d
    (72) d -> . d DISTINTO_QUE e
    (73) d -> . d MENOR_QUE e
    (74) d -> . d MENOR_IGUAL_QUE e
    (75) d -> . d MAYOR_QUE e
    (76) d -> . d MAYOR_IGUAL_QUE e
    (77) d -> . d TRIPLE_IGUAL e
    (78) d -> . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 60
    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    a                              shift and go to state 86
    b                              shift and go to state 58
    c                              shift and go to state 59
    d                              shift and go to state 61
    e                              shift and go to state 62
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 50

    (22) call_function_pro -> LITERAL L_PAREN . values R_PAREN
    (23) call_function_pro -> LITERAL L_PAREN . R_PAREN
    (24) values -> . values COMA a
    (25) values -> . a
    (66) a -> . a OR b
    (67) a -> . b
    (68) b -> . b AND c
    (69) b -> . c
    (70) c -> . NOT d
    (71) c -> . d
    (72) d -> . d DISTINTO_QUE e
    (73) d -> . d MENOR_QUE e
    (74) d -> . d MENOR_IGUAL_QUE e
    (75) d -> . d MAYOR_QUE e
    (76) d -> . d MAYOR_IGUAL_QUE e
    (77) d -> . d TRIPLE_IGUAL e
    (78) d -> . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    R_PAREN         shift and go to state 88
    NOT             shift and go to state 60
    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    values                         shift and go to state 87
    a                              shift and go to state 89
    b                              shift and go to state 58
    c                              shift and go to state 59
    d                              shift and go to state 61
    e                              shift and go to state 62
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 51

    (106) sumadores -> LITERAL MAS . MAS

    MAS             shift and go to state 90


state 52

    (107) sumadores -> LITERAL MENOS . MENOS

    MENOS           shift and go to state 91


state 53

    (51) if_pro -> IF L_PAREN . a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) a -> . a OR b
    (67) a -> . b
    (68) b -> . b AND c
    (69) b -> . c
    (70) c -> . NOT d
    (71) c -> . d
    (72) d -> . d DISTINTO_QUE e
    (73) d -> . d MENOR_QUE e
    (74) d -> . d MENOR_IGUAL_QUE e
    (75) d -> . d MAYOR_QUE e
    (76) d -> . d MAYOR_IGUAL_QUE e
    (77) d -> . d TRIPLE_IGUAL e
    (78) d -> . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 60
    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    a                              shift and go to state 92
    b                              shift and go to state 58
    c                              shift and go to state 59
    d                              shift and go to state 61
    e                              shift and go to state 62
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 54

    (55) while_pro -> WHILE L_PAREN . a R_PAREN L_LLAVE instrucciones R_LLAVE
    (66) a -> . a OR b
    (67) a -> . b
    (68) b -> . b AND c
    (69) b -> . c
    (70) c -> . NOT d
    (71) c -> . d
    (72) d -> . d DISTINTO_QUE e
    (73) d -> . d MENOR_QUE e
    (74) d -> . d MENOR_IGUAL_QUE e
    (75) d -> . d MAYOR_QUE e
    (76) d -> . d MAYOR_IGUAL_QUE e
    (77) d -> . d TRIPLE_IGUAL e
    (78) d -> . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 60
    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    a                              shift and go to state 93
    b                              shift and go to state 58
    c                              shift and go to state 59
    d                              shift and go to state 61
    e                              shift and go to state 62
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 55

    (56) for_pro -> FOR L_PAREN . declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (57) for_pro -> FOR L_PAREN . assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (60) for_each_pro -> FOR L_PAREN . for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (39) declaration_instruction -> . LET declaracion_list
    (50) assig_pro -> . LITERAL IGUAL a
    (61) for_each_dec -> . LET LITERAL OF a
    (62) for_each_dec -> . LET LITERAL COLON type OF a

    LET             shift and go to state 97
    LITERAL         shift and go to state 98

    declaration_instruction        shift and go to state 94
    assig_pro                      shift and go to state 95
    for_each_dec                   shift and go to state 96

state 56

    (34) interface_pro -> INTERFACE LITERAL . L_LLAVE interface_atributos R_LLAVE

    L_LLAVE         shift and go to state 99


state 57

    (33) return_pro -> RETURN a .
    (66) a -> a . OR b

    SEMI_COLON      reduce using rule 33 (return_pro -> RETURN a .)
    CONSOLE         reduce using rule 33 (return_pro -> RETURN a .)
    LET             reduce using rule 33 (return_pro -> RETURN a .)
    LITERAL         reduce using rule 33 (return_pro -> RETURN a .)
    IF              reduce using rule 33 (return_pro -> RETURN a .)
    WHILE           reduce using rule 33 (return_pro -> RETURN a .)
    FOR             reduce using rule 33 (return_pro -> RETURN a .)
    INTERFACE       reduce using rule 33 (return_pro -> RETURN a .)
    CONTINUE        reduce using rule 33 (return_pro -> RETURN a .)
    BREAK           reduce using rule 33 (return_pro -> RETURN a .)
    RETURN          reduce using rule 33 (return_pro -> RETURN a .)
    FUNCTION        reduce using rule 33 (return_pro -> RETURN a .)
    $end            reduce using rule 33 (return_pro -> RETURN a .)
    R_LLAVE         reduce using rule 33 (return_pro -> RETURN a .)
    OR              shift and go to state 100


state 58

    (67) a -> b .
    (68) b -> b . AND c

    OR              reduce using rule 67 (a -> b .)
    SEMI_COLON      reduce using rule 67 (a -> b .)
    CONSOLE         reduce using rule 67 (a -> b .)
    LET             reduce using rule 67 (a -> b .)
    LITERAL         reduce using rule 67 (a -> b .)
    IF              reduce using rule 67 (a -> b .)
    WHILE           reduce using rule 67 (a -> b .)
    FOR             reduce using rule 67 (a -> b .)
    INTERFACE       reduce using rule 67 (a -> b .)
    CONTINUE        reduce using rule 67 (a -> b .)
    BREAK           reduce using rule 67 (a -> b .)
    RETURN          reduce using rule 67 (a -> b .)
    FUNCTION        reduce using rule 67 (a -> b .)
    $end            reduce using rule 67 (a -> b .)
    R_LLAVE         reduce using rule 67 (a -> b .)
    R_PAREN         reduce using rule 67 (a -> b .)
    COMA            reduce using rule 67 (a -> b .)
    R_CORCHETE      reduce using rule 67 (a -> b .)
    AND             shift and go to state 101


state 59

    (69) b -> c .

    AND             reduce using rule 69 (b -> c .)
    OR              reduce using rule 69 (b -> c .)
    SEMI_COLON      reduce using rule 69 (b -> c .)
    CONSOLE         reduce using rule 69 (b -> c .)
    LET             reduce using rule 69 (b -> c .)
    LITERAL         reduce using rule 69 (b -> c .)
    IF              reduce using rule 69 (b -> c .)
    WHILE           reduce using rule 69 (b -> c .)
    FOR             reduce using rule 69 (b -> c .)
    INTERFACE       reduce using rule 69 (b -> c .)
    CONTINUE        reduce using rule 69 (b -> c .)
    BREAK           reduce using rule 69 (b -> c .)
    RETURN          reduce using rule 69 (b -> c .)
    FUNCTION        reduce using rule 69 (b -> c .)
    $end            reduce using rule 69 (b -> c .)
    R_LLAVE         reduce using rule 69 (b -> c .)
    R_PAREN         reduce using rule 69 (b -> c .)
    COMA            reduce using rule 69 (b -> c .)
    R_CORCHETE      reduce using rule 69 (b -> c .)


state 60

    (70) c -> NOT . d
    (72) d -> . d DISTINTO_QUE e
    (73) d -> . d MENOR_QUE e
    (74) d -> . d MENOR_IGUAL_QUE e
    (75) d -> . d MAYOR_QUE e
    (76) d -> . d MAYOR_IGUAL_QUE e
    (77) d -> . d TRIPLE_IGUAL e
    (78) d -> . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    d                              shift and go to state 102
    e                              shift and go to state 62
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 61

    (71) c -> d .
    (72) d -> d . DISTINTO_QUE e
    (73) d -> d . MENOR_QUE e
    (74) d -> d . MENOR_IGUAL_QUE e
    (75) d -> d . MAYOR_QUE e
    (76) d -> d . MAYOR_IGUAL_QUE e
    (77) d -> d . TRIPLE_IGUAL e

    AND             reduce using rule 71 (c -> d .)
    OR              reduce using rule 71 (c -> d .)
    SEMI_COLON      reduce using rule 71 (c -> d .)
    CONSOLE         reduce using rule 71 (c -> d .)
    LET             reduce using rule 71 (c -> d .)
    LITERAL         reduce using rule 71 (c -> d .)
    IF              reduce using rule 71 (c -> d .)
    WHILE           reduce using rule 71 (c -> d .)
    FOR             reduce using rule 71 (c -> d .)
    INTERFACE       reduce using rule 71 (c -> d .)
    CONTINUE        reduce using rule 71 (c -> d .)
    BREAK           reduce using rule 71 (c -> d .)
    RETURN          reduce using rule 71 (c -> d .)
    FUNCTION        reduce using rule 71 (c -> d .)
    $end            reduce using rule 71 (c -> d .)
    R_LLAVE         reduce using rule 71 (c -> d .)
    R_PAREN         reduce using rule 71 (c -> d .)
    COMA            reduce using rule 71 (c -> d .)
    R_CORCHETE      reduce using rule 71 (c -> d .)
    DISTINTO_QUE    shift and go to state 103
    MENOR_QUE       shift and go to state 104
    MENOR_IGUAL_QUE shift and go to state 105
    MAYOR_QUE       shift and go to state 106
    MAYOR_IGUAL_QUE shift and go to state 107
    TRIPLE_IGUAL    shift and go to state 108


state 62

    (78) d -> e .
    (79) e -> e . MAS f
    (80) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 78 (d -> e .)
    MENOR_QUE       reduce using rule 78 (d -> e .)
    MENOR_IGUAL_QUE reduce using rule 78 (d -> e .)
    MAYOR_QUE       reduce using rule 78 (d -> e .)
    MAYOR_IGUAL_QUE reduce using rule 78 (d -> e .)
    TRIPLE_IGUAL    reduce using rule 78 (d -> e .)
    AND             reduce using rule 78 (d -> e .)
    OR              reduce using rule 78 (d -> e .)
    SEMI_COLON      reduce using rule 78 (d -> e .)
    CONSOLE         reduce using rule 78 (d -> e .)
    LET             reduce using rule 78 (d -> e .)
    LITERAL         reduce using rule 78 (d -> e .)
    IF              reduce using rule 78 (d -> e .)
    WHILE           reduce using rule 78 (d -> e .)
    FOR             reduce using rule 78 (d -> e .)
    INTERFACE       reduce using rule 78 (d -> e .)
    CONTINUE        reduce using rule 78 (d -> e .)
    BREAK           reduce using rule 78 (d -> e .)
    RETURN          reduce using rule 78 (d -> e .)
    FUNCTION        reduce using rule 78 (d -> e .)
    $end            reduce using rule 78 (d -> e .)
    R_LLAVE         reduce using rule 78 (d -> e .)
    R_PAREN         reduce using rule 78 (d -> e .)
    COMA            reduce using rule 78 (d -> e .)
    R_CORCHETE      reduce using rule 78 (d -> e .)
    MAS             shift and go to state 109
    MENOS           shift and go to state 110


state 63

    (83) f -> MAS . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    g                              shift and go to state 111
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 64

    (81) e -> f .

    MAS             reduce using rule 81 (e -> f .)
    MENOS           reduce using rule 81 (e -> f .)
    DISTINTO_QUE    reduce using rule 81 (e -> f .)
    MENOR_QUE       reduce using rule 81 (e -> f .)
    MENOR_IGUAL_QUE reduce using rule 81 (e -> f .)
    MAYOR_QUE       reduce using rule 81 (e -> f .)
    MAYOR_IGUAL_QUE reduce using rule 81 (e -> f .)
    TRIPLE_IGUAL    reduce using rule 81 (e -> f .)
    AND             reduce using rule 81 (e -> f .)
    OR              reduce using rule 81 (e -> f .)
    SEMI_COLON      reduce using rule 81 (e -> f .)
    CONSOLE         reduce using rule 81 (e -> f .)
    LET             reduce using rule 81 (e -> f .)
    LITERAL         reduce using rule 81 (e -> f .)
    IF              reduce using rule 81 (e -> f .)
    WHILE           reduce using rule 81 (e -> f .)
    FOR             reduce using rule 81 (e -> f .)
    INTERFACE       reduce using rule 81 (e -> f .)
    CONTINUE        reduce using rule 81 (e -> f .)
    BREAK           reduce using rule 81 (e -> f .)
    RETURN          reduce using rule 81 (e -> f .)
    FUNCTION        reduce using rule 81 (e -> f .)
    $end            reduce using rule 81 (e -> f .)
    R_LLAVE         reduce using rule 81 (e -> f .)
    R_PAREN         reduce using rule 81 (e -> f .)
    COMA            reduce using rule 81 (e -> f .)
    R_CORCHETE      reduce using rule 81 (e -> f .)


state 65

    (82) f -> MENOS . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    g                              shift and go to state 112
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 66

    (84) f -> g .
    (85) g -> g . TIMES h
    (86) g -> g . DIVIDE h
    (87) g -> g . MOD h
    (88) g -> g . POTENCIA h

    MAS             reduce using rule 84 (f -> g .)
    MENOS           reduce using rule 84 (f -> g .)
    DISTINTO_QUE    reduce using rule 84 (f -> g .)
    MENOR_QUE       reduce using rule 84 (f -> g .)
    MENOR_IGUAL_QUE reduce using rule 84 (f -> g .)
    MAYOR_QUE       reduce using rule 84 (f -> g .)
    MAYOR_IGUAL_QUE reduce using rule 84 (f -> g .)
    TRIPLE_IGUAL    reduce using rule 84 (f -> g .)
    AND             reduce using rule 84 (f -> g .)
    OR              reduce using rule 84 (f -> g .)
    SEMI_COLON      reduce using rule 84 (f -> g .)
    CONSOLE         reduce using rule 84 (f -> g .)
    LET             reduce using rule 84 (f -> g .)
    LITERAL         reduce using rule 84 (f -> g .)
    IF              reduce using rule 84 (f -> g .)
    WHILE           reduce using rule 84 (f -> g .)
    FOR             reduce using rule 84 (f -> g .)
    INTERFACE       reduce using rule 84 (f -> g .)
    CONTINUE        reduce using rule 84 (f -> g .)
    BREAK           reduce using rule 84 (f -> g .)
    RETURN          reduce using rule 84 (f -> g .)
    FUNCTION        reduce using rule 84 (f -> g .)
    $end            reduce using rule 84 (f -> g .)
    R_LLAVE         reduce using rule 84 (f -> g .)
    R_PAREN         reduce using rule 84 (f -> g .)
    COMA            reduce using rule 84 (f -> g .)
    R_CORCHETE      reduce using rule 84 (f -> g .)
    TIMES           shift and go to state 113
    DIVIDE          shift and go to state 114
    MOD             shift and go to state 115
    POTENCIA        shift and go to state 116


state 67

    (89) g -> h .
    (90) g -> h . PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> h . PUNTO nativeFun L_PAREN R_PAREN

    TIMES           reduce using rule 89 (g -> h .)
    DIVIDE          reduce using rule 89 (g -> h .)
    MOD             reduce using rule 89 (g -> h .)
    POTENCIA        reduce using rule 89 (g -> h .)
    MAS             reduce using rule 89 (g -> h .)
    MENOS           reduce using rule 89 (g -> h .)
    DISTINTO_QUE    reduce using rule 89 (g -> h .)
    MENOR_QUE       reduce using rule 89 (g -> h .)
    MENOR_IGUAL_QUE reduce using rule 89 (g -> h .)
    MAYOR_QUE       reduce using rule 89 (g -> h .)
    MAYOR_IGUAL_QUE reduce using rule 89 (g -> h .)
    TRIPLE_IGUAL    reduce using rule 89 (g -> h .)
    AND             reduce using rule 89 (g -> h .)
    OR              reduce using rule 89 (g -> h .)
    SEMI_COLON      reduce using rule 89 (g -> h .)
    CONSOLE         reduce using rule 89 (g -> h .)
    LET             reduce using rule 89 (g -> h .)
    LITERAL         reduce using rule 89 (g -> h .)
    IF              reduce using rule 89 (g -> h .)
    WHILE           reduce using rule 89 (g -> h .)
    FOR             reduce using rule 89 (g -> h .)
    INTERFACE       reduce using rule 89 (g -> h .)
    CONTINUE        reduce using rule 89 (g -> h .)
    BREAK           reduce using rule 89 (g -> h .)
    RETURN          reduce using rule 89 (g -> h .)
    FUNCTION        reduce using rule 89 (g -> h .)
    $end            reduce using rule 89 (g -> h .)
    R_LLAVE         reduce using rule 89 (g -> h .)
    R_PAREN         reduce using rule 89 (g -> h .)
    COMA            reduce using rule 89 (g -> h .)
    R_CORCHETE      reduce using rule 89 (g -> h .)
    PUNTO           shift and go to state 117


state 68

    (101) h -> L_PAREN . a R_PAREN
    (66) a -> . a OR b
    (67) a -> . b
    (68) b -> . b AND c
    (69) b -> . c
    (70) c -> . NOT d
    (71) c -> . d
    (72) d -> . d DISTINTO_QUE e
    (73) d -> . d MENOR_QUE e
    (74) d -> . d MENOR_IGUAL_QUE e
    (75) d -> . d MAYOR_QUE e
    (76) d -> . d MAYOR_IGUAL_QUE e
    (77) d -> . d TRIPLE_IGUAL e
    (78) d -> . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 60
    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    a                              shift and go to state 118
    b                              shift and go to state 58
    c                              shift and go to state 59
    d                              shift and go to state 61
    e                              shift and go to state 62
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 69

    (92) h -> ENTERO .

    PUNTO           reduce using rule 92 (h -> ENTERO .)
    TIMES           reduce using rule 92 (h -> ENTERO .)
    DIVIDE          reduce using rule 92 (h -> ENTERO .)
    MOD             reduce using rule 92 (h -> ENTERO .)
    POTENCIA        reduce using rule 92 (h -> ENTERO .)
    MAS             reduce using rule 92 (h -> ENTERO .)
    MENOS           reduce using rule 92 (h -> ENTERO .)
    DISTINTO_QUE    reduce using rule 92 (h -> ENTERO .)
    MENOR_QUE       reduce using rule 92 (h -> ENTERO .)
    MENOR_IGUAL_QUE reduce using rule 92 (h -> ENTERO .)
    MAYOR_QUE       reduce using rule 92 (h -> ENTERO .)
    MAYOR_IGUAL_QUE reduce using rule 92 (h -> ENTERO .)
    TRIPLE_IGUAL    reduce using rule 92 (h -> ENTERO .)
    AND             reduce using rule 92 (h -> ENTERO .)
    OR              reduce using rule 92 (h -> ENTERO .)
    SEMI_COLON      reduce using rule 92 (h -> ENTERO .)
    CONSOLE         reduce using rule 92 (h -> ENTERO .)
    LET             reduce using rule 92 (h -> ENTERO .)
    LITERAL         reduce using rule 92 (h -> ENTERO .)
    IF              reduce using rule 92 (h -> ENTERO .)
    WHILE           reduce using rule 92 (h -> ENTERO .)
    FOR             reduce using rule 92 (h -> ENTERO .)
    INTERFACE       reduce using rule 92 (h -> ENTERO .)
    CONTINUE        reduce using rule 92 (h -> ENTERO .)
    BREAK           reduce using rule 92 (h -> ENTERO .)
    RETURN          reduce using rule 92 (h -> ENTERO .)
    FUNCTION        reduce using rule 92 (h -> ENTERO .)
    $end            reduce using rule 92 (h -> ENTERO .)
    R_LLAVE         reduce using rule 92 (h -> ENTERO .)
    R_PAREN         reduce using rule 92 (h -> ENTERO .)
    COMA            reduce using rule 92 (h -> ENTERO .)
    R_CORCHETE      reduce using rule 92 (h -> ENTERO .)


state 70

    (93) h -> DECIMAL .

    PUNTO           reduce using rule 93 (h -> DECIMAL .)
    TIMES           reduce using rule 93 (h -> DECIMAL .)
    DIVIDE          reduce using rule 93 (h -> DECIMAL .)
    MOD             reduce using rule 93 (h -> DECIMAL .)
    POTENCIA        reduce using rule 93 (h -> DECIMAL .)
    MAS             reduce using rule 93 (h -> DECIMAL .)
    MENOS           reduce using rule 93 (h -> DECIMAL .)
    DISTINTO_QUE    reduce using rule 93 (h -> DECIMAL .)
    MENOR_QUE       reduce using rule 93 (h -> DECIMAL .)
    MENOR_IGUAL_QUE reduce using rule 93 (h -> DECIMAL .)
    MAYOR_QUE       reduce using rule 93 (h -> DECIMAL .)
    MAYOR_IGUAL_QUE reduce using rule 93 (h -> DECIMAL .)
    TRIPLE_IGUAL    reduce using rule 93 (h -> DECIMAL .)
    AND             reduce using rule 93 (h -> DECIMAL .)
    OR              reduce using rule 93 (h -> DECIMAL .)
    SEMI_COLON      reduce using rule 93 (h -> DECIMAL .)
    CONSOLE         reduce using rule 93 (h -> DECIMAL .)
    LET             reduce using rule 93 (h -> DECIMAL .)
    LITERAL         reduce using rule 93 (h -> DECIMAL .)
    IF              reduce using rule 93 (h -> DECIMAL .)
    WHILE           reduce using rule 93 (h -> DECIMAL .)
    FOR             reduce using rule 93 (h -> DECIMAL .)
    INTERFACE       reduce using rule 93 (h -> DECIMAL .)
    CONTINUE        reduce using rule 93 (h -> DECIMAL .)
    BREAK           reduce using rule 93 (h -> DECIMAL .)
    RETURN          reduce using rule 93 (h -> DECIMAL .)
    FUNCTION        reduce using rule 93 (h -> DECIMAL .)
    $end            reduce using rule 93 (h -> DECIMAL .)
    R_LLAVE         reduce using rule 93 (h -> DECIMAL .)
    R_PAREN         reduce using rule 93 (h -> DECIMAL .)
    COMA            reduce using rule 93 (h -> DECIMAL .)
    R_CORCHETE      reduce using rule 93 (h -> DECIMAL .)


state 71

    (94) h -> CADENA .

    PUNTO           reduce using rule 94 (h -> CADENA .)
    TIMES           reduce using rule 94 (h -> CADENA .)
    DIVIDE          reduce using rule 94 (h -> CADENA .)
    MOD             reduce using rule 94 (h -> CADENA .)
    POTENCIA        reduce using rule 94 (h -> CADENA .)
    MAS             reduce using rule 94 (h -> CADENA .)
    MENOS           reduce using rule 94 (h -> CADENA .)
    DISTINTO_QUE    reduce using rule 94 (h -> CADENA .)
    MENOR_QUE       reduce using rule 94 (h -> CADENA .)
    MENOR_IGUAL_QUE reduce using rule 94 (h -> CADENA .)
    MAYOR_QUE       reduce using rule 94 (h -> CADENA .)
    MAYOR_IGUAL_QUE reduce using rule 94 (h -> CADENA .)
    TRIPLE_IGUAL    reduce using rule 94 (h -> CADENA .)
    AND             reduce using rule 94 (h -> CADENA .)
    OR              reduce using rule 94 (h -> CADENA .)
    SEMI_COLON      reduce using rule 94 (h -> CADENA .)
    CONSOLE         reduce using rule 94 (h -> CADENA .)
    LET             reduce using rule 94 (h -> CADENA .)
    LITERAL         reduce using rule 94 (h -> CADENA .)
    IF              reduce using rule 94 (h -> CADENA .)
    WHILE           reduce using rule 94 (h -> CADENA .)
    FOR             reduce using rule 94 (h -> CADENA .)
    INTERFACE       reduce using rule 94 (h -> CADENA .)
    CONTINUE        reduce using rule 94 (h -> CADENA .)
    BREAK           reduce using rule 94 (h -> CADENA .)
    RETURN          reduce using rule 94 (h -> CADENA .)
    FUNCTION        reduce using rule 94 (h -> CADENA .)
    $end            reduce using rule 94 (h -> CADENA .)
    R_LLAVE         reduce using rule 94 (h -> CADENA .)
    R_PAREN         reduce using rule 94 (h -> CADENA .)
    COMA            reduce using rule 94 (h -> CADENA .)
    R_CORCHETE      reduce using rule 94 (h -> CADENA .)


state 72

    (95) h -> LITERAL .
    (22) call_function_pro -> LITERAL . L_PAREN values R_PAREN
    (23) call_function_pro -> LITERAL . L_PAREN R_PAREN
    (103) array_val_pro -> LITERAL . dimensions
    (104) dimensions -> . dimensions L_CORCHETE a R_CORCHETE
    (105) dimensions -> . L_CORCHETE a R_CORCHETE

    PUNTO           reduce using rule 95 (h -> LITERAL .)
    TIMES           reduce using rule 95 (h -> LITERAL .)
    DIVIDE          reduce using rule 95 (h -> LITERAL .)
    MOD             reduce using rule 95 (h -> LITERAL .)
    POTENCIA        reduce using rule 95 (h -> LITERAL .)
    MAS             reduce using rule 95 (h -> LITERAL .)
    MENOS           reduce using rule 95 (h -> LITERAL .)
    DISTINTO_QUE    reduce using rule 95 (h -> LITERAL .)
    MENOR_QUE       reduce using rule 95 (h -> LITERAL .)
    MENOR_IGUAL_QUE reduce using rule 95 (h -> LITERAL .)
    MAYOR_QUE       reduce using rule 95 (h -> LITERAL .)
    MAYOR_IGUAL_QUE reduce using rule 95 (h -> LITERAL .)
    TRIPLE_IGUAL    reduce using rule 95 (h -> LITERAL .)
    AND             reduce using rule 95 (h -> LITERAL .)
    OR              reduce using rule 95 (h -> LITERAL .)
    SEMI_COLON      reduce using rule 95 (h -> LITERAL .)
    CONSOLE         reduce using rule 95 (h -> LITERAL .)
    LET             reduce using rule 95 (h -> LITERAL .)
    LITERAL         reduce using rule 95 (h -> LITERAL .)
    IF              reduce using rule 95 (h -> LITERAL .)
    WHILE           reduce using rule 95 (h -> LITERAL .)
    FOR             reduce using rule 95 (h -> LITERAL .)
    INTERFACE       reduce using rule 95 (h -> LITERAL .)
    CONTINUE        reduce using rule 95 (h -> LITERAL .)
    BREAK           reduce using rule 95 (h -> LITERAL .)
    RETURN          reduce using rule 95 (h -> LITERAL .)
    FUNCTION        reduce using rule 95 (h -> LITERAL .)
    $end            reduce using rule 95 (h -> LITERAL .)
    R_LLAVE         reduce using rule 95 (h -> LITERAL .)
    R_PAREN         reduce using rule 95 (h -> LITERAL .)
    COMA            reduce using rule 95 (h -> LITERAL .)
    R_CORCHETE      reduce using rule 95 (h -> LITERAL .)
    L_PAREN         shift and go to state 50
    L_CORCHETE      shift and go to state 120

    dimensions                     shift and go to state 119

state 73

    (96) h -> TRUE .

    PUNTO           reduce using rule 96 (h -> TRUE .)
    TIMES           reduce using rule 96 (h -> TRUE .)
    DIVIDE          reduce using rule 96 (h -> TRUE .)
    MOD             reduce using rule 96 (h -> TRUE .)
    POTENCIA        reduce using rule 96 (h -> TRUE .)
    MAS             reduce using rule 96 (h -> TRUE .)
    MENOS           reduce using rule 96 (h -> TRUE .)
    DISTINTO_QUE    reduce using rule 96 (h -> TRUE .)
    MENOR_QUE       reduce using rule 96 (h -> TRUE .)
    MENOR_IGUAL_QUE reduce using rule 96 (h -> TRUE .)
    MAYOR_QUE       reduce using rule 96 (h -> TRUE .)
    MAYOR_IGUAL_QUE reduce using rule 96 (h -> TRUE .)
    TRIPLE_IGUAL    reduce using rule 96 (h -> TRUE .)
    AND             reduce using rule 96 (h -> TRUE .)
    OR              reduce using rule 96 (h -> TRUE .)
    SEMI_COLON      reduce using rule 96 (h -> TRUE .)
    CONSOLE         reduce using rule 96 (h -> TRUE .)
    LET             reduce using rule 96 (h -> TRUE .)
    LITERAL         reduce using rule 96 (h -> TRUE .)
    IF              reduce using rule 96 (h -> TRUE .)
    WHILE           reduce using rule 96 (h -> TRUE .)
    FOR             reduce using rule 96 (h -> TRUE .)
    INTERFACE       reduce using rule 96 (h -> TRUE .)
    CONTINUE        reduce using rule 96 (h -> TRUE .)
    BREAK           reduce using rule 96 (h -> TRUE .)
    RETURN          reduce using rule 96 (h -> TRUE .)
    FUNCTION        reduce using rule 96 (h -> TRUE .)
    $end            reduce using rule 96 (h -> TRUE .)
    R_LLAVE         reduce using rule 96 (h -> TRUE .)
    R_PAREN         reduce using rule 96 (h -> TRUE .)
    COMA            reduce using rule 96 (h -> TRUE .)
    R_CORCHETE      reduce using rule 96 (h -> TRUE .)


state 74

    (97) h -> FALSE .

    PUNTO           reduce using rule 97 (h -> FALSE .)
    TIMES           reduce using rule 97 (h -> FALSE .)
    DIVIDE          reduce using rule 97 (h -> FALSE .)
    MOD             reduce using rule 97 (h -> FALSE .)
    POTENCIA        reduce using rule 97 (h -> FALSE .)
    MAS             reduce using rule 97 (h -> FALSE .)
    MENOS           reduce using rule 97 (h -> FALSE .)
    DISTINTO_QUE    reduce using rule 97 (h -> FALSE .)
    MENOR_QUE       reduce using rule 97 (h -> FALSE .)
    MENOR_IGUAL_QUE reduce using rule 97 (h -> FALSE .)
    MAYOR_QUE       reduce using rule 97 (h -> FALSE .)
    MAYOR_IGUAL_QUE reduce using rule 97 (h -> FALSE .)
    TRIPLE_IGUAL    reduce using rule 97 (h -> FALSE .)
    AND             reduce using rule 97 (h -> FALSE .)
    OR              reduce using rule 97 (h -> FALSE .)
    SEMI_COLON      reduce using rule 97 (h -> FALSE .)
    CONSOLE         reduce using rule 97 (h -> FALSE .)
    LET             reduce using rule 97 (h -> FALSE .)
    LITERAL         reduce using rule 97 (h -> FALSE .)
    IF              reduce using rule 97 (h -> FALSE .)
    WHILE           reduce using rule 97 (h -> FALSE .)
    FOR             reduce using rule 97 (h -> FALSE .)
    INTERFACE       reduce using rule 97 (h -> FALSE .)
    CONTINUE        reduce using rule 97 (h -> FALSE .)
    BREAK           reduce using rule 97 (h -> FALSE .)
    RETURN          reduce using rule 97 (h -> FALSE .)
    FUNCTION        reduce using rule 97 (h -> FALSE .)
    $end            reduce using rule 97 (h -> FALSE .)
    R_LLAVE         reduce using rule 97 (h -> FALSE .)
    R_PAREN         reduce using rule 97 (h -> FALSE .)
    COMA            reduce using rule 97 (h -> FALSE .)
    R_CORCHETE      reduce using rule 97 (h -> FALSE .)


state 75

    (98) h -> call_function_pro .

    PUNTO           reduce using rule 98 (h -> call_function_pro .)
    TIMES           reduce using rule 98 (h -> call_function_pro .)
    DIVIDE          reduce using rule 98 (h -> call_function_pro .)
    MOD             reduce using rule 98 (h -> call_function_pro .)
    POTENCIA        reduce using rule 98 (h -> call_function_pro .)
    MAS             reduce using rule 98 (h -> call_function_pro .)
    MENOS           reduce using rule 98 (h -> call_function_pro .)
    DISTINTO_QUE    reduce using rule 98 (h -> call_function_pro .)
    MENOR_QUE       reduce using rule 98 (h -> call_function_pro .)
    MENOR_IGUAL_QUE reduce using rule 98 (h -> call_function_pro .)
    MAYOR_QUE       reduce using rule 98 (h -> call_function_pro .)
    MAYOR_IGUAL_QUE reduce using rule 98 (h -> call_function_pro .)
    TRIPLE_IGUAL    reduce using rule 98 (h -> call_function_pro .)
    AND             reduce using rule 98 (h -> call_function_pro .)
    OR              reduce using rule 98 (h -> call_function_pro .)
    SEMI_COLON      reduce using rule 98 (h -> call_function_pro .)
    CONSOLE         reduce using rule 98 (h -> call_function_pro .)
    LET             reduce using rule 98 (h -> call_function_pro .)
    LITERAL         reduce using rule 98 (h -> call_function_pro .)
    IF              reduce using rule 98 (h -> call_function_pro .)
    WHILE           reduce using rule 98 (h -> call_function_pro .)
    FOR             reduce using rule 98 (h -> call_function_pro .)
    INTERFACE       reduce using rule 98 (h -> call_function_pro .)
    CONTINUE        reduce using rule 98 (h -> call_function_pro .)
    BREAK           reduce using rule 98 (h -> call_function_pro .)
    RETURN          reduce using rule 98 (h -> call_function_pro .)
    FUNCTION        reduce using rule 98 (h -> call_function_pro .)
    $end            reduce using rule 98 (h -> call_function_pro .)
    R_LLAVE         reduce using rule 98 (h -> call_function_pro .)
    R_PAREN         reduce using rule 98 (h -> call_function_pro .)
    COMA            reduce using rule 98 (h -> call_function_pro .)
    R_CORCHETE      reduce using rule 98 (h -> call_function_pro .)


state 76

    (99) h -> array_pro .

    PUNTO           reduce using rule 99 (h -> array_pro .)
    TIMES           reduce using rule 99 (h -> array_pro .)
    DIVIDE          reduce using rule 99 (h -> array_pro .)
    MOD             reduce using rule 99 (h -> array_pro .)
    POTENCIA        reduce using rule 99 (h -> array_pro .)
    MAS             reduce using rule 99 (h -> array_pro .)
    MENOS           reduce using rule 99 (h -> array_pro .)
    DISTINTO_QUE    reduce using rule 99 (h -> array_pro .)
    MENOR_QUE       reduce using rule 99 (h -> array_pro .)
    MENOR_IGUAL_QUE reduce using rule 99 (h -> array_pro .)
    MAYOR_QUE       reduce using rule 99 (h -> array_pro .)
    MAYOR_IGUAL_QUE reduce using rule 99 (h -> array_pro .)
    TRIPLE_IGUAL    reduce using rule 99 (h -> array_pro .)
    AND             reduce using rule 99 (h -> array_pro .)
    OR              reduce using rule 99 (h -> array_pro .)
    SEMI_COLON      reduce using rule 99 (h -> array_pro .)
    CONSOLE         reduce using rule 99 (h -> array_pro .)
    LET             reduce using rule 99 (h -> array_pro .)
    LITERAL         reduce using rule 99 (h -> array_pro .)
    IF              reduce using rule 99 (h -> array_pro .)
    WHILE           reduce using rule 99 (h -> array_pro .)
    FOR             reduce using rule 99 (h -> array_pro .)
    INTERFACE       reduce using rule 99 (h -> array_pro .)
    CONTINUE        reduce using rule 99 (h -> array_pro .)
    BREAK           reduce using rule 99 (h -> array_pro .)
    RETURN          reduce using rule 99 (h -> array_pro .)
    FUNCTION        reduce using rule 99 (h -> array_pro .)
    $end            reduce using rule 99 (h -> array_pro .)
    R_LLAVE         reduce using rule 99 (h -> array_pro .)
    R_PAREN         reduce using rule 99 (h -> array_pro .)
    COMA            reduce using rule 99 (h -> array_pro .)
    R_CORCHETE      reduce using rule 99 (h -> array_pro .)


state 77

    (100) h -> interface_assi .

    PUNTO           reduce using rule 100 (h -> interface_assi .)
    TIMES           reduce using rule 100 (h -> interface_assi .)
    DIVIDE          reduce using rule 100 (h -> interface_assi .)
    MOD             reduce using rule 100 (h -> interface_assi .)
    POTENCIA        reduce using rule 100 (h -> interface_assi .)
    MAS             reduce using rule 100 (h -> interface_assi .)
    MENOS           reduce using rule 100 (h -> interface_assi .)
    DISTINTO_QUE    reduce using rule 100 (h -> interface_assi .)
    MENOR_QUE       reduce using rule 100 (h -> interface_assi .)
    MENOR_IGUAL_QUE reduce using rule 100 (h -> interface_assi .)
    MAYOR_QUE       reduce using rule 100 (h -> interface_assi .)
    MAYOR_IGUAL_QUE reduce using rule 100 (h -> interface_assi .)
    TRIPLE_IGUAL    reduce using rule 100 (h -> interface_assi .)
    AND             reduce using rule 100 (h -> interface_assi .)
    OR              reduce using rule 100 (h -> interface_assi .)
    SEMI_COLON      reduce using rule 100 (h -> interface_assi .)
    CONSOLE         reduce using rule 100 (h -> interface_assi .)
    LET             reduce using rule 100 (h -> interface_assi .)
    LITERAL         reduce using rule 100 (h -> interface_assi .)
    IF              reduce using rule 100 (h -> interface_assi .)
    WHILE           reduce using rule 100 (h -> interface_assi .)
    FOR             reduce using rule 100 (h -> interface_assi .)
    INTERFACE       reduce using rule 100 (h -> interface_assi .)
    CONTINUE        reduce using rule 100 (h -> interface_assi .)
    BREAK           reduce using rule 100 (h -> interface_assi .)
    RETURN          reduce using rule 100 (h -> interface_assi .)
    FUNCTION        reduce using rule 100 (h -> interface_assi .)
    $end            reduce using rule 100 (h -> interface_assi .)
    R_LLAVE         reduce using rule 100 (h -> interface_assi .)
    R_PAREN         reduce using rule 100 (h -> interface_assi .)
    COMA            reduce using rule 100 (h -> interface_assi .)
    R_CORCHETE      reduce using rule 100 (h -> interface_assi .)


state 78

    (102) h -> array_val_pro .

    PUNTO           reduce using rule 102 (h -> array_val_pro .)
    TIMES           reduce using rule 102 (h -> array_val_pro .)
    DIVIDE          reduce using rule 102 (h -> array_val_pro .)
    MOD             reduce using rule 102 (h -> array_val_pro .)
    POTENCIA        reduce using rule 102 (h -> array_val_pro .)
    MAS             reduce using rule 102 (h -> array_val_pro .)
    MENOS           reduce using rule 102 (h -> array_val_pro .)
    DISTINTO_QUE    reduce using rule 102 (h -> array_val_pro .)
    MENOR_QUE       reduce using rule 102 (h -> array_val_pro .)
    MENOR_IGUAL_QUE reduce using rule 102 (h -> array_val_pro .)
    MAYOR_QUE       reduce using rule 102 (h -> array_val_pro .)
    MAYOR_IGUAL_QUE reduce using rule 102 (h -> array_val_pro .)
    TRIPLE_IGUAL    reduce using rule 102 (h -> array_val_pro .)
    AND             reduce using rule 102 (h -> array_val_pro .)
    OR              reduce using rule 102 (h -> array_val_pro .)
    SEMI_COLON      reduce using rule 102 (h -> array_val_pro .)
    CONSOLE         reduce using rule 102 (h -> array_val_pro .)
    LET             reduce using rule 102 (h -> array_val_pro .)
    LITERAL         reduce using rule 102 (h -> array_val_pro .)
    IF              reduce using rule 102 (h -> array_val_pro .)
    WHILE           reduce using rule 102 (h -> array_val_pro .)
    FOR             reduce using rule 102 (h -> array_val_pro .)
    INTERFACE       reduce using rule 102 (h -> array_val_pro .)
    CONTINUE        reduce using rule 102 (h -> array_val_pro .)
    BREAK           reduce using rule 102 (h -> array_val_pro .)
    RETURN          reduce using rule 102 (h -> array_val_pro .)
    FUNCTION        reduce using rule 102 (h -> array_val_pro .)
    $end            reduce using rule 102 (h -> array_val_pro .)
    R_LLAVE         reduce using rule 102 (h -> array_val_pro .)
    R_PAREN         reduce using rule 102 (h -> array_val_pro .)
    COMA            reduce using rule 102 (h -> array_val_pro .)
    R_CORCHETE      reduce using rule 102 (h -> array_val_pro .)


state 79

    (111) array_pro -> L_CORCHETE . values R_CORCHETE
    (24) values -> . values COMA a
    (25) values -> . a
    (66) a -> . a OR b
    (67) a -> . b
    (68) b -> . b AND c
    (69) b -> . c
    (70) c -> . NOT d
    (71) c -> . d
    (72) d -> . d DISTINTO_QUE e
    (73) d -> . d MENOR_QUE e
    (74) d -> . d MENOR_IGUAL_QUE e
    (75) d -> . d MAYOR_QUE e
    (76) d -> . d MAYOR_IGUAL_QUE e
    (77) d -> . d TRIPLE_IGUAL e
    (78) d -> . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 60
    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    values                         shift and go to state 121
    a                              shift and go to state 89
    b                              shift and go to state 58
    c                              shift and go to state 59
    d                              shift and go to state 61
    e                              shift and go to state 62
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 80

    (108) interface_assi -> L_LLAVE . atributos_assi R_LLAVE
    (109) atributos_assi -> . atributos_assi COMA LITERAL COLON a
    (110) atributos_assi -> . LITERAL COLON a

    LITERAL         shift and go to state 123

    atributos_assi                 shift and go to state 122

state 81

    (20) function_pro -> FUNCTION LITERAL . L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (21) function_pro -> FUNCTION LITERAL . L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE

    L_PAREN         shift and go to state 124


state 82

    (63) console_pro -> CONSOLE PUNTO LOG . L_PAREN expresion R_PAREN

    L_PAREN         shift and go to state 125


state 83

    (40) declaracion_list -> declaracion_list COMA . assignacion_instruction
    (42) assignacion_instruction -> . LITERAL COLON type IGUAL a
    (43) assignacion_instruction -> . LITERAL COLON type
    (44) assignacion_instruction -> . LITERAL IGUAL a

    LITERAL         shift and go to state 48

    assignacion_instruction        shift and go to state 126

state 84

    (42) assignacion_instruction -> LITERAL COLON . type IGUAL a
    (43) assignacion_instruction -> LITERAL COLON . type
    (45) type -> . NUMBER
    (46) type -> . STRING
    (47) type -> . BOOLEAN
    (48) type -> . ANY
    (49) type -> . LITERAL

    NUMBER          shift and go to state 129
    STRING          shift and go to state 130
    BOOLEAN         shift and go to state 131
    ANY             shift and go to state 132
    LITERAL         shift and go to state 127

    type                           shift and go to state 128

state 85

    (44) assignacion_instruction -> LITERAL IGUAL . a
    (66) a -> . a OR b
    (67) a -> . b
    (68) b -> . b AND c
    (69) b -> . c
    (70) c -> . NOT d
    (71) c -> . d
    (72) d -> . d DISTINTO_QUE e
    (73) d -> . d MENOR_QUE e
    (74) d -> . d MENOR_IGUAL_QUE e
    (75) d -> . d MAYOR_QUE e
    (76) d -> . d MAYOR_IGUAL_QUE e
    (77) d -> . d TRIPLE_IGUAL e
    (78) d -> . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 60
    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    a                              shift and go to state 133
    b                              shift and go to state 58
    c                              shift and go to state 59
    d                              shift and go to state 61
    e                              shift and go to state 62
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 86

    (50) assig_pro -> LITERAL IGUAL a .
    (66) a -> a . OR b

    SEMI_COLON      reduce using rule 50 (assig_pro -> LITERAL IGUAL a .)
    CONSOLE         reduce using rule 50 (assig_pro -> LITERAL IGUAL a .)
    LET             reduce using rule 50 (assig_pro -> LITERAL IGUAL a .)
    LITERAL         reduce using rule 50 (assig_pro -> LITERAL IGUAL a .)
    IF              reduce using rule 50 (assig_pro -> LITERAL IGUAL a .)
    WHILE           reduce using rule 50 (assig_pro -> LITERAL IGUAL a .)
    FOR             reduce using rule 50 (assig_pro -> LITERAL IGUAL a .)
    INTERFACE       reduce using rule 50 (assig_pro -> LITERAL IGUAL a .)
    CONTINUE        reduce using rule 50 (assig_pro -> LITERAL IGUAL a .)
    BREAK           reduce using rule 50 (assig_pro -> LITERAL IGUAL a .)
    RETURN          reduce using rule 50 (assig_pro -> LITERAL IGUAL a .)
    FUNCTION        reduce using rule 50 (assig_pro -> LITERAL IGUAL a .)
    $end            reduce using rule 50 (assig_pro -> LITERAL IGUAL a .)
    R_LLAVE         reduce using rule 50 (assig_pro -> LITERAL IGUAL a .)
    R_PAREN         reduce using rule 50 (assig_pro -> LITERAL IGUAL a .)
    OR              shift and go to state 100


state 87

    (22) call_function_pro -> LITERAL L_PAREN values . R_PAREN
    (24) values -> values . COMA a

    R_PAREN         shift and go to state 134
    COMA            shift and go to state 135


state 88

    (23) call_function_pro -> LITERAL L_PAREN R_PAREN .

    SEMI_COLON      reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    CONSOLE         reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    LET             reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    LITERAL         reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    IF              reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    WHILE           reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    FOR             reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    INTERFACE       reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    CONTINUE        reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    BREAK           reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    RETURN          reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    FUNCTION        reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    $end            reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    PUNTO           reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    TIMES           reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    DIVIDE          reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    MOD             reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    POTENCIA        reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    MAS             reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    MENOS           reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    DISTINTO_QUE    reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    MENOR_QUE       reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    MENOR_IGUAL_QUE reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    MAYOR_QUE       reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    MAYOR_IGUAL_QUE reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    TRIPLE_IGUAL    reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    AND             reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    OR              reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    R_LLAVE         reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    R_PAREN         reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    COMA            reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    R_CORCHETE      reduce using rule 23 (call_function_pro -> LITERAL L_PAREN R_PAREN .)


state 89

    (25) values -> a .
    (66) a -> a . OR b

    R_PAREN         reduce using rule 25 (values -> a .)
    COMA            reduce using rule 25 (values -> a .)
    R_CORCHETE      reduce using rule 25 (values -> a .)
    OR              shift and go to state 100


state 90

    (106) sumadores -> LITERAL MAS MAS .

    SEMI_COLON      reduce using rule 106 (sumadores -> LITERAL MAS MAS .)
    CONSOLE         reduce using rule 106 (sumadores -> LITERAL MAS MAS .)
    LET             reduce using rule 106 (sumadores -> LITERAL MAS MAS .)
    LITERAL         reduce using rule 106 (sumadores -> LITERAL MAS MAS .)
    IF              reduce using rule 106 (sumadores -> LITERAL MAS MAS .)
    WHILE           reduce using rule 106 (sumadores -> LITERAL MAS MAS .)
    FOR             reduce using rule 106 (sumadores -> LITERAL MAS MAS .)
    INTERFACE       reduce using rule 106 (sumadores -> LITERAL MAS MAS .)
    CONTINUE        reduce using rule 106 (sumadores -> LITERAL MAS MAS .)
    BREAK           reduce using rule 106 (sumadores -> LITERAL MAS MAS .)
    RETURN          reduce using rule 106 (sumadores -> LITERAL MAS MAS .)
    FUNCTION        reduce using rule 106 (sumadores -> LITERAL MAS MAS .)
    $end            reduce using rule 106 (sumadores -> LITERAL MAS MAS .)
    R_LLAVE         reduce using rule 106 (sumadores -> LITERAL MAS MAS .)
    R_PAREN         reduce using rule 106 (sumadores -> LITERAL MAS MAS .)


state 91

    (107) sumadores -> LITERAL MENOS MENOS .

    SEMI_COLON      reduce using rule 107 (sumadores -> LITERAL MENOS MENOS .)
    CONSOLE         reduce using rule 107 (sumadores -> LITERAL MENOS MENOS .)
    LET             reduce using rule 107 (sumadores -> LITERAL MENOS MENOS .)
    LITERAL         reduce using rule 107 (sumadores -> LITERAL MENOS MENOS .)
    IF              reduce using rule 107 (sumadores -> LITERAL MENOS MENOS .)
    WHILE           reduce using rule 107 (sumadores -> LITERAL MENOS MENOS .)
    FOR             reduce using rule 107 (sumadores -> LITERAL MENOS MENOS .)
    INTERFACE       reduce using rule 107 (sumadores -> LITERAL MENOS MENOS .)
    CONTINUE        reduce using rule 107 (sumadores -> LITERAL MENOS MENOS .)
    BREAK           reduce using rule 107 (sumadores -> LITERAL MENOS MENOS .)
    RETURN          reduce using rule 107 (sumadores -> LITERAL MENOS MENOS .)
    FUNCTION        reduce using rule 107 (sumadores -> LITERAL MENOS MENOS .)
    $end            reduce using rule 107 (sumadores -> LITERAL MENOS MENOS .)
    R_LLAVE         reduce using rule 107 (sumadores -> LITERAL MENOS MENOS .)
    R_PAREN         reduce using rule 107 (sumadores -> LITERAL MENOS MENOS .)


state 92

    (51) if_pro -> IF L_PAREN a . R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) a -> a . OR b

    R_PAREN         shift and go to state 136
    OR              shift and go to state 100


state 93

    (55) while_pro -> WHILE L_PAREN a . R_PAREN L_LLAVE instrucciones R_LLAVE
    (66) a -> a . OR b

    R_PAREN         shift and go to state 137
    OR              shift and go to state 100


state 94

    (56) for_pro -> FOR L_PAREN declaration_instruction . SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE

    SEMI_COLON      shift and go to state 138


state 95

    (57) for_pro -> FOR L_PAREN assig_pro . SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE

    SEMI_COLON      shift and go to state 139


state 96

    (60) for_each_pro -> FOR L_PAREN for_each_dec . R_PAREN L_LLAVE instrucciones R_LLAVE

    R_PAREN         shift and go to state 140


state 97

    (39) declaration_instruction -> LET . declaracion_list
    (61) for_each_dec -> LET . LITERAL OF a
    (62) for_each_dec -> LET . LITERAL COLON type OF a
    (40) declaracion_list -> . declaracion_list COMA assignacion_instruction
    (41) declaracion_list -> . assignacion_instruction
    (42) assignacion_instruction -> . LITERAL COLON type IGUAL a
    (43) assignacion_instruction -> . LITERAL COLON type
    (44) assignacion_instruction -> . LITERAL IGUAL a

    LITERAL         shift and go to state 141

    declaracion_list               shift and go to state 46
    assignacion_instruction        shift and go to state 47

state 98

    (50) assig_pro -> LITERAL . IGUAL a

    IGUAL           shift and go to state 49


state 99

    (34) interface_pro -> INTERFACE LITERAL L_LLAVE . interface_atributos R_LLAVE
    (35) interface_atributos -> . interface_atributos interface_atributo sc
    (36) interface_atributos -> .

    R_LLAVE         reduce using rule 36 (interface_atributos -> .)
    LITERAL         reduce using rule 36 (interface_atributos -> .)

    interface_atributos            shift and go to state 142

state 100

    (66) a -> a OR . b
    (68) b -> . b AND c
    (69) b -> . c
    (70) c -> . NOT d
    (71) c -> . d
    (72) d -> . d DISTINTO_QUE e
    (73) d -> . d MENOR_QUE e
    (74) d -> . d MENOR_IGUAL_QUE e
    (75) d -> . d MAYOR_QUE e
    (76) d -> . d MAYOR_IGUAL_QUE e
    (77) d -> . d TRIPLE_IGUAL e
    (78) d -> . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 60
    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    b                              shift and go to state 143
    c                              shift and go to state 59
    d                              shift and go to state 61
    e                              shift and go to state 62
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 101

    (68) b -> b AND . c
    (70) c -> . NOT d
    (71) c -> . d
    (72) d -> . d DISTINTO_QUE e
    (73) d -> . d MENOR_QUE e
    (74) d -> . d MENOR_IGUAL_QUE e
    (75) d -> . d MAYOR_QUE e
    (76) d -> . d MAYOR_IGUAL_QUE e
    (77) d -> . d TRIPLE_IGUAL e
    (78) d -> . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 60
    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    c                              shift and go to state 144
    d                              shift and go to state 61
    e                              shift and go to state 62
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 102

    (70) c -> NOT d .
    (72) d -> d . DISTINTO_QUE e
    (73) d -> d . MENOR_QUE e
    (74) d -> d . MENOR_IGUAL_QUE e
    (75) d -> d . MAYOR_QUE e
    (76) d -> d . MAYOR_IGUAL_QUE e
    (77) d -> d . TRIPLE_IGUAL e

    AND             reduce using rule 70 (c -> NOT d .)
    OR              reduce using rule 70 (c -> NOT d .)
    SEMI_COLON      reduce using rule 70 (c -> NOT d .)
    CONSOLE         reduce using rule 70 (c -> NOT d .)
    LET             reduce using rule 70 (c -> NOT d .)
    LITERAL         reduce using rule 70 (c -> NOT d .)
    IF              reduce using rule 70 (c -> NOT d .)
    WHILE           reduce using rule 70 (c -> NOT d .)
    FOR             reduce using rule 70 (c -> NOT d .)
    INTERFACE       reduce using rule 70 (c -> NOT d .)
    CONTINUE        reduce using rule 70 (c -> NOT d .)
    BREAK           reduce using rule 70 (c -> NOT d .)
    RETURN          reduce using rule 70 (c -> NOT d .)
    FUNCTION        reduce using rule 70 (c -> NOT d .)
    $end            reduce using rule 70 (c -> NOT d .)
    R_LLAVE         reduce using rule 70 (c -> NOT d .)
    R_PAREN         reduce using rule 70 (c -> NOT d .)
    COMA            reduce using rule 70 (c -> NOT d .)
    R_CORCHETE      reduce using rule 70 (c -> NOT d .)
    DISTINTO_QUE    shift and go to state 103
    MENOR_QUE       shift and go to state 104
    MENOR_IGUAL_QUE shift and go to state 105
    MAYOR_QUE       shift and go to state 106
    MAYOR_IGUAL_QUE shift and go to state 107
    TRIPLE_IGUAL    shift and go to state 108


state 103

    (72) d -> d DISTINTO_QUE . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    e                              shift and go to state 145
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 104

    (73) d -> d MENOR_QUE . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    e                              shift and go to state 146
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 105

    (74) d -> d MENOR_IGUAL_QUE . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    e                              shift and go to state 147
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 106

    (75) d -> d MAYOR_QUE . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    e                              shift and go to state 148
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 107

    (76) d -> d MAYOR_IGUAL_QUE . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    e                              shift and go to state 149
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 108

    (77) d -> d TRIPLE_IGUAL . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    e                              shift and go to state 150
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 109

    (79) e -> e MAS . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    f                              shift and go to state 151
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 110

    (80) e -> e MENOS . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    f                              shift and go to state 152
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 111

    (83) f -> MAS g .
    (85) g -> g . TIMES h
    (86) g -> g . DIVIDE h
    (87) g -> g . MOD h
    (88) g -> g . POTENCIA h

    MAS             reduce using rule 83 (f -> MAS g .)
    MENOS           reduce using rule 83 (f -> MAS g .)
    DISTINTO_QUE    reduce using rule 83 (f -> MAS g .)
    MENOR_QUE       reduce using rule 83 (f -> MAS g .)
    MENOR_IGUAL_QUE reduce using rule 83 (f -> MAS g .)
    MAYOR_QUE       reduce using rule 83 (f -> MAS g .)
    MAYOR_IGUAL_QUE reduce using rule 83 (f -> MAS g .)
    TRIPLE_IGUAL    reduce using rule 83 (f -> MAS g .)
    AND             reduce using rule 83 (f -> MAS g .)
    OR              reduce using rule 83 (f -> MAS g .)
    SEMI_COLON      reduce using rule 83 (f -> MAS g .)
    CONSOLE         reduce using rule 83 (f -> MAS g .)
    LET             reduce using rule 83 (f -> MAS g .)
    LITERAL         reduce using rule 83 (f -> MAS g .)
    IF              reduce using rule 83 (f -> MAS g .)
    WHILE           reduce using rule 83 (f -> MAS g .)
    FOR             reduce using rule 83 (f -> MAS g .)
    INTERFACE       reduce using rule 83 (f -> MAS g .)
    CONTINUE        reduce using rule 83 (f -> MAS g .)
    BREAK           reduce using rule 83 (f -> MAS g .)
    RETURN          reduce using rule 83 (f -> MAS g .)
    FUNCTION        reduce using rule 83 (f -> MAS g .)
    $end            reduce using rule 83 (f -> MAS g .)
    R_LLAVE         reduce using rule 83 (f -> MAS g .)
    R_PAREN         reduce using rule 83 (f -> MAS g .)
    COMA            reduce using rule 83 (f -> MAS g .)
    R_CORCHETE      reduce using rule 83 (f -> MAS g .)
    TIMES           shift and go to state 113
    DIVIDE          shift and go to state 114
    MOD             shift and go to state 115
    POTENCIA        shift and go to state 116


state 112

    (82) f -> MENOS g .
    (85) g -> g . TIMES h
    (86) g -> g . DIVIDE h
    (87) g -> g . MOD h
    (88) g -> g . POTENCIA h

    MAS             reduce using rule 82 (f -> MENOS g .)
    MENOS           reduce using rule 82 (f -> MENOS g .)
    DISTINTO_QUE    reduce using rule 82 (f -> MENOS g .)
    MENOR_QUE       reduce using rule 82 (f -> MENOS g .)
    MENOR_IGUAL_QUE reduce using rule 82 (f -> MENOS g .)
    MAYOR_QUE       reduce using rule 82 (f -> MENOS g .)
    MAYOR_IGUAL_QUE reduce using rule 82 (f -> MENOS g .)
    TRIPLE_IGUAL    reduce using rule 82 (f -> MENOS g .)
    AND             reduce using rule 82 (f -> MENOS g .)
    OR              reduce using rule 82 (f -> MENOS g .)
    SEMI_COLON      reduce using rule 82 (f -> MENOS g .)
    CONSOLE         reduce using rule 82 (f -> MENOS g .)
    LET             reduce using rule 82 (f -> MENOS g .)
    LITERAL         reduce using rule 82 (f -> MENOS g .)
    IF              reduce using rule 82 (f -> MENOS g .)
    WHILE           reduce using rule 82 (f -> MENOS g .)
    FOR             reduce using rule 82 (f -> MENOS g .)
    INTERFACE       reduce using rule 82 (f -> MENOS g .)
    CONTINUE        reduce using rule 82 (f -> MENOS g .)
    BREAK           reduce using rule 82 (f -> MENOS g .)
    RETURN          reduce using rule 82 (f -> MENOS g .)
    FUNCTION        reduce using rule 82 (f -> MENOS g .)
    $end            reduce using rule 82 (f -> MENOS g .)
    R_LLAVE         reduce using rule 82 (f -> MENOS g .)
    R_PAREN         reduce using rule 82 (f -> MENOS g .)
    COMA            reduce using rule 82 (f -> MENOS g .)
    R_CORCHETE      reduce using rule 82 (f -> MENOS g .)
    TIMES           shift and go to state 113
    DIVIDE          shift and go to state 114
    MOD             shift and go to state 115
    POTENCIA        shift and go to state 116


state 113

    (85) g -> g TIMES . h
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    h                              shift and go to state 153
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 114

    (86) g -> g DIVIDE . h
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    h                              shift and go to state 154
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 115

    (87) g -> g MOD . h
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    h                              shift and go to state 155
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 116

    (88) g -> g POTENCIA . h
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    h                              shift and go to state 156
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 117

    (90) g -> h PUNTO . nativeFun L_PAREN expresion R_PAREN
    (91) g -> h PUNTO . nativeFun L_PAREN R_PAREN
    (112) nativeFun -> . TOSTRING
    (113) nativeFun -> . TOFIXED
    (114) nativeFun -> . TOEXPONENTIAL
    (115) nativeFun -> . TOLOWERCASE
    (116) nativeFun -> . TOUPPERCASE
    (117) nativeFun -> . SPLIT
    (118) nativeFun -> . CONCAT

    TOSTRING        shift and go to state 158
    TOFIXED         shift and go to state 159
    TOEXPONENTIAL   shift and go to state 160
    TOLOWERCASE     shift and go to state 161
    TOUPPERCASE     shift and go to state 162
    SPLIT           shift and go to state 163
    CONCAT          shift and go to state 164

    nativeFun                      shift and go to state 157

state 118

    (101) h -> L_PAREN a . R_PAREN
    (66) a -> a . OR b

    R_PAREN         shift and go to state 165
    OR              shift and go to state 100


state 119

    (103) array_val_pro -> LITERAL dimensions .
    (104) dimensions -> dimensions . L_CORCHETE a R_CORCHETE

    PUNTO           reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    TIMES           reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    DIVIDE          reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    MOD             reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    POTENCIA        reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    MAS             reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    MENOS           reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    DISTINTO_QUE    reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    MENOR_QUE       reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    MENOR_IGUAL_QUE reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    MAYOR_QUE       reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    MAYOR_IGUAL_QUE reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    TRIPLE_IGUAL    reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    AND             reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    OR              reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    SEMI_COLON      reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    CONSOLE         reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    LET             reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    LITERAL         reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    IF              reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    WHILE           reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    FOR             reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    INTERFACE       reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    CONTINUE        reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    BREAK           reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    RETURN          reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    FUNCTION        reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    $end            reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    R_LLAVE         reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    R_PAREN         reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    COMA            reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    R_CORCHETE      reduce using rule 103 (array_val_pro -> LITERAL dimensions .)
    L_CORCHETE      shift and go to state 166


state 120

    (105) dimensions -> L_CORCHETE . a R_CORCHETE
    (66) a -> . a OR b
    (67) a -> . b
    (68) b -> . b AND c
    (69) b -> . c
    (70) c -> . NOT d
    (71) c -> . d
    (72) d -> . d DISTINTO_QUE e
    (73) d -> . d MENOR_QUE e
    (74) d -> . d MENOR_IGUAL_QUE e
    (75) d -> . d MAYOR_QUE e
    (76) d -> . d MAYOR_IGUAL_QUE e
    (77) d -> . d TRIPLE_IGUAL e
    (78) d -> . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 60
    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    a                              shift and go to state 167
    b                              shift and go to state 58
    c                              shift and go to state 59
    d                              shift and go to state 61
    e                              shift and go to state 62
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 121

    (111) array_pro -> L_CORCHETE values . R_CORCHETE
    (24) values -> values . COMA a

    R_CORCHETE      shift and go to state 168
    COMA            shift and go to state 135


state 122

    (108) interface_assi -> L_LLAVE atributos_assi . R_LLAVE
    (109) atributos_assi -> atributos_assi . COMA LITERAL COLON a

    R_LLAVE         shift and go to state 169
    COMA            shift and go to state 170


state 123

    (110) atributos_assi -> LITERAL . COLON a

    COLON           shift and go to state 171


state 124

    (20) function_pro -> FUNCTION LITERAL L_PAREN . parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (21) function_pro -> FUNCTION LITERAL L_PAREN . R_PAREN L_LLAVE instrucciones R_LLAVE
    (26) parameters_pro -> . parameters_pro COMA parameter_pro
    (27) parameters_pro -> . parameter_pro
    (28) parameter_pro -> . LITERAL COLON type
    (29) parameter_pro -> . LITERAL

    R_PAREN         shift and go to state 174
    LITERAL         shift and go to state 172

    parameters_pro                 shift and go to state 173
    parameter_pro                  shift and go to state 175

state 125

    (63) console_pro -> CONSOLE PUNTO LOG L_PAREN . expresion R_PAREN
    (64) expresion -> . expresion COMA a
    (65) expresion -> . a
    (66) a -> . a OR b
    (67) a -> . b
    (68) b -> . b AND c
    (69) b -> . c
    (70) c -> . NOT d
    (71) c -> . d
    (72) d -> . d DISTINTO_QUE e
    (73) d -> . d MENOR_QUE e
    (74) d -> . d MENOR_IGUAL_QUE e
    (75) d -> . d MAYOR_QUE e
    (76) d -> . d MAYOR_IGUAL_QUE e
    (77) d -> . d TRIPLE_IGUAL e
    (78) d -> . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 60
    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    expresion                      shift and go to state 176
    a                              shift and go to state 177
    b                              shift and go to state 58
    c                              shift and go to state 59
    d                              shift and go to state 61
    e                              shift and go to state 62
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 126

    (40) declaracion_list -> declaracion_list COMA assignacion_instruction .

    COMA            reduce using rule 40 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    SEMI_COLON      reduce using rule 40 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    CONSOLE         reduce using rule 40 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    LET             reduce using rule 40 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    LITERAL         reduce using rule 40 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    IF              reduce using rule 40 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    WHILE           reduce using rule 40 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    FOR             reduce using rule 40 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    INTERFACE       reduce using rule 40 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    CONTINUE        reduce using rule 40 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    BREAK           reduce using rule 40 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    RETURN          reduce using rule 40 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    FUNCTION        reduce using rule 40 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    $end            reduce using rule 40 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    R_LLAVE         reduce using rule 40 (declaracion_list -> declaracion_list COMA assignacion_instruction .)


state 127

    (49) type -> LITERAL .

    IGUAL           reduce using rule 49 (type -> LITERAL .)
    COMA            reduce using rule 49 (type -> LITERAL .)
    SEMI_COLON      reduce using rule 49 (type -> LITERAL .)
    CONSOLE         reduce using rule 49 (type -> LITERAL .)
    LET             reduce using rule 49 (type -> LITERAL .)
    LITERAL         reduce using rule 49 (type -> LITERAL .)
    IF              reduce using rule 49 (type -> LITERAL .)
    WHILE           reduce using rule 49 (type -> LITERAL .)
    FOR             reduce using rule 49 (type -> LITERAL .)
    INTERFACE       reduce using rule 49 (type -> LITERAL .)
    CONTINUE        reduce using rule 49 (type -> LITERAL .)
    BREAK           reduce using rule 49 (type -> LITERAL .)
    RETURN          reduce using rule 49 (type -> LITERAL .)
    FUNCTION        reduce using rule 49 (type -> LITERAL .)
    $end            reduce using rule 49 (type -> LITERAL .)
    R_LLAVE         reduce using rule 49 (type -> LITERAL .)
    OF              reduce using rule 49 (type -> LITERAL .)
    R_PAREN         reduce using rule 49 (type -> LITERAL .)


state 128

    (42) assignacion_instruction -> LITERAL COLON type . IGUAL a
    (43) assignacion_instruction -> LITERAL COLON type .

    IGUAL           shift and go to state 178
    COMA            reduce using rule 43 (assignacion_instruction -> LITERAL COLON type .)
    SEMI_COLON      reduce using rule 43 (assignacion_instruction -> LITERAL COLON type .)
    CONSOLE         reduce using rule 43 (assignacion_instruction -> LITERAL COLON type .)
    LET             reduce using rule 43 (assignacion_instruction -> LITERAL COLON type .)
    LITERAL         reduce using rule 43 (assignacion_instruction -> LITERAL COLON type .)
    IF              reduce using rule 43 (assignacion_instruction -> LITERAL COLON type .)
    WHILE           reduce using rule 43 (assignacion_instruction -> LITERAL COLON type .)
    FOR             reduce using rule 43 (assignacion_instruction -> LITERAL COLON type .)
    INTERFACE       reduce using rule 43 (assignacion_instruction -> LITERAL COLON type .)
    CONTINUE        reduce using rule 43 (assignacion_instruction -> LITERAL COLON type .)
    BREAK           reduce using rule 43 (assignacion_instruction -> LITERAL COLON type .)
    RETURN          reduce using rule 43 (assignacion_instruction -> LITERAL COLON type .)
    FUNCTION        reduce using rule 43 (assignacion_instruction -> LITERAL COLON type .)
    $end            reduce using rule 43 (assignacion_instruction -> LITERAL COLON type .)
    R_LLAVE         reduce using rule 43 (assignacion_instruction -> LITERAL COLON type .)


state 129

    (45) type -> NUMBER .

    IGUAL           reduce using rule 45 (type -> NUMBER .)
    COMA            reduce using rule 45 (type -> NUMBER .)
    SEMI_COLON      reduce using rule 45 (type -> NUMBER .)
    CONSOLE         reduce using rule 45 (type -> NUMBER .)
    LET             reduce using rule 45 (type -> NUMBER .)
    LITERAL         reduce using rule 45 (type -> NUMBER .)
    IF              reduce using rule 45 (type -> NUMBER .)
    WHILE           reduce using rule 45 (type -> NUMBER .)
    FOR             reduce using rule 45 (type -> NUMBER .)
    INTERFACE       reduce using rule 45 (type -> NUMBER .)
    CONTINUE        reduce using rule 45 (type -> NUMBER .)
    BREAK           reduce using rule 45 (type -> NUMBER .)
    RETURN          reduce using rule 45 (type -> NUMBER .)
    FUNCTION        reduce using rule 45 (type -> NUMBER .)
    $end            reduce using rule 45 (type -> NUMBER .)
    R_LLAVE         reduce using rule 45 (type -> NUMBER .)
    OF              reduce using rule 45 (type -> NUMBER .)
    R_PAREN         reduce using rule 45 (type -> NUMBER .)


state 130

    (46) type -> STRING .

    IGUAL           reduce using rule 46 (type -> STRING .)
    COMA            reduce using rule 46 (type -> STRING .)
    SEMI_COLON      reduce using rule 46 (type -> STRING .)
    CONSOLE         reduce using rule 46 (type -> STRING .)
    LET             reduce using rule 46 (type -> STRING .)
    LITERAL         reduce using rule 46 (type -> STRING .)
    IF              reduce using rule 46 (type -> STRING .)
    WHILE           reduce using rule 46 (type -> STRING .)
    FOR             reduce using rule 46 (type -> STRING .)
    INTERFACE       reduce using rule 46 (type -> STRING .)
    CONTINUE        reduce using rule 46 (type -> STRING .)
    BREAK           reduce using rule 46 (type -> STRING .)
    RETURN          reduce using rule 46 (type -> STRING .)
    FUNCTION        reduce using rule 46 (type -> STRING .)
    $end            reduce using rule 46 (type -> STRING .)
    R_LLAVE         reduce using rule 46 (type -> STRING .)
    OF              reduce using rule 46 (type -> STRING .)
    R_PAREN         reduce using rule 46 (type -> STRING .)


state 131

    (47) type -> BOOLEAN .

    IGUAL           reduce using rule 47 (type -> BOOLEAN .)
    COMA            reduce using rule 47 (type -> BOOLEAN .)
    SEMI_COLON      reduce using rule 47 (type -> BOOLEAN .)
    CONSOLE         reduce using rule 47 (type -> BOOLEAN .)
    LET             reduce using rule 47 (type -> BOOLEAN .)
    LITERAL         reduce using rule 47 (type -> BOOLEAN .)
    IF              reduce using rule 47 (type -> BOOLEAN .)
    WHILE           reduce using rule 47 (type -> BOOLEAN .)
    FOR             reduce using rule 47 (type -> BOOLEAN .)
    INTERFACE       reduce using rule 47 (type -> BOOLEAN .)
    CONTINUE        reduce using rule 47 (type -> BOOLEAN .)
    BREAK           reduce using rule 47 (type -> BOOLEAN .)
    RETURN          reduce using rule 47 (type -> BOOLEAN .)
    FUNCTION        reduce using rule 47 (type -> BOOLEAN .)
    $end            reduce using rule 47 (type -> BOOLEAN .)
    R_LLAVE         reduce using rule 47 (type -> BOOLEAN .)
    OF              reduce using rule 47 (type -> BOOLEAN .)
    R_PAREN         reduce using rule 47 (type -> BOOLEAN .)


state 132

    (48) type -> ANY .

    IGUAL           reduce using rule 48 (type -> ANY .)
    COMA            reduce using rule 48 (type -> ANY .)
    SEMI_COLON      reduce using rule 48 (type -> ANY .)
    CONSOLE         reduce using rule 48 (type -> ANY .)
    LET             reduce using rule 48 (type -> ANY .)
    LITERAL         reduce using rule 48 (type -> ANY .)
    IF              reduce using rule 48 (type -> ANY .)
    WHILE           reduce using rule 48 (type -> ANY .)
    FOR             reduce using rule 48 (type -> ANY .)
    INTERFACE       reduce using rule 48 (type -> ANY .)
    CONTINUE        reduce using rule 48 (type -> ANY .)
    BREAK           reduce using rule 48 (type -> ANY .)
    RETURN          reduce using rule 48 (type -> ANY .)
    FUNCTION        reduce using rule 48 (type -> ANY .)
    $end            reduce using rule 48 (type -> ANY .)
    R_LLAVE         reduce using rule 48 (type -> ANY .)
    OF              reduce using rule 48 (type -> ANY .)
    R_PAREN         reduce using rule 48 (type -> ANY .)


state 133

    (44) assignacion_instruction -> LITERAL IGUAL a .
    (66) a -> a . OR b

    COMA            reduce using rule 44 (assignacion_instruction -> LITERAL IGUAL a .)
    SEMI_COLON      reduce using rule 44 (assignacion_instruction -> LITERAL IGUAL a .)
    CONSOLE         reduce using rule 44 (assignacion_instruction -> LITERAL IGUAL a .)
    LET             reduce using rule 44 (assignacion_instruction -> LITERAL IGUAL a .)
    LITERAL         reduce using rule 44 (assignacion_instruction -> LITERAL IGUAL a .)
    IF              reduce using rule 44 (assignacion_instruction -> LITERAL IGUAL a .)
    WHILE           reduce using rule 44 (assignacion_instruction -> LITERAL IGUAL a .)
    FOR             reduce using rule 44 (assignacion_instruction -> LITERAL IGUAL a .)
    INTERFACE       reduce using rule 44 (assignacion_instruction -> LITERAL IGUAL a .)
    CONTINUE        reduce using rule 44 (assignacion_instruction -> LITERAL IGUAL a .)
    BREAK           reduce using rule 44 (assignacion_instruction -> LITERAL IGUAL a .)
    RETURN          reduce using rule 44 (assignacion_instruction -> LITERAL IGUAL a .)
    FUNCTION        reduce using rule 44 (assignacion_instruction -> LITERAL IGUAL a .)
    $end            reduce using rule 44 (assignacion_instruction -> LITERAL IGUAL a .)
    R_LLAVE         reduce using rule 44 (assignacion_instruction -> LITERAL IGUAL a .)
    OR              shift and go to state 100


state 134

    (22) call_function_pro -> LITERAL L_PAREN values R_PAREN .

    SEMI_COLON      reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    CONSOLE         reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    LET             reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    LITERAL         reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    IF              reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    WHILE           reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    FOR             reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    INTERFACE       reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    CONTINUE        reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    BREAK           reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    RETURN          reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    FUNCTION        reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    $end            reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    PUNTO           reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    TIMES           reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    DIVIDE          reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    MOD             reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    POTENCIA        reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    MAS             reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    MENOS           reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    DISTINTO_QUE    reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    MENOR_QUE       reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    MENOR_IGUAL_QUE reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    MAYOR_QUE       reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    MAYOR_IGUAL_QUE reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    TRIPLE_IGUAL    reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    AND             reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    OR              reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    R_LLAVE         reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    R_PAREN         reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    COMA            reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    R_CORCHETE      reduce using rule 22 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)


state 135

    (24) values -> values COMA . a
    (66) a -> . a OR b
    (67) a -> . b
    (68) b -> . b AND c
    (69) b -> . c
    (70) c -> . NOT d
    (71) c -> . d
    (72) d -> . d DISTINTO_QUE e
    (73) d -> . d MENOR_QUE e
    (74) d -> . d MENOR_IGUAL_QUE e
    (75) d -> . d MAYOR_QUE e
    (76) d -> . d MAYOR_IGUAL_QUE e
    (77) d -> . d TRIPLE_IGUAL e
    (78) d -> . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 60
    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    a                              shift and go to state 179
    b                              shift and go to state 58
    c                              shift and go to state 59
    d                              shift and go to state 61
    e                              shift and go to state 62
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 136

    (51) if_pro -> IF L_PAREN a R_PAREN . L_LLAVE instrucciones R_LLAVE else_pro

    L_LLAVE         shift and go to state 180


state 137

    (55) while_pro -> WHILE L_PAREN a R_PAREN . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 181


state 138

    (56) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON . a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (66) a -> . a OR b
    (67) a -> . b
    (68) b -> . b AND c
    (69) b -> . c
    (70) c -> . NOT d
    (71) c -> . d
    (72) d -> . d DISTINTO_QUE e
    (73) d -> . d MENOR_QUE e
    (74) d -> . d MENOR_IGUAL_QUE e
    (75) d -> . d MAYOR_QUE e
    (76) d -> . d MAYOR_IGUAL_QUE e
    (77) d -> . d TRIPLE_IGUAL e
    (78) d -> . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 60
    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    a                              shift and go to state 182
    b                              shift and go to state 58
    c                              shift and go to state 59
    d                              shift and go to state 61
    e                              shift and go to state 62
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 139

    (57) for_pro -> FOR L_PAREN assig_pro SEMI_COLON . a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (66) a -> . a OR b
    (67) a -> . b
    (68) b -> . b AND c
    (69) b -> . c
    (70) c -> . NOT d
    (71) c -> . d
    (72) d -> . d DISTINTO_QUE e
    (73) d -> . d MENOR_QUE e
    (74) d -> . d MENOR_IGUAL_QUE e
    (75) d -> . d MAYOR_QUE e
    (76) d -> . d MAYOR_IGUAL_QUE e
    (77) d -> . d TRIPLE_IGUAL e
    (78) d -> . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 60
    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    a                              shift and go to state 183
    b                              shift and go to state 58
    c                              shift and go to state 59
    d                              shift and go to state 61
    e                              shift and go to state 62
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 140

    (60) for_each_pro -> FOR L_PAREN for_each_dec R_PAREN . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 184


state 141

    (61) for_each_dec -> LET LITERAL . OF a
    (62) for_each_dec -> LET LITERAL . COLON type OF a
    (42) assignacion_instruction -> LITERAL . COLON type IGUAL a
    (43) assignacion_instruction -> LITERAL . COLON type
    (44) assignacion_instruction -> LITERAL . IGUAL a

    OF              shift and go to state 185
    COLON           shift and go to state 186
    IGUAL           shift and go to state 85


state 142

    (34) interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos . R_LLAVE
    (35) interface_atributos -> interface_atributos . interface_atributo sc
    (37) interface_atributo -> . LITERAL COLON type
    (38) interface_atributo -> . LITERAL

    R_LLAVE         shift and go to state 188
    LITERAL         shift and go to state 187

    interface_atributo             shift and go to state 189

state 143

    (66) a -> a OR b .
    (68) b -> b . AND c

    OR              reduce using rule 66 (a -> a OR b .)
    SEMI_COLON      reduce using rule 66 (a -> a OR b .)
    CONSOLE         reduce using rule 66 (a -> a OR b .)
    LET             reduce using rule 66 (a -> a OR b .)
    LITERAL         reduce using rule 66 (a -> a OR b .)
    IF              reduce using rule 66 (a -> a OR b .)
    WHILE           reduce using rule 66 (a -> a OR b .)
    FOR             reduce using rule 66 (a -> a OR b .)
    INTERFACE       reduce using rule 66 (a -> a OR b .)
    CONTINUE        reduce using rule 66 (a -> a OR b .)
    BREAK           reduce using rule 66 (a -> a OR b .)
    RETURN          reduce using rule 66 (a -> a OR b .)
    FUNCTION        reduce using rule 66 (a -> a OR b .)
    $end            reduce using rule 66 (a -> a OR b .)
    R_LLAVE         reduce using rule 66 (a -> a OR b .)
    R_PAREN         reduce using rule 66 (a -> a OR b .)
    COMA            reduce using rule 66 (a -> a OR b .)
    R_CORCHETE      reduce using rule 66 (a -> a OR b .)
    AND             shift and go to state 101


state 144

    (68) b -> b AND c .

    AND             reduce using rule 68 (b -> b AND c .)
    OR              reduce using rule 68 (b -> b AND c .)
    SEMI_COLON      reduce using rule 68 (b -> b AND c .)
    CONSOLE         reduce using rule 68 (b -> b AND c .)
    LET             reduce using rule 68 (b -> b AND c .)
    LITERAL         reduce using rule 68 (b -> b AND c .)
    IF              reduce using rule 68 (b -> b AND c .)
    WHILE           reduce using rule 68 (b -> b AND c .)
    FOR             reduce using rule 68 (b -> b AND c .)
    INTERFACE       reduce using rule 68 (b -> b AND c .)
    CONTINUE        reduce using rule 68 (b -> b AND c .)
    BREAK           reduce using rule 68 (b -> b AND c .)
    RETURN          reduce using rule 68 (b -> b AND c .)
    FUNCTION        reduce using rule 68 (b -> b AND c .)
    $end            reduce using rule 68 (b -> b AND c .)
    R_LLAVE         reduce using rule 68 (b -> b AND c .)
    R_PAREN         reduce using rule 68 (b -> b AND c .)
    COMA            reduce using rule 68 (b -> b AND c .)
    R_CORCHETE      reduce using rule 68 (b -> b AND c .)


state 145

    (72) d -> d DISTINTO_QUE e .
    (79) e -> e . MAS f
    (80) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 72 (d -> d DISTINTO_QUE e .)
    MENOR_QUE       reduce using rule 72 (d -> d DISTINTO_QUE e .)
    MENOR_IGUAL_QUE reduce using rule 72 (d -> d DISTINTO_QUE e .)
    MAYOR_QUE       reduce using rule 72 (d -> d DISTINTO_QUE e .)
    MAYOR_IGUAL_QUE reduce using rule 72 (d -> d DISTINTO_QUE e .)
    TRIPLE_IGUAL    reduce using rule 72 (d -> d DISTINTO_QUE e .)
    AND             reduce using rule 72 (d -> d DISTINTO_QUE e .)
    OR              reduce using rule 72 (d -> d DISTINTO_QUE e .)
    SEMI_COLON      reduce using rule 72 (d -> d DISTINTO_QUE e .)
    CONSOLE         reduce using rule 72 (d -> d DISTINTO_QUE e .)
    LET             reduce using rule 72 (d -> d DISTINTO_QUE e .)
    LITERAL         reduce using rule 72 (d -> d DISTINTO_QUE e .)
    IF              reduce using rule 72 (d -> d DISTINTO_QUE e .)
    WHILE           reduce using rule 72 (d -> d DISTINTO_QUE e .)
    FOR             reduce using rule 72 (d -> d DISTINTO_QUE e .)
    INTERFACE       reduce using rule 72 (d -> d DISTINTO_QUE e .)
    CONTINUE        reduce using rule 72 (d -> d DISTINTO_QUE e .)
    BREAK           reduce using rule 72 (d -> d DISTINTO_QUE e .)
    RETURN          reduce using rule 72 (d -> d DISTINTO_QUE e .)
    FUNCTION        reduce using rule 72 (d -> d DISTINTO_QUE e .)
    $end            reduce using rule 72 (d -> d DISTINTO_QUE e .)
    R_LLAVE         reduce using rule 72 (d -> d DISTINTO_QUE e .)
    R_PAREN         reduce using rule 72 (d -> d DISTINTO_QUE e .)
    COMA            reduce using rule 72 (d -> d DISTINTO_QUE e .)
    R_CORCHETE      reduce using rule 72 (d -> d DISTINTO_QUE e .)
    MAS             shift and go to state 109
    MENOS           shift and go to state 110


state 146

    (73) d -> d MENOR_QUE e .
    (79) e -> e . MAS f
    (80) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 73 (d -> d MENOR_QUE e .)
    MENOR_QUE       reduce using rule 73 (d -> d MENOR_QUE e .)
    MENOR_IGUAL_QUE reduce using rule 73 (d -> d MENOR_QUE e .)
    MAYOR_QUE       reduce using rule 73 (d -> d MENOR_QUE e .)
    MAYOR_IGUAL_QUE reduce using rule 73 (d -> d MENOR_QUE e .)
    TRIPLE_IGUAL    reduce using rule 73 (d -> d MENOR_QUE e .)
    AND             reduce using rule 73 (d -> d MENOR_QUE e .)
    OR              reduce using rule 73 (d -> d MENOR_QUE e .)
    SEMI_COLON      reduce using rule 73 (d -> d MENOR_QUE e .)
    CONSOLE         reduce using rule 73 (d -> d MENOR_QUE e .)
    LET             reduce using rule 73 (d -> d MENOR_QUE e .)
    LITERAL         reduce using rule 73 (d -> d MENOR_QUE e .)
    IF              reduce using rule 73 (d -> d MENOR_QUE e .)
    WHILE           reduce using rule 73 (d -> d MENOR_QUE e .)
    FOR             reduce using rule 73 (d -> d MENOR_QUE e .)
    INTERFACE       reduce using rule 73 (d -> d MENOR_QUE e .)
    CONTINUE        reduce using rule 73 (d -> d MENOR_QUE e .)
    BREAK           reduce using rule 73 (d -> d MENOR_QUE e .)
    RETURN          reduce using rule 73 (d -> d MENOR_QUE e .)
    FUNCTION        reduce using rule 73 (d -> d MENOR_QUE e .)
    $end            reduce using rule 73 (d -> d MENOR_QUE e .)
    R_LLAVE         reduce using rule 73 (d -> d MENOR_QUE e .)
    R_PAREN         reduce using rule 73 (d -> d MENOR_QUE e .)
    COMA            reduce using rule 73 (d -> d MENOR_QUE e .)
    R_CORCHETE      reduce using rule 73 (d -> d MENOR_QUE e .)
    MAS             shift and go to state 109
    MENOS           shift and go to state 110


state 147

    (74) d -> d MENOR_IGUAL_QUE e .
    (79) e -> e . MAS f
    (80) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 74 (d -> d MENOR_IGUAL_QUE e .)
    MENOR_QUE       reduce using rule 74 (d -> d MENOR_IGUAL_QUE e .)
    MENOR_IGUAL_QUE reduce using rule 74 (d -> d MENOR_IGUAL_QUE e .)
    MAYOR_QUE       reduce using rule 74 (d -> d MENOR_IGUAL_QUE e .)
    MAYOR_IGUAL_QUE reduce using rule 74 (d -> d MENOR_IGUAL_QUE e .)
    TRIPLE_IGUAL    reduce using rule 74 (d -> d MENOR_IGUAL_QUE e .)
    AND             reduce using rule 74 (d -> d MENOR_IGUAL_QUE e .)
    OR              reduce using rule 74 (d -> d MENOR_IGUAL_QUE e .)
    SEMI_COLON      reduce using rule 74 (d -> d MENOR_IGUAL_QUE e .)
    CONSOLE         reduce using rule 74 (d -> d MENOR_IGUAL_QUE e .)
    LET             reduce using rule 74 (d -> d MENOR_IGUAL_QUE e .)
    LITERAL         reduce using rule 74 (d -> d MENOR_IGUAL_QUE e .)
    IF              reduce using rule 74 (d -> d MENOR_IGUAL_QUE e .)
    WHILE           reduce using rule 74 (d -> d MENOR_IGUAL_QUE e .)
    FOR             reduce using rule 74 (d -> d MENOR_IGUAL_QUE e .)
    INTERFACE       reduce using rule 74 (d -> d MENOR_IGUAL_QUE e .)
    CONTINUE        reduce using rule 74 (d -> d MENOR_IGUAL_QUE e .)
    BREAK           reduce using rule 74 (d -> d MENOR_IGUAL_QUE e .)
    RETURN          reduce using rule 74 (d -> d MENOR_IGUAL_QUE e .)
    FUNCTION        reduce using rule 74 (d -> d MENOR_IGUAL_QUE e .)
    $end            reduce using rule 74 (d -> d MENOR_IGUAL_QUE e .)
    R_LLAVE         reduce using rule 74 (d -> d MENOR_IGUAL_QUE e .)
    R_PAREN         reduce using rule 74 (d -> d MENOR_IGUAL_QUE e .)
    COMA            reduce using rule 74 (d -> d MENOR_IGUAL_QUE e .)
    R_CORCHETE      reduce using rule 74 (d -> d MENOR_IGUAL_QUE e .)
    MAS             shift and go to state 109
    MENOS           shift and go to state 110


state 148

    (75) d -> d MAYOR_QUE e .
    (79) e -> e . MAS f
    (80) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 75 (d -> d MAYOR_QUE e .)
    MENOR_QUE       reduce using rule 75 (d -> d MAYOR_QUE e .)
    MENOR_IGUAL_QUE reduce using rule 75 (d -> d MAYOR_QUE e .)
    MAYOR_QUE       reduce using rule 75 (d -> d MAYOR_QUE e .)
    MAYOR_IGUAL_QUE reduce using rule 75 (d -> d MAYOR_QUE e .)
    TRIPLE_IGUAL    reduce using rule 75 (d -> d MAYOR_QUE e .)
    AND             reduce using rule 75 (d -> d MAYOR_QUE e .)
    OR              reduce using rule 75 (d -> d MAYOR_QUE e .)
    SEMI_COLON      reduce using rule 75 (d -> d MAYOR_QUE e .)
    CONSOLE         reduce using rule 75 (d -> d MAYOR_QUE e .)
    LET             reduce using rule 75 (d -> d MAYOR_QUE e .)
    LITERAL         reduce using rule 75 (d -> d MAYOR_QUE e .)
    IF              reduce using rule 75 (d -> d MAYOR_QUE e .)
    WHILE           reduce using rule 75 (d -> d MAYOR_QUE e .)
    FOR             reduce using rule 75 (d -> d MAYOR_QUE e .)
    INTERFACE       reduce using rule 75 (d -> d MAYOR_QUE e .)
    CONTINUE        reduce using rule 75 (d -> d MAYOR_QUE e .)
    BREAK           reduce using rule 75 (d -> d MAYOR_QUE e .)
    RETURN          reduce using rule 75 (d -> d MAYOR_QUE e .)
    FUNCTION        reduce using rule 75 (d -> d MAYOR_QUE e .)
    $end            reduce using rule 75 (d -> d MAYOR_QUE e .)
    R_LLAVE         reduce using rule 75 (d -> d MAYOR_QUE e .)
    R_PAREN         reduce using rule 75 (d -> d MAYOR_QUE e .)
    COMA            reduce using rule 75 (d -> d MAYOR_QUE e .)
    R_CORCHETE      reduce using rule 75 (d -> d MAYOR_QUE e .)
    MAS             shift and go to state 109
    MENOS           shift and go to state 110


state 149

    (76) d -> d MAYOR_IGUAL_QUE e .
    (79) e -> e . MAS f
    (80) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 76 (d -> d MAYOR_IGUAL_QUE e .)
    MENOR_QUE       reduce using rule 76 (d -> d MAYOR_IGUAL_QUE e .)
    MENOR_IGUAL_QUE reduce using rule 76 (d -> d MAYOR_IGUAL_QUE e .)
    MAYOR_QUE       reduce using rule 76 (d -> d MAYOR_IGUAL_QUE e .)
    MAYOR_IGUAL_QUE reduce using rule 76 (d -> d MAYOR_IGUAL_QUE e .)
    TRIPLE_IGUAL    reduce using rule 76 (d -> d MAYOR_IGUAL_QUE e .)
    AND             reduce using rule 76 (d -> d MAYOR_IGUAL_QUE e .)
    OR              reduce using rule 76 (d -> d MAYOR_IGUAL_QUE e .)
    SEMI_COLON      reduce using rule 76 (d -> d MAYOR_IGUAL_QUE e .)
    CONSOLE         reduce using rule 76 (d -> d MAYOR_IGUAL_QUE e .)
    LET             reduce using rule 76 (d -> d MAYOR_IGUAL_QUE e .)
    LITERAL         reduce using rule 76 (d -> d MAYOR_IGUAL_QUE e .)
    IF              reduce using rule 76 (d -> d MAYOR_IGUAL_QUE e .)
    WHILE           reduce using rule 76 (d -> d MAYOR_IGUAL_QUE e .)
    FOR             reduce using rule 76 (d -> d MAYOR_IGUAL_QUE e .)
    INTERFACE       reduce using rule 76 (d -> d MAYOR_IGUAL_QUE e .)
    CONTINUE        reduce using rule 76 (d -> d MAYOR_IGUAL_QUE e .)
    BREAK           reduce using rule 76 (d -> d MAYOR_IGUAL_QUE e .)
    RETURN          reduce using rule 76 (d -> d MAYOR_IGUAL_QUE e .)
    FUNCTION        reduce using rule 76 (d -> d MAYOR_IGUAL_QUE e .)
    $end            reduce using rule 76 (d -> d MAYOR_IGUAL_QUE e .)
    R_LLAVE         reduce using rule 76 (d -> d MAYOR_IGUAL_QUE e .)
    R_PAREN         reduce using rule 76 (d -> d MAYOR_IGUAL_QUE e .)
    COMA            reduce using rule 76 (d -> d MAYOR_IGUAL_QUE e .)
    R_CORCHETE      reduce using rule 76 (d -> d MAYOR_IGUAL_QUE e .)
    MAS             shift and go to state 109
    MENOS           shift and go to state 110


state 150

    (77) d -> d TRIPLE_IGUAL e .
    (79) e -> e . MAS f
    (80) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 77 (d -> d TRIPLE_IGUAL e .)
    MENOR_QUE       reduce using rule 77 (d -> d TRIPLE_IGUAL e .)
    MENOR_IGUAL_QUE reduce using rule 77 (d -> d TRIPLE_IGUAL e .)
    MAYOR_QUE       reduce using rule 77 (d -> d TRIPLE_IGUAL e .)
    MAYOR_IGUAL_QUE reduce using rule 77 (d -> d TRIPLE_IGUAL e .)
    TRIPLE_IGUAL    reduce using rule 77 (d -> d TRIPLE_IGUAL e .)
    AND             reduce using rule 77 (d -> d TRIPLE_IGUAL e .)
    OR              reduce using rule 77 (d -> d TRIPLE_IGUAL e .)
    SEMI_COLON      reduce using rule 77 (d -> d TRIPLE_IGUAL e .)
    CONSOLE         reduce using rule 77 (d -> d TRIPLE_IGUAL e .)
    LET             reduce using rule 77 (d -> d TRIPLE_IGUAL e .)
    LITERAL         reduce using rule 77 (d -> d TRIPLE_IGUAL e .)
    IF              reduce using rule 77 (d -> d TRIPLE_IGUAL e .)
    WHILE           reduce using rule 77 (d -> d TRIPLE_IGUAL e .)
    FOR             reduce using rule 77 (d -> d TRIPLE_IGUAL e .)
    INTERFACE       reduce using rule 77 (d -> d TRIPLE_IGUAL e .)
    CONTINUE        reduce using rule 77 (d -> d TRIPLE_IGUAL e .)
    BREAK           reduce using rule 77 (d -> d TRIPLE_IGUAL e .)
    RETURN          reduce using rule 77 (d -> d TRIPLE_IGUAL e .)
    FUNCTION        reduce using rule 77 (d -> d TRIPLE_IGUAL e .)
    $end            reduce using rule 77 (d -> d TRIPLE_IGUAL e .)
    R_LLAVE         reduce using rule 77 (d -> d TRIPLE_IGUAL e .)
    R_PAREN         reduce using rule 77 (d -> d TRIPLE_IGUAL e .)
    COMA            reduce using rule 77 (d -> d TRIPLE_IGUAL e .)
    R_CORCHETE      reduce using rule 77 (d -> d TRIPLE_IGUAL e .)
    MAS             shift and go to state 109
    MENOS           shift and go to state 110


state 151

    (79) e -> e MAS f .

    MAS             reduce using rule 79 (e -> e MAS f .)
    MENOS           reduce using rule 79 (e -> e MAS f .)
    DISTINTO_QUE    reduce using rule 79 (e -> e MAS f .)
    MENOR_QUE       reduce using rule 79 (e -> e MAS f .)
    MENOR_IGUAL_QUE reduce using rule 79 (e -> e MAS f .)
    MAYOR_QUE       reduce using rule 79 (e -> e MAS f .)
    MAYOR_IGUAL_QUE reduce using rule 79 (e -> e MAS f .)
    TRIPLE_IGUAL    reduce using rule 79 (e -> e MAS f .)
    AND             reduce using rule 79 (e -> e MAS f .)
    OR              reduce using rule 79 (e -> e MAS f .)
    SEMI_COLON      reduce using rule 79 (e -> e MAS f .)
    CONSOLE         reduce using rule 79 (e -> e MAS f .)
    LET             reduce using rule 79 (e -> e MAS f .)
    LITERAL         reduce using rule 79 (e -> e MAS f .)
    IF              reduce using rule 79 (e -> e MAS f .)
    WHILE           reduce using rule 79 (e -> e MAS f .)
    FOR             reduce using rule 79 (e -> e MAS f .)
    INTERFACE       reduce using rule 79 (e -> e MAS f .)
    CONTINUE        reduce using rule 79 (e -> e MAS f .)
    BREAK           reduce using rule 79 (e -> e MAS f .)
    RETURN          reduce using rule 79 (e -> e MAS f .)
    FUNCTION        reduce using rule 79 (e -> e MAS f .)
    $end            reduce using rule 79 (e -> e MAS f .)
    R_LLAVE         reduce using rule 79 (e -> e MAS f .)
    R_PAREN         reduce using rule 79 (e -> e MAS f .)
    COMA            reduce using rule 79 (e -> e MAS f .)
    R_CORCHETE      reduce using rule 79 (e -> e MAS f .)


state 152

    (80) e -> e MENOS f .

    MAS             reduce using rule 80 (e -> e MENOS f .)
    MENOS           reduce using rule 80 (e -> e MENOS f .)
    DISTINTO_QUE    reduce using rule 80 (e -> e MENOS f .)
    MENOR_QUE       reduce using rule 80 (e -> e MENOS f .)
    MENOR_IGUAL_QUE reduce using rule 80 (e -> e MENOS f .)
    MAYOR_QUE       reduce using rule 80 (e -> e MENOS f .)
    MAYOR_IGUAL_QUE reduce using rule 80 (e -> e MENOS f .)
    TRIPLE_IGUAL    reduce using rule 80 (e -> e MENOS f .)
    AND             reduce using rule 80 (e -> e MENOS f .)
    OR              reduce using rule 80 (e -> e MENOS f .)
    SEMI_COLON      reduce using rule 80 (e -> e MENOS f .)
    CONSOLE         reduce using rule 80 (e -> e MENOS f .)
    LET             reduce using rule 80 (e -> e MENOS f .)
    LITERAL         reduce using rule 80 (e -> e MENOS f .)
    IF              reduce using rule 80 (e -> e MENOS f .)
    WHILE           reduce using rule 80 (e -> e MENOS f .)
    FOR             reduce using rule 80 (e -> e MENOS f .)
    INTERFACE       reduce using rule 80 (e -> e MENOS f .)
    CONTINUE        reduce using rule 80 (e -> e MENOS f .)
    BREAK           reduce using rule 80 (e -> e MENOS f .)
    RETURN          reduce using rule 80 (e -> e MENOS f .)
    FUNCTION        reduce using rule 80 (e -> e MENOS f .)
    $end            reduce using rule 80 (e -> e MENOS f .)
    R_LLAVE         reduce using rule 80 (e -> e MENOS f .)
    R_PAREN         reduce using rule 80 (e -> e MENOS f .)
    COMA            reduce using rule 80 (e -> e MENOS f .)
    R_CORCHETE      reduce using rule 80 (e -> e MENOS f .)


state 153

    (85) g -> g TIMES h .

    TIMES           reduce using rule 85 (g -> g TIMES h .)
    DIVIDE          reduce using rule 85 (g -> g TIMES h .)
    MOD             reduce using rule 85 (g -> g TIMES h .)
    POTENCIA        reduce using rule 85 (g -> g TIMES h .)
    MAS             reduce using rule 85 (g -> g TIMES h .)
    MENOS           reduce using rule 85 (g -> g TIMES h .)
    DISTINTO_QUE    reduce using rule 85 (g -> g TIMES h .)
    MENOR_QUE       reduce using rule 85 (g -> g TIMES h .)
    MENOR_IGUAL_QUE reduce using rule 85 (g -> g TIMES h .)
    MAYOR_QUE       reduce using rule 85 (g -> g TIMES h .)
    MAYOR_IGUAL_QUE reduce using rule 85 (g -> g TIMES h .)
    TRIPLE_IGUAL    reduce using rule 85 (g -> g TIMES h .)
    AND             reduce using rule 85 (g -> g TIMES h .)
    OR              reduce using rule 85 (g -> g TIMES h .)
    SEMI_COLON      reduce using rule 85 (g -> g TIMES h .)
    CONSOLE         reduce using rule 85 (g -> g TIMES h .)
    LET             reduce using rule 85 (g -> g TIMES h .)
    LITERAL         reduce using rule 85 (g -> g TIMES h .)
    IF              reduce using rule 85 (g -> g TIMES h .)
    WHILE           reduce using rule 85 (g -> g TIMES h .)
    FOR             reduce using rule 85 (g -> g TIMES h .)
    INTERFACE       reduce using rule 85 (g -> g TIMES h .)
    CONTINUE        reduce using rule 85 (g -> g TIMES h .)
    BREAK           reduce using rule 85 (g -> g TIMES h .)
    RETURN          reduce using rule 85 (g -> g TIMES h .)
    FUNCTION        reduce using rule 85 (g -> g TIMES h .)
    $end            reduce using rule 85 (g -> g TIMES h .)
    R_LLAVE         reduce using rule 85 (g -> g TIMES h .)
    R_PAREN         reduce using rule 85 (g -> g TIMES h .)
    COMA            reduce using rule 85 (g -> g TIMES h .)
    R_CORCHETE      reduce using rule 85 (g -> g TIMES h .)


state 154

    (86) g -> g DIVIDE h .

    TIMES           reduce using rule 86 (g -> g DIVIDE h .)
    DIVIDE          reduce using rule 86 (g -> g DIVIDE h .)
    MOD             reduce using rule 86 (g -> g DIVIDE h .)
    POTENCIA        reduce using rule 86 (g -> g DIVIDE h .)
    MAS             reduce using rule 86 (g -> g DIVIDE h .)
    MENOS           reduce using rule 86 (g -> g DIVIDE h .)
    DISTINTO_QUE    reduce using rule 86 (g -> g DIVIDE h .)
    MENOR_QUE       reduce using rule 86 (g -> g DIVIDE h .)
    MENOR_IGUAL_QUE reduce using rule 86 (g -> g DIVIDE h .)
    MAYOR_QUE       reduce using rule 86 (g -> g DIVIDE h .)
    MAYOR_IGUAL_QUE reduce using rule 86 (g -> g DIVIDE h .)
    TRIPLE_IGUAL    reduce using rule 86 (g -> g DIVIDE h .)
    AND             reduce using rule 86 (g -> g DIVIDE h .)
    OR              reduce using rule 86 (g -> g DIVIDE h .)
    SEMI_COLON      reduce using rule 86 (g -> g DIVIDE h .)
    CONSOLE         reduce using rule 86 (g -> g DIVIDE h .)
    LET             reduce using rule 86 (g -> g DIVIDE h .)
    LITERAL         reduce using rule 86 (g -> g DIVIDE h .)
    IF              reduce using rule 86 (g -> g DIVIDE h .)
    WHILE           reduce using rule 86 (g -> g DIVIDE h .)
    FOR             reduce using rule 86 (g -> g DIVIDE h .)
    INTERFACE       reduce using rule 86 (g -> g DIVIDE h .)
    CONTINUE        reduce using rule 86 (g -> g DIVIDE h .)
    BREAK           reduce using rule 86 (g -> g DIVIDE h .)
    RETURN          reduce using rule 86 (g -> g DIVIDE h .)
    FUNCTION        reduce using rule 86 (g -> g DIVIDE h .)
    $end            reduce using rule 86 (g -> g DIVIDE h .)
    R_LLAVE         reduce using rule 86 (g -> g DIVIDE h .)
    R_PAREN         reduce using rule 86 (g -> g DIVIDE h .)
    COMA            reduce using rule 86 (g -> g DIVIDE h .)
    R_CORCHETE      reduce using rule 86 (g -> g DIVIDE h .)


state 155

    (87) g -> g MOD h .

    TIMES           reduce using rule 87 (g -> g MOD h .)
    DIVIDE          reduce using rule 87 (g -> g MOD h .)
    MOD             reduce using rule 87 (g -> g MOD h .)
    POTENCIA        reduce using rule 87 (g -> g MOD h .)
    MAS             reduce using rule 87 (g -> g MOD h .)
    MENOS           reduce using rule 87 (g -> g MOD h .)
    DISTINTO_QUE    reduce using rule 87 (g -> g MOD h .)
    MENOR_QUE       reduce using rule 87 (g -> g MOD h .)
    MENOR_IGUAL_QUE reduce using rule 87 (g -> g MOD h .)
    MAYOR_QUE       reduce using rule 87 (g -> g MOD h .)
    MAYOR_IGUAL_QUE reduce using rule 87 (g -> g MOD h .)
    TRIPLE_IGUAL    reduce using rule 87 (g -> g MOD h .)
    AND             reduce using rule 87 (g -> g MOD h .)
    OR              reduce using rule 87 (g -> g MOD h .)
    SEMI_COLON      reduce using rule 87 (g -> g MOD h .)
    CONSOLE         reduce using rule 87 (g -> g MOD h .)
    LET             reduce using rule 87 (g -> g MOD h .)
    LITERAL         reduce using rule 87 (g -> g MOD h .)
    IF              reduce using rule 87 (g -> g MOD h .)
    WHILE           reduce using rule 87 (g -> g MOD h .)
    FOR             reduce using rule 87 (g -> g MOD h .)
    INTERFACE       reduce using rule 87 (g -> g MOD h .)
    CONTINUE        reduce using rule 87 (g -> g MOD h .)
    BREAK           reduce using rule 87 (g -> g MOD h .)
    RETURN          reduce using rule 87 (g -> g MOD h .)
    FUNCTION        reduce using rule 87 (g -> g MOD h .)
    $end            reduce using rule 87 (g -> g MOD h .)
    R_LLAVE         reduce using rule 87 (g -> g MOD h .)
    R_PAREN         reduce using rule 87 (g -> g MOD h .)
    COMA            reduce using rule 87 (g -> g MOD h .)
    R_CORCHETE      reduce using rule 87 (g -> g MOD h .)


state 156

    (88) g -> g POTENCIA h .

    TIMES           reduce using rule 88 (g -> g POTENCIA h .)
    DIVIDE          reduce using rule 88 (g -> g POTENCIA h .)
    MOD             reduce using rule 88 (g -> g POTENCIA h .)
    POTENCIA        reduce using rule 88 (g -> g POTENCIA h .)
    MAS             reduce using rule 88 (g -> g POTENCIA h .)
    MENOS           reduce using rule 88 (g -> g POTENCIA h .)
    DISTINTO_QUE    reduce using rule 88 (g -> g POTENCIA h .)
    MENOR_QUE       reduce using rule 88 (g -> g POTENCIA h .)
    MENOR_IGUAL_QUE reduce using rule 88 (g -> g POTENCIA h .)
    MAYOR_QUE       reduce using rule 88 (g -> g POTENCIA h .)
    MAYOR_IGUAL_QUE reduce using rule 88 (g -> g POTENCIA h .)
    TRIPLE_IGUAL    reduce using rule 88 (g -> g POTENCIA h .)
    AND             reduce using rule 88 (g -> g POTENCIA h .)
    OR              reduce using rule 88 (g -> g POTENCIA h .)
    SEMI_COLON      reduce using rule 88 (g -> g POTENCIA h .)
    CONSOLE         reduce using rule 88 (g -> g POTENCIA h .)
    LET             reduce using rule 88 (g -> g POTENCIA h .)
    LITERAL         reduce using rule 88 (g -> g POTENCIA h .)
    IF              reduce using rule 88 (g -> g POTENCIA h .)
    WHILE           reduce using rule 88 (g -> g POTENCIA h .)
    FOR             reduce using rule 88 (g -> g POTENCIA h .)
    INTERFACE       reduce using rule 88 (g -> g POTENCIA h .)
    CONTINUE        reduce using rule 88 (g -> g POTENCIA h .)
    BREAK           reduce using rule 88 (g -> g POTENCIA h .)
    RETURN          reduce using rule 88 (g -> g POTENCIA h .)
    FUNCTION        reduce using rule 88 (g -> g POTENCIA h .)
    $end            reduce using rule 88 (g -> g POTENCIA h .)
    R_LLAVE         reduce using rule 88 (g -> g POTENCIA h .)
    R_PAREN         reduce using rule 88 (g -> g POTENCIA h .)
    COMA            reduce using rule 88 (g -> g POTENCIA h .)
    R_CORCHETE      reduce using rule 88 (g -> g POTENCIA h .)


state 157

    (90) g -> h PUNTO nativeFun . L_PAREN expresion R_PAREN
    (91) g -> h PUNTO nativeFun . L_PAREN R_PAREN

    L_PAREN         shift and go to state 190


state 158

    (112) nativeFun -> TOSTRING .

    L_PAREN         reduce using rule 112 (nativeFun -> TOSTRING .)


state 159

    (113) nativeFun -> TOFIXED .

    L_PAREN         reduce using rule 113 (nativeFun -> TOFIXED .)


state 160

    (114) nativeFun -> TOEXPONENTIAL .

    L_PAREN         reduce using rule 114 (nativeFun -> TOEXPONENTIAL .)


state 161

    (115) nativeFun -> TOLOWERCASE .

    L_PAREN         reduce using rule 115 (nativeFun -> TOLOWERCASE .)


state 162

    (116) nativeFun -> TOUPPERCASE .

    L_PAREN         reduce using rule 116 (nativeFun -> TOUPPERCASE .)


state 163

    (117) nativeFun -> SPLIT .

    L_PAREN         reduce using rule 117 (nativeFun -> SPLIT .)


state 164

    (118) nativeFun -> CONCAT .

    L_PAREN         reduce using rule 118 (nativeFun -> CONCAT .)


state 165

    (101) h -> L_PAREN a R_PAREN .

    PUNTO           reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    TIMES           reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    DIVIDE          reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    MOD             reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    POTENCIA        reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    MAS             reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    MENOS           reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    DISTINTO_QUE    reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    MENOR_QUE       reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    MENOR_IGUAL_QUE reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    MAYOR_QUE       reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    MAYOR_IGUAL_QUE reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    TRIPLE_IGUAL    reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    AND             reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    OR              reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    SEMI_COLON      reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    CONSOLE         reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    LET             reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    LITERAL         reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    IF              reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    WHILE           reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    FOR             reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    INTERFACE       reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    CONTINUE        reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    BREAK           reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    RETURN          reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    FUNCTION        reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    $end            reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    R_LLAVE         reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    R_PAREN         reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    COMA            reduce using rule 101 (h -> L_PAREN a R_PAREN .)
    R_CORCHETE      reduce using rule 101 (h -> L_PAREN a R_PAREN .)


state 166

    (104) dimensions -> dimensions L_CORCHETE . a R_CORCHETE
    (66) a -> . a OR b
    (67) a -> . b
    (68) b -> . b AND c
    (69) b -> . c
    (70) c -> . NOT d
    (71) c -> . d
    (72) d -> . d DISTINTO_QUE e
    (73) d -> . d MENOR_QUE e
    (74) d -> . d MENOR_IGUAL_QUE e
    (75) d -> . d MAYOR_QUE e
    (76) d -> . d MAYOR_IGUAL_QUE e
    (77) d -> . d TRIPLE_IGUAL e
    (78) d -> . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 60
    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    a                              shift and go to state 191
    b                              shift and go to state 58
    c                              shift and go to state 59
    d                              shift and go to state 61
    e                              shift and go to state 62
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 167

    (105) dimensions -> L_CORCHETE a . R_CORCHETE
    (66) a -> a . OR b

    R_CORCHETE      shift and go to state 192
    OR              shift and go to state 100


state 168

    (111) array_pro -> L_CORCHETE values R_CORCHETE .

    PUNTO           reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    TIMES           reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    DIVIDE          reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    MOD             reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    POTENCIA        reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    MAS             reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    MENOS           reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    DISTINTO_QUE    reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    MENOR_QUE       reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    MENOR_IGUAL_QUE reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    MAYOR_QUE       reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    MAYOR_IGUAL_QUE reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    TRIPLE_IGUAL    reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    AND             reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    OR              reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    SEMI_COLON      reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    CONSOLE         reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    LET             reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    LITERAL         reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    IF              reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    WHILE           reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    FOR             reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    INTERFACE       reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    CONTINUE        reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    BREAK           reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    RETURN          reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    FUNCTION        reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    $end            reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    R_LLAVE         reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    R_PAREN         reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    COMA            reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)
    R_CORCHETE      reduce using rule 111 (array_pro -> L_CORCHETE values R_CORCHETE .)


state 169

    (108) interface_assi -> L_LLAVE atributos_assi R_LLAVE .

    PUNTO           reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    TIMES           reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    DIVIDE          reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MOD             reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    POTENCIA        reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MAS             reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MENOS           reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    DISTINTO_QUE    reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MENOR_QUE       reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MENOR_IGUAL_QUE reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MAYOR_QUE       reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MAYOR_IGUAL_QUE reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    TRIPLE_IGUAL    reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    AND             reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    OR              reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    SEMI_COLON      reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    CONSOLE         reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    LET             reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    LITERAL         reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    IF              reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    WHILE           reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    FOR             reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    INTERFACE       reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    CONTINUE        reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    BREAK           reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    RETURN          reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    FUNCTION        reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    $end            reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    R_LLAVE         reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    R_PAREN         reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    COMA            reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    R_CORCHETE      reduce using rule 108 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)


state 170

    (109) atributos_assi -> atributos_assi COMA . LITERAL COLON a

    LITERAL         shift and go to state 193


state 171

    (110) atributos_assi -> LITERAL COLON . a
    (66) a -> . a OR b
    (67) a -> . b
    (68) b -> . b AND c
    (69) b -> . c
    (70) c -> . NOT d
    (71) c -> . d
    (72) d -> . d DISTINTO_QUE e
    (73) d -> . d MENOR_QUE e
    (74) d -> . d MENOR_IGUAL_QUE e
    (75) d -> . d MAYOR_QUE e
    (76) d -> . d MAYOR_IGUAL_QUE e
    (77) d -> . d TRIPLE_IGUAL e
    (78) d -> . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 60
    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    a                              shift and go to state 194
    b                              shift and go to state 58
    c                              shift and go to state 59
    d                              shift and go to state 61
    e                              shift and go to state 62
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 172

    (28) parameter_pro -> LITERAL . COLON type
    (29) parameter_pro -> LITERAL .

    COLON           shift and go to state 195
    R_PAREN         reduce using rule 29 (parameter_pro -> LITERAL .)
    COMA            reduce using rule 29 (parameter_pro -> LITERAL .)


state 173

    (20) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro . R_PAREN L_LLAVE instrucciones R_LLAVE
    (26) parameters_pro -> parameters_pro . COMA parameter_pro

    R_PAREN         shift and go to state 196
    COMA            shift and go to state 197


state 174

    (21) function_pro -> FUNCTION LITERAL L_PAREN R_PAREN . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 198


state 175

    (27) parameters_pro -> parameter_pro .

    R_PAREN         reduce using rule 27 (parameters_pro -> parameter_pro .)
    COMA            reduce using rule 27 (parameters_pro -> parameter_pro .)


state 176

    (63) console_pro -> CONSOLE PUNTO LOG L_PAREN expresion . R_PAREN
    (64) expresion -> expresion . COMA a

    R_PAREN         shift and go to state 199
    COMA            shift and go to state 200


state 177

    (65) expresion -> a .
    (66) a -> a . OR b

    R_PAREN         reduce using rule 65 (expresion -> a .)
    COMA            reduce using rule 65 (expresion -> a .)
    OR              shift and go to state 100


state 178

    (42) assignacion_instruction -> LITERAL COLON type IGUAL . a
    (66) a -> . a OR b
    (67) a -> . b
    (68) b -> . b AND c
    (69) b -> . c
    (70) c -> . NOT d
    (71) c -> . d
    (72) d -> . d DISTINTO_QUE e
    (73) d -> . d MENOR_QUE e
    (74) d -> . d MENOR_IGUAL_QUE e
    (75) d -> . d MAYOR_QUE e
    (76) d -> . d MAYOR_IGUAL_QUE e
    (77) d -> . d TRIPLE_IGUAL e
    (78) d -> . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 60
    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    a                              shift and go to state 201
    b                              shift and go to state 58
    c                              shift and go to state 59
    d                              shift and go to state 61
    e                              shift and go to state 62
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 179

    (24) values -> values COMA a .
    (66) a -> a . OR b

    R_PAREN         reduce using rule 24 (values -> values COMA a .)
    COMA            reduce using rule 24 (values -> values COMA a .)
    R_CORCHETE      reduce using rule 24 (values -> values COMA a .)
    OR              shift and go to state 100


state 180

    (51) if_pro -> IF L_PAREN a R_PAREN L_LLAVE . instrucciones R_LLAVE else_pro
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . call_function_pro sc
    (17) instruccion -> . sumadores sc
    (63) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (39) declaration_instruction -> . LET declaracion_list
    (50) assig_pro -> . LITERAL IGUAL a
    (51) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (55) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (56) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (57) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (60) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (34) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (30) continue_pro -> . CONTINUE
    (31) break_pro -> . BREAK
    (32) return_pro -> . RETURN
    (33) return_pro -> . RETURN a
    (20) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (21) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (106) sumadores -> . LITERAL MAS MAS
    (107) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 18
    LET             shift and go to state 19
    LITERAL         shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    INTERFACE       shift and go to state 24
    CONTINUE        shift and go to state 25
    BREAK           shift and go to state 26
    RETURN          shift and go to state 27
    FUNCTION        shift and go to state 28

    instrucciones                  shift and go to state 202
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    call_function_pro              shift and go to state 16
    sumadores                      shift and go to state 17

state 181

    (55) while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . call_function_pro sc
    (17) instruccion -> . sumadores sc
    (63) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (39) declaration_instruction -> . LET declaracion_list
    (50) assig_pro -> . LITERAL IGUAL a
    (51) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (55) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (56) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (57) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (60) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (34) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (30) continue_pro -> . CONTINUE
    (31) break_pro -> . BREAK
    (32) return_pro -> . RETURN
    (33) return_pro -> . RETURN a
    (20) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (21) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (106) sumadores -> . LITERAL MAS MAS
    (107) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 18
    LET             shift and go to state 19
    LITERAL         shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    INTERFACE       shift and go to state 24
    CONTINUE        shift and go to state 25
    BREAK           shift and go to state 26
    RETURN          shift and go to state 27
    FUNCTION        shift and go to state 28

    instrucciones                  shift and go to state 203
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    call_function_pro              shift and go to state 16
    sumadores                      shift and go to state 17

state 182

    (56) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a . SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (66) a -> a . OR b

    SEMI_COLON      shift and go to state 204
    OR              shift and go to state 100


state 183

    (57) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a . SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (66) a -> a . OR b

    SEMI_COLON      shift and go to state 205
    OR              shift and go to state 100


state 184

    (60) for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . call_function_pro sc
    (17) instruccion -> . sumadores sc
    (63) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (39) declaration_instruction -> . LET declaracion_list
    (50) assig_pro -> . LITERAL IGUAL a
    (51) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (55) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (56) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (57) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (60) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (34) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (30) continue_pro -> . CONTINUE
    (31) break_pro -> . BREAK
    (32) return_pro -> . RETURN
    (33) return_pro -> . RETURN a
    (20) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (21) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (106) sumadores -> . LITERAL MAS MAS
    (107) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 18
    LET             shift and go to state 19
    LITERAL         shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    INTERFACE       shift and go to state 24
    CONTINUE        shift and go to state 25
    BREAK           shift and go to state 26
    RETURN          shift and go to state 27
    FUNCTION        shift and go to state 28

    instrucciones                  shift and go to state 206
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    call_function_pro              shift and go to state 16
    sumadores                      shift and go to state 17

state 185

    (61) for_each_dec -> LET LITERAL OF . a
    (66) a -> . a OR b
    (67) a -> . b
    (68) b -> . b AND c
    (69) b -> . c
    (70) c -> . NOT d
    (71) c -> . d
    (72) d -> . d DISTINTO_QUE e
    (73) d -> . d MENOR_QUE e
    (74) d -> . d MENOR_IGUAL_QUE e
    (75) d -> . d MAYOR_QUE e
    (76) d -> . d MAYOR_IGUAL_QUE e
    (77) d -> . d TRIPLE_IGUAL e
    (78) d -> . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 60
    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    a                              shift and go to state 207
    b                              shift and go to state 58
    c                              shift and go to state 59
    d                              shift and go to state 61
    e                              shift and go to state 62
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 186

    (62) for_each_dec -> LET LITERAL COLON . type OF a
    (42) assignacion_instruction -> LITERAL COLON . type IGUAL a
    (43) assignacion_instruction -> LITERAL COLON . type
    (45) type -> . NUMBER
    (46) type -> . STRING
    (47) type -> . BOOLEAN
    (48) type -> . ANY
    (49) type -> . LITERAL

    NUMBER          shift and go to state 129
    STRING          shift and go to state 130
    BOOLEAN         shift and go to state 131
    ANY             shift and go to state 132
    LITERAL         shift and go to state 127

    type                           shift and go to state 208

state 187

    (37) interface_atributo -> LITERAL . COLON type
    (38) interface_atributo -> LITERAL .

    COLON           shift and go to state 209
    SEMI_COLON      reduce using rule 38 (interface_atributo -> LITERAL .)
    R_LLAVE         reduce using rule 38 (interface_atributo -> LITERAL .)
    LITERAL         reduce using rule 38 (interface_atributo -> LITERAL .)


state 188

    (34) interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .

    SEMI_COLON      reduce using rule 34 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    CONSOLE         reduce using rule 34 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    LET             reduce using rule 34 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    LITERAL         reduce using rule 34 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    IF              reduce using rule 34 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    WHILE           reduce using rule 34 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    FOR             reduce using rule 34 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    INTERFACE       reduce using rule 34 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    CONTINUE        reduce using rule 34 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    BREAK           reduce using rule 34 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    RETURN          reduce using rule 34 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    FUNCTION        reduce using rule 34 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    $end            reduce using rule 34 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    R_LLAVE         reduce using rule 34 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)


state 189

    (35) interface_atributos -> interface_atributos interface_atributo . sc
    (18) sc -> . SEMI_COLON
    (19) sc -> .

    SEMI_COLON      shift and go to state 31
    R_LLAVE         reduce using rule 19 (sc -> .)
    LITERAL         reduce using rule 19 (sc -> .)

    sc                             shift and go to state 210

state 190

    (90) g -> h PUNTO nativeFun L_PAREN . expresion R_PAREN
    (91) g -> h PUNTO nativeFun L_PAREN . R_PAREN
    (64) expresion -> . expresion COMA a
    (65) expresion -> . a
    (66) a -> . a OR b
    (67) a -> . b
    (68) b -> . b AND c
    (69) b -> . c
    (70) c -> . NOT d
    (71) c -> . d
    (72) d -> . d DISTINTO_QUE e
    (73) d -> . d MENOR_QUE e
    (74) d -> . d MENOR_IGUAL_QUE e
    (75) d -> . d MAYOR_QUE e
    (76) d -> . d MAYOR_IGUAL_QUE e
    (77) d -> . d TRIPLE_IGUAL e
    (78) d -> . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    R_PAREN         shift and go to state 212
    NOT             shift and go to state 60
    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    h                              shift and go to state 67
    expresion                      shift and go to state 211
    a                              shift and go to state 177
    b                              shift and go to state 58
    c                              shift and go to state 59
    d                              shift and go to state 61
    e                              shift and go to state 62
    f                              shift and go to state 64
    g                              shift and go to state 66
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 191

    (104) dimensions -> dimensions L_CORCHETE a . R_CORCHETE
    (66) a -> a . OR b

    R_CORCHETE      shift and go to state 213
    OR              shift and go to state 100


state 192

    (105) dimensions -> L_CORCHETE a R_CORCHETE .

    L_CORCHETE      reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    PUNTO           reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    TIMES           reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    DIVIDE          reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    MOD             reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    POTENCIA        reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    MAS             reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    MENOS           reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    DISTINTO_QUE    reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    MENOR_QUE       reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    MENOR_IGUAL_QUE reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    MAYOR_QUE       reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    MAYOR_IGUAL_QUE reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    TRIPLE_IGUAL    reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    AND             reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    OR              reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    SEMI_COLON      reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    CONSOLE         reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    LET             reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    LITERAL         reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    IF              reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    WHILE           reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    FOR             reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    INTERFACE       reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    CONTINUE        reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    BREAK           reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    RETURN          reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    FUNCTION        reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    $end            reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    R_LLAVE         reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    R_PAREN         reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    COMA            reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)
    R_CORCHETE      reduce using rule 105 (dimensions -> L_CORCHETE a R_CORCHETE .)


state 193

    (109) atributos_assi -> atributos_assi COMA LITERAL . COLON a

    COLON           shift and go to state 214


state 194

    (110) atributos_assi -> LITERAL COLON a .
    (66) a -> a . OR b

    R_LLAVE         reduce using rule 110 (atributos_assi -> LITERAL COLON a .)
    COMA            reduce using rule 110 (atributos_assi -> LITERAL COLON a .)
    OR              shift and go to state 100


state 195

    (28) parameter_pro -> LITERAL COLON . type
    (45) type -> . NUMBER
    (46) type -> . STRING
    (47) type -> . BOOLEAN
    (48) type -> . ANY
    (49) type -> . LITERAL

    NUMBER          shift and go to state 129
    STRING          shift and go to state 130
    BOOLEAN         shift and go to state 131
    ANY             shift and go to state 132
    LITERAL         shift and go to state 127

    type                           shift and go to state 215

state 196

    (20) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 216


state 197

    (26) parameters_pro -> parameters_pro COMA . parameter_pro
    (28) parameter_pro -> . LITERAL COLON type
    (29) parameter_pro -> . LITERAL

    LITERAL         shift and go to state 172

    parameter_pro                  shift and go to state 217

state 198

    (21) function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . call_function_pro sc
    (17) instruccion -> . sumadores sc
    (63) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (39) declaration_instruction -> . LET declaracion_list
    (50) assig_pro -> . LITERAL IGUAL a
    (51) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (55) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (56) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (57) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (60) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (34) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (30) continue_pro -> . CONTINUE
    (31) break_pro -> . BREAK
    (32) return_pro -> . RETURN
    (33) return_pro -> . RETURN a
    (20) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (21) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (106) sumadores -> . LITERAL MAS MAS
    (107) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 18
    LET             shift and go to state 19
    LITERAL         shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    INTERFACE       shift and go to state 24
    CONTINUE        shift and go to state 25
    BREAK           shift and go to state 26
    RETURN          shift and go to state 27
    FUNCTION        shift and go to state 28

    instrucciones                  shift and go to state 218
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    call_function_pro              shift and go to state 16
    sumadores                      shift and go to state 17

state 199

    (63) console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .

    SEMI_COLON      reduce using rule 63 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    CONSOLE         reduce using rule 63 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    LET             reduce using rule 63 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    LITERAL         reduce using rule 63 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    IF              reduce using rule 63 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    WHILE           reduce using rule 63 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    FOR             reduce using rule 63 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    INTERFACE       reduce using rule 63 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    CONTINUE        reduce using rule 63 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    BREAK           reduce using rule 63 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    RETURN          reduce using rule 63 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    FUNCTION        reduce using rule 63 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    $end            reduce using rule 63 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    R_LLAVE         reduce using rule 63 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)


state 200

    (64) expresion -> expresion COMA . a
    (66) a -> . a OR b
    (67) a -> . b
    (68) b -> . b AND c
    (69) b -> . c
    (70) c -> . NOT d
    (71) c -> . d
    (72) d -> . d DISTINTO_QUE e
    (73) d -> . d MENOR_QUE e
    (74) d -> . d MENOR_IGUAL_QUE e
    (75) d -> . d MAYOR_QUE e
    (76) d -> . d MAYOR_IGUAL_QUE e
    (77) d -> . d TRIPLE_IGUAL e
    (78) d -> . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 60
    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    a                              shift and go to state 219
    b                              shift and go to state 58
    c                              shift and go to state 59
    d                              shift and go to state 61
    e                              shift and go to state 62
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 201

    (42) assignacion_instruction -> LITERAL COLON type IGUAL a .
    (66) a -> a . OR b

    COMA            reduce using rule 42 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    SEMI_COLON      reduce using rule 42 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    CONSOLE         reduce using rule 42 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    LET             reduce using rule 42 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    LITERAL         reduce using rule 42 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    IF              reduce using rule 42 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    WHILE           reduce using rule 42 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    FOR             reduce using rule 42 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    INTERFACE       reduce using rule 42 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    CONTINUE        reduce using rule 42 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    BREAK           reduce using rule 42 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    RETURN          reduce using rule 42 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    FUNCTION        reduce using rule 42 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    $end            reduce using rule 42 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    R_LLAVE         reduce using rule 42 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    OR              shift and go to state 100


state 202

    (51) if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones . R_LLAVE else_pro
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . call_function_pro sc
    (17) instruccion -> . sumadores sc
    (63) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (39) declaration_instruction -> . LET declaracion_list
    (50) assig_pro -> . LITERAL IGUAL a
    (51) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (55) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (56) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (57) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (60) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (34) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (30) continue_pro -> . CONTINUE
    (31) break_pro -> . BREAK
    (32) return_pro -> . RETURN
    (33) return_pro -> . RETURN a
    (20) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (21) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (106) sumadores -> . LITERAL MAS MAS
    (107) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 220
    CONSOLE         shift and go to state 18
    LET             shift and go to state 19
    LITERAL         shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    INTERFACE       shift and go to state 24
    CONTINUE        shift and go to state 25
    BREAK           shift and go to state 26
    RETURN          shift and go to state 27
    FUNCTION        shift and go to state 28

    instruccion                    shift and go to state 29
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    call_function_pro              shift and go to state 16
    sumadores                      shift and go to state 17

state 203

    (55) while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . call_function_pro sc
    (17) instruccion -> . sumadores sc
    (63) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (39) declaration_instruction -> . LET declaracion_list
    (50) assig_pro -> . LITERAL IGUAL a
    (51) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (55) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (56) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (57) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (60) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (34) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (30) continue_pro -> . CONTINUE
    (31) break_pro -> . BREAK
    (32) return_pro -> . RETURN
    (33) return_pro -> . RETURN a
    (20) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (21) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (106) sumadores -> . LITERAL MAS MAS
    (107) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 221
    CONSOLE         shift and go to state 18
    LET             shift and go to state 19
    LITERAL         shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    INTERFACE       shift and go to state 24
    CONTINUE        shift and go to state 25
    BREAK           shift and go to state 26
    RETURN          shift and go to state 27
    FUNCTION        shift and go to state 28

    instruccion                    shift and go to state 29
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    call_function_pro              shift and go to state 16
    sumadores                      shift and go to state 17

state 204

    (56) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON . inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (58) inDec_pro -> . assig_pro
    (59) inDec_pro -> . sumadores
    (50) assig_pro -> . LITERAL IGUAL a
    (106) sumadores -> . LITERAL MAS MAS
    (107) sumadores -> . LITERAL MENOS MENOS

    LITERAL         shift and go to state 225

    inDec_pro                      shift and go to state 222
    assig_pro                      shift and go to state 223
    sumadores                      shift and go to state 224

state 205

    (57) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON . inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (58) inDec_pro -> . assig_pro
    (59) inDec_pro -> . sumadores
    (50) assig_pro -> . LITERAL IGUAL a
    (106) sumadores -> . LITERAL MAS MAS
    (107) sumadores -> . LITERAL MENOS MENOS

    LITERAL         shift and go to state 225

    assig_pro                      shift and go to state 223
    inDec_pro                      shift and go to state 226
    sumadores                      shift and go to state 224

state 206

    (60) for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . call_function_pro sc
    (17) instruccion -> . sumadores sc
    (63) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (39) declaration_instruction -> . LET declaracion_list
    (50) assig_pro -> . LITERAL IGUAL a
    (51) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (55) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (56) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (57) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (60) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (34) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (30) continue_pro -> . CONTINUE
    (31) break_pro -> . BREAK
    (32) return_pro -> . RETURN
    (33) return_pro -> . RETURN a
    (20) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (21) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (106) sumadores -> . LITERAL MAS MAS
    (107) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 227
    CONSOLE         shift and go to state 18
    LET             shift and go to state 19
    LITERAL         shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    INTERFACE       shift and go to state 24
    CONTINUE        shift and go to state 25
    BREAK           shift and go to state 26
    RETURN          shift and go to state 27
    FUNCTION        shift and go to state 28

    instruccion                    shift and go to state 29
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    call_function_pro              shift and go to state 16
    sumadores                      shift and go to state 17

state 207

    (61) for_each_dec -> LET LITERAL OF a .
    (66) a -> a . OR b

    R_PAREN         reduce using rule 61 (for_each_dec -> LET LITERAL OF a .)
    OR              shift and go to state 100


state 208

    (62) for_each_dec -> LET LITERAL COLON type . OF a
    (42) assignacion_instruction -> LITERAL COLON type . IGUAL a
    (43) assignacion_instruction -> LITERAL COLON type .

    OF              shift and go to state 228
    IGUAL           shift and go to state 178
    COMA            reduce using rule 43 (assignacion_instruction -> LITERAL COLON type .)
    SEMI_COLON      reduce using rule 43 (assignacion_instruction -> LITERAL COLON type .)


state 209

    (37) interface_atributo -> LITERAL COLON . type
    (45) type -> . NUMBER
    (46) type -> . STRING
    (47) type -> . BOOLEAN
    (48) type -> . ANY
    (49) type -> . LITERAL

    NUMBER          shift and go to state 129
    STRING          shift and go to state 130
    BOOLEAN         shift and go to state 131
    ANY             shift and go to state 132
    LITERAL         shift and go to state 127

    type                           shift and go to state 229

state 210

    (35) interface_atributos -> interface_atributos interface_atributo sc .

    R_LLAVE         reduce using rule 35 (interface_atributos -> interface_atributos interface_atributo sc .)
    LITERAL         reduce using rule 35 (interface_atributos -> interface_atributos interface_atributo sc .)


state 211

    (90) g -> h PUNTO nativeFun L_PAREN expresion . R_PAREN
    (64) expresion -> expresion . COMA a

    R_PAREN         shift and go to state 230
    COMA            shift and go to state 200


state 212

    (91) g -> h PUNTO nativeFun L_PAREN R_PAREN .

    TIMES           reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    DIVIDE          reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    MOD             reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    POTENCIA        reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    MAS             reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    MENOS           reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    DISTINTO_QUE    reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    MENOR_QUE       reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    MENOR_IGUAL_QUE reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    MAYOR_QUE       reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    MAYOR_IGUAL_QUE reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    TRIPLE_IGUAL    reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    AND             reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    OR              reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    SEMI_COLON      reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    CONSOLE         reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    LET             reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    LITERAL         reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    IF              reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    WHILE           reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    FOR             reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    INTERFACE       reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    CONTINUE        reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    BREAK           reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    RETURN          reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    FUNCTION        reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    $end            reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    R_LLAVE         reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    R_PAREN         reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    COMA            reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)
    R_CORCHETE      reduce using rule 91 (g -> h PUNTO nativeFun L_PAREN R_PAREN .)


state 213

    (104) dimensions -> dimensions L_CORCHETE a R_CORCHETE .

    L_CORCHETE      reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    PUNTO           reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    TIMES           reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    DIVIDE          reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    MOD             reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    POTENCIA        reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    MAS             reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    MENOS           reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    DISTINTO_QUE    reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    MENOR_QUE       reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    MENOR_IGUAL_QUE reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    MAYOR_QUE       reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    MAYOR_IGUAL_QUE reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    TRIPLE_IGUAL    reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    AND             reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    OR              reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    SEMI_COLON      reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    CONSOLE         reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    LET             reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    LITERAL         reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    IF              reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    WHILE           reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    FOR             reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    INTERFACE       reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    CONTINUE        reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    BREAK           reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    RETURN          reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    FUNCTION        reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    $end            reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    R_LLAVE         reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    R_PAREN         reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    COMA            reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    R_CORCHETE      reduce using rule 104 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)


state 214

    (109) atributos_assi -> atributos_assi COMA LITERAL COLON . a
    (66) a -> . a OR b
    (67) a -> . b
    (68) b -> . b AND c
    (69) b -> . c
    (70) c -> . NOT d
    (71) c -> . d
    (72) d -> . d DISTINTO_QUE e
    (73) d -> . d MENOR_QUE e
    (74) d -> . d MENOR_IGUAL_QUE e
    (75) d -> . d MAYOR_QUE e
    (76) d -> . d MAYOR_IGUAL_QUE e
    (77) d -> . d TRIPLE_IGUAL e
    (78) d -> . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 60
    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    a                              shift and go to state 231
    b                              shift and go to state 58
    c                              shift and go to state 59
    d                              shift and go to state 61
    e                              shift and go to state 62
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 215

    (28) parameter_pro -> LITERAL COLON type .

    R_PAREN         reduce using rule 28 (parameter_pro -> LITERAL COLON type .)
    COMA            reduce using rule 28 (parameter_pro -> LITERAL COLON type .)


state 216

    (20) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . call_function_pro sc
    (17) instruccion -> . sumadores sc
    (63) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (39) declaration_instruction -> . LET declaracion_list
    (50) assig_pro -> . LITERAL IGUAL a
    (51) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (55) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (56) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (57) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (60) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (34) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (30) continue_pro -> . CONTINUE
    (31) break_pro -> . BREAK
    (32) return_pro -> . RETURN
    (33) return_pro -> . RETURN a
    (20) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (21) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (106) sumadores -> . LITERAL MAS MAS
    (107) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 18
    LET             shift and go to state 19
    LITERAL         shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    INTERFACE       shift and go to state 24
    CONTINUE        shift and go to state 25
    BREAK           shift and go to state 26
    RETURN          shift and go to state 27
    FUNCTION        shift and go to state 28

    instrucciones                  shift and go to state 232
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    call_function_pro              shift and go to state 16
    sumadores                      shift and go to state 17

state 217

    (26) parameters_pro -> parameters_pro COMA parameter_pro .

    R_PAREN         reduce using rule 26 (parameters_pro -> parameters_pro COMA parameter_pro .)
    COMA            reduce using rule 26 (parameters_pro -> parameters_pro COMA parameter_pro .)


state 218

    (21) function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . call_function_pro sc
    (17) instruccion -> . sumadores sc
    (63) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (39) declaration_instruction -> . LET declaracion_list
    (50) assig_pro -> . LITERAL IGUAL a
    (51) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (55) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (56) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (57) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (60) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (34) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (30) continue_pro -> . CONTINUE
    (31) break_pro -> . BREAK
    (32) return_pro -> . RETURN
    (33) return_pro -> . RETURN a
    (20) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (21) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (106) sumadores -> . LITERAL MAS MAS
    (107) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 233
    CONSOLE         shift and go to state 18
    LET             shift and go to state 19
    LITERAL         shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    INTERFACE       shift and go to state 24
    CONTINUE        shift and go to state 25
    BREAK           shift and go to state 26
    RETURN          shift and go to state 27
    FUNCTION        shift and go to state 28

    instruccion                    shift and go to state 29
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    call_function_pro              shift and go to state 16
    sumadores                      shift and go to state 17

state 219

    (64) expresion -> expresion COMA a .
    (66) a -> a . OR b

    R_PAREN         reduce using rule 64 (expresion -> expresion COMA a .)
    COMA            reduce using rule 64 (expresion -> expresion COMA a .)
    OR              shift and go to state 100


state 220

    (51) if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE . else_pro
    (52) else_pro -> . ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (53) else_pro -> . ELSE L_LLAVE instrucciones R_LLAVE
    (54) else_pro -> .

    ELSE            shift and go to state 235
    SEMI_COLON      reduce using rule 54 (else_pro -> .)
    CONSOLE         reduce using rule 54 (else_pro -> .)
    LET             reduce using rule 54 (else_pro -> .)
    LITERAL         reduce using rule 54 (else_pro -> .)
    IF              reduce using rule 54 (else_pro -> .)
    WHILE           reduce using rule 54 (else_pro -> .)
    FOR             reduce using rule 54 (else_pro -> .)
    INTERFACE       reduce using rule 54 (else_pro -> .)
    CONTINUE        reduce using rule 54 (else_pro -> .)
    BREAK           reduce using rule 54 (else_pro -> .)
    RETURN          reduce using rule 54 (else_pro -> .)
    FUNCTION        reduce using rule 54 (else_pro -> .)
    $end            reduce using rule 54 (else_pro -> .)
    R_LLAVE         reduce using rule 54 (else_pro -> .)

    else_pro                       shift and go to state 234

state 221

    (55) while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 55 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 55 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 55 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 55 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 55 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 55 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 55 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 55 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONTINUE        reduce using rule 55 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    BREAK           reduce using rule 55 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    RETURN          reduce using rule 55 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FUNCTION        reduce using rule 55 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 55 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 55 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 222

    (56) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro . R_PAREN L_LLAVE instrucciones R_LLAVE

    R_PAREN         shift and go to state 236


state 223

    (58) inDec_pro -> assig_pro .

    R_PAREN         reduce using rule 58 (inDec_pro -> assig_pro .)


state 224

    (59) inDec_pro -> sumadores .

    R_PAREN         reduce using rule 59 (inDec_pro -> sumadores .)


state 225

    (50) assig_pro -> LITERAL . IGUAL a
    (106) sumadores -> LITERAL . MAS MAS
    (107) sumadores -> LITERAL . MENOS MENOS

    IGUAL           shift and go to state 49
    MAS             shift and go to state 51
    MENOS           shift and go to state 52


state 226

    (57) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro . R_PAREN L_LLAVE instrucciones R_LLAVE

    R_PAREN         shift and go to state 237


state 227

    (60) for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 60 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 60 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 60 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 60 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 60 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 60 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 60 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 60 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONTINUE        reduce using rule 60 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    BREAK           reduce using rule 60 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    RETURN          reduce using rule 60 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FUNCTION        reduce using rule 60 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 60 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 60 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 228

    (62) for_each_dec -> LET LITERAL COLON type OF . a
    (66) a -> . a OR b
    (67) a -> . b
    (68) b -> . b AND c
    (69) b -> . c
    (70) c -> . NOT d
    (71) c -> . d
    (72) d -> . d DISTINTO_QUE e
    (73) d -> . d MENOR_QUE e
    (74) d -> . d MENOR_IGUAL_QUE e
    (75) d -> . d MAYOR_QUE e
    (76) d -> . d MAYOR_IGUAL_QUE e
    (77) d -> . d TRIPLE_IGUAL e
    (78) d -> . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 60
    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    a                              shift and go to state 238
    b                              shift and go to state 58
    c                              shift and go to state 59
    d                              shift and go to state 61
    e                              shift and go to state 62
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 229

    (37) interface_atributo -> LITERAL COLON type .

    SEMI_COLON      reduce using rule 37 (interface_atributo -> LITERAL COLON type .)
    R_LLAVE         reduce using rule 37 (interface_atributo -> LITERAL COLON type .)
    LITERAL         reduce using rule 37 (interface_atributo -> LITERAL COLON type .)


state 230

    (90) g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .

    TIMES           reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    DIVIDE          reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MOD             reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    POTENCIA        reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MAS             reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MENOS           reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    DISTINTO_QUE    reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MENOR_QUE       reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MENOR_IGUAL_QUE reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MAYOR_QUE       reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MAYOR_IGUAL_QUE reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    TRIPLE_IGUAL    reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    AND             reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    OR              reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    SEMI_COLON      reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    CONSOLE         reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    LET             reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    LITERAL         reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    IF              reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    WHILE           reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    FOR             reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    INTERFACE       reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    CONTINUE        reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    BREAK           reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    RETURN          reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    FUNCTION        reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    $end            reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    R_LLAVE         reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    R_PAREN         reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    COMA            reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)
    R_CORCHETE      reduce using rule 90 (g -> h PUNTO nativeFun L_PAREN expresion R_PAREN .)


state 231

    (109) atributos_assi -> atributos_assi COMA LITERAL COLON a .
    (66) a -> a . OR b

    R_LLAVE         reduce using rule 109 (atributos_assi -> atributos_assi COMA LITERAL COLON a .)
    COMA            reduce using rule 109 (atributos_assi -> atributos_assi COMA LITERAL COLON a .)
    OR              shift and go to state 100


state 232

    (20) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . call_function_pro sc
    (17) instruccion -> . sumadores sc
    (63) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (39) declaration_instruction -> . LET declaracion_list
    (50) assig_pro -> . LITERAL IGUAL a
    (51) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (55) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (56) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (57) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (60) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (34) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (30) continue_pro -> . CONTINUE
    (31) break_pro -> . BREAK
    (32) return_pro -> . RETURN
    (33) return_pro -> . RETURN a
    (20) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (21) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (106) sumadores -> . LITERAL MAS MAS
    (107) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 239
    CONSOLE         shift and go to state 18
    LET             shift and go to state 19
    LITERAL         shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    INTERFACE       shift and go to state 24
    CONTINUE        shift and go to state 25
    BREAK           shift and go to state 26
    RETURN          shift and go to state 27
    FUNCTION        shift and go to state 28

    instruccion                    shift and go to state 29
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    call_function_pro              shift and go to state 16
    sumadores                      shift and go to state 17

state 233

    (21) function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 21 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 21 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 21 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 21 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 21 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 21 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 21 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 21 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONTINUE        reduce using rule 21 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    BREAK           reduce using rule 21 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    RETURN          reduce using rule 21 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FUNCTION        reduce using rule 21 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 21 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 21 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 234

    (51) if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .

    SEMI_COLON      reduce using rule 51 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    CONSOLE         reduce using rule 51 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    LET             reduce using rule 51 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    LITERAL         reduce using rule 51 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    IF              reduce using rule 51 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    WHILE           reduce using rule 51 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    FOR             reduce using rule 51 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    INTERFACE       reduce using rule 51 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    CONTINUE        reduce using rule 51 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    BREAK           reduce using rule 51 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    RETURN          reduce using rule 51 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    FUNCTION        reduce using rule 51 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    $end            reduce using rule 51 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    R_LLAVE         reduce using rule 51 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)


state 235

    (52) else_pro -> ELSE . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (53) else_pro -> ELSE . L_LLAVE instrucciones R_LLAVE

    IF              shift and go to state 240
    L_LLAVE         shift and go to state 241


state 236

    (56) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 242


state 237

    (57) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 243


state 238

    (62) for_each_dec -> LET LITERAL COLON type OF a .
    (66) a -> a . OR b

    R_PAREN         reduce using rule 62 (for_each_dec -> LET LITERAL COLON type OF a .)
    OR              shift and go to state 100


state 239

    (20) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONTINUE        reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    BREAK           reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    RETURN          reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FUNCTION        reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 20 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 240

    (52) else_pro -> ELSE IF . L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro

    L_PAREN         shift and go to state 244


state 241

    (53) else_pro -> ELSE L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . call_function_pro sc
    (17) instruccion -> . sumadores sc
    (63) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (39) declaration_instruction -> . LET declaracion_list
    (50) assig_pro -> . LITERAL IGUAL a
    (51) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (55) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (56) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (57) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (60) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (34) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (30) continue_pro -> . CONTINUE
    (31) break_pro -> . BREAK
    (32) return_pro -> . RETURN
    (33) return_pro -> . RETURN a
    (20) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (21) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (106) sumadores -> . LITERAL MAS MAS
    (107) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 18
    LET             shift and go to state 19
    LITERAL         shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    INTERFACE       shift and go to state 24
    CONTINUE        shift and go to state 25
    BREAK           shift and go to state 26
    RETURN          shift and go to state 27
    FUNCTION        shift and go to state 28

    instrucciones                  shift and go to state 245
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    call_function_pro              shift and go to state 16
    sumadores                      shift and go to state 17

state 242

    (56) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . call_function_pro sc
    (17) instruccion -> . sumadores sc
    (63) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (39) declaration_instruction -> . LET declaracion_list
    (50) assig_pro -> . LITERAL IGUAL a
    (51) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (55) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (56) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (57) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (60) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (34) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (30) continue_pro -> . CONTINUE
    (31) break_pro -> . BREAK
    (32) return_pro -> . RETURN
    (33) return_pro -> . RETURN a
    (20) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (21) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (106) sumadores -> . LITERAL MAS MAS
    (107) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 18
    LET             shift and go to state 19
    LITERAL         shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    INTERFACE       shift and go to state 24
    CONTINUE        shift and go to state 25
    BREAK           shift and go to state 26
    RETURN          shift and go to state 27
    FUNCTION        shift and go to state 28

    declaration_instruction        shift and go to state 5
    instrucciones                  shift and go to state 246
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    call_function_pro              shift and go to state 16
    sumadores                      shift and go to state 17

state 243

    (57) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . call_function_pro sc
    (17) instruccion -> . sumadores sc
    (63) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (39) declaration_instruction -> . LET declaracion_list
    (50) assig_pro -> . LITERAL IGUAL a
    (51) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (55) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (56) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (57) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (60) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (34) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (30) continue_pro -> . CONTINUE
    (31) break_pro -> . BREAK
    (32) return_pro -> . RETURN
    (33) return_pro -> . RETURN a
    (20) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (21) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (106) sumadores -> . LITERAL MAS MAS
    (107) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 18
    LET             shift and go to state 19
    LITERAL         shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    INTERFACE       shift and go to state 24
    CONTINUE        shift and go to state 25
    BREAK           shift and go to state 26
    RETURN          shift and go to state 27
    FUNCTION        shift and go to state 28

    assig_pro                      shift and go to state 6
    instrucciones                  shift and go to state 247
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    call_function_pro              shift and go to state 16
    sumadores                      shift and go to state 17

state 244

    (52) else_pro -> ELSE IF L_PAREN . a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) a -> . a OR b
    (67) a -> . b
    (68) b -> . b AND c
    (69) b -> . c
    (70) c -> . NOT d
    (71) c -> . d
    (72) d -> . d DISTINTO_QUE e
    (73) d -> . d MENOR_QUE e
    (74) d -> . d MENOR_IGUAL_QUE e
    (75) d -> . d MAYOR_QUE e
    (76) d -> . d MAYOR_IGUAL_QUE e
    (77) d -> . d TRIPLE_IGUAL e
    (78) d -> . e
    (79) e -> . e MAS f
    (80) e -> . e MENOS f
    (81) e -> . f
    (82) f -> . MENOS g
    (83) f -> . MAS g
    (84) f -> . g
    (85) g -> . g TIMES h
    (86) g -> . g DIVIDE h
    (87) g -> . g MOD h
    (88) g -> . g POTENCIA h
    (89) g -> . h
    (90) g -> . h PUNTO nativeFun L_PAREN expresion R_PAREN
    (91) g -> . h PUNTO nativeFun L_PAREN R_PAREN
    (92) h -> . ENTERO
    (93) h -> . DECIMAL
    (94) h -> . CADENA
    (95) h -> . LITERAL
    (96) h -> . TRUE
    (97) h -> . FALSE
    (98) h -> . call_function_pro
    (99) h -> . array_pro
    (100) h -> . interface_assi
    (101) h -> . L_PAREN a R_PAREN
    (102) h -> . array_val_pro
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (111) array_pro -> . L_CORCHETE values R_CORCHETE
    (108) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (103) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 60
    MENOS           shift and go to state 65
    MAS             shift and go to state 63
    ENTERO          shift and go to state 69
    DECIMAL         shift and go to state 70
    CADENA          shift and go to state 71
    LITERAL         shift and go to state 72
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    L_PAREN         shift and go to state 68
    L_CORCHETE      shift and go to state 79
    L_LLAVE         shift and go to state 80

    a                              shift and go to state 248
    b                              shift and go to state 58
    c                              shift and go to state 59
    d                              shift and go to state 61
    e                              shift and go to state 62
    f                              shift and go to state 64
    g                              shift and go to state 66
    h                              shift and go to state 67
    call_function_pro              shift and go to state 75
    array_pro                      shift and go to state 76
    interface_assi                 shift and go to state 77
    array_val_pro                  shift and go to state 78

state 245

    (53) else_pro -> ELSE L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . call_function_pro sc
    (17) instruccion -> . sumadores sc
    (63) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (39) declaration_instruction -> . LET declaracion_list
    (50) assig_pro -> . LITERAL IGUAL a
    (51) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (55) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (56) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (57) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (60) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (34) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (30) continue_pro -> . CONTINUE
    (31) break_pro -> . BREAK
    (32) return_pro -> . RETURN
    (33) return_pro -> . RETURN a
    (20) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (21) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (106) sumadores -> . LITERAL MAS MAS
    (107) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 249
    CONSOLE         shift and go to state 18
    LET             shift and go to state 19
    LITERAL         shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    INTERFACE       shift and go to state 24
    CONTINUE        shift and go to state 25
    BREAK           shift and go to state 26
    RETURN          shift and go to state 27
    FUNCTION        shift and go to state 28

    instruccion                    shift and go to state 29
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    call_function_pro              shift and go to state 16
    sumadores                      shift and go to state 17

state 246

    (56) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . call_function_pro sc
    (17) instruccion -> . sumadores sc
    (63) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (39) declaration_instruction -> . LET declaracion_list
    (50) assig_pro -> . LITERAL IGUAL a
    (51) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (55) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (56) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (57) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (60) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (34) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (30) continue_pro -> . CONTINUE
    (31) break_pro -> . BREAK
    (32) return_pro -> . RETURN
    (33) return_pro -> . RETURN a
    (20) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (21) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (106) sumadores -> . LITERAL MAS MAS
    (107) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 250
    CONSOLE         shift and go to state 18
    LET             shift and go to state 19
    LITERAL         shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    INTERFACE       shift and go to state 24
    CONTINUE        shift and go to state 25
    BREAK           shift and go to state 26
    RETURN          shift and go to state 27
    FUNCTION        shift and go to state 28

    declaration_instruction        shift and go to state 5
    instruccion                    shift and go to state 29
    console_pro                    shift and go to state 4
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    call_function_pro              shift and go to state 16
    sumadores                      shift and go to state 17

state 247

    (57) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . call_function_pro sc
    (17) instruccion -> . sumadores sc
    (63) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (39) declaration_instruction -> . LET declaracion_list
    (50) assig_pro -> . LITERAL IGUAL a
    (51) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (55) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (56) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (57) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (60) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (34) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (30) continue_pro -> . CONTINUE
    (31) break_pro -> . BREAK
    (32) return_pro -> . RETURN
    (33) return_pro -> . RETURN a
    (20) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (21) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (106) sumadores -> . LITERAL MAS MAS
    (107) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 251
    CONSOLE         shift and go to state 18
    LET             shift and go to state 19
    LITERAL         shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    INTERFACE       shift and go to state 24
    CONTINUE        shift and go to state 25
    BREAK           shift and go to state 26
    RETURN          shift and go to state 27
    FUNCTION        shift and go to state 28

    assig_pro                      shift and go to state 6
    instruccion                    shift and go to state 29
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    call_function_pro              shift and go to state 16
    sumadores                      shift and go to state 17

state 248

    (52) else_pro -> ELSE IF L_PAREN a . R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) a -> a . OR b

    R_PAREN         shift and go to state 252
    OR              shift and go to state 100


state 249

    (53) else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 53 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 53 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 53 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 53 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 53 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 53 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 53 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 53 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    CONTINUE        reduce using rule 53 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    BREAK           reduce using rule 53 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    RETURN          reduce using rule 53 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    FUNCTION        reduce using rule 53 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 53 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 53 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)


state 250

    (56) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 56 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 56 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 56 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 56 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 56 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 56 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 56 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 56 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONTINUE        reduce using rule 56 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    BREAK           reduce using rule 56 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    RETURN          reduce using rule 56 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FUNCTION        reduce using rule 56 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 56 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 56 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 251

    (57) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 57 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 57 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 57 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 57 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 57 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 57 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 57 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 57 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONTINUE        reduce using rule 57 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    BREAK           reduce using rule 57 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    RETURN          reduce using rule 57 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FUNCTION        reduce using rule 57 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 57 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 57 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 252

    (52) else_pro -> ELSE IF L_PAREN a R_PAREN . L_LLAVE instrucciones R_LLAVE else_pro

    L_LLAVE         shift and go to state 253


state 253

    (52) else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE . instrucciones R_LLAVE else_pro
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . call_function_pro sc
    (17) instruccion -> . sumadores sc
    (63) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (39) declaration_instruction -> . LET declaracion_list
    (50) assig_pro -> . LITERAL IGUAL a
    (51) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (55) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (56) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (57) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (60) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (34) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (30) continue_pro -> . CONTINUE
    (31) break_pro -> . BREAK
    (32) return_pro -> . RETURN
    (33) return_pro -> . RETURN a
    (20) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (21) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (106) sumadores -> . LITERAL MAS MAS
    (107) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 18
    LET             shift and go to state 19
    LITERAL         shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    INTERFACE       shift and go to state 24
    CONTINUE        shift and go to state 25
    BREAK           shift and go to state 26
    RETURN          shift and go to state 27
    FUNCTION        shift and go to state 28

    instrucciones                  shift and go to state 254
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    call_function_pro              shift and go to state 16
    sumadores                      shift and go to state 17

state 254

    (52) else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones . R_LLAVE else_pro
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . continue_pro sc
    (13) instruccion -> . break_pro sc
    (14) instruccion -> . return_pro sc
    (15) instruccion -> . function_pro sc
    (16) instruccion -> . call_function_pro sc
    (17) instruccion -> . sumadores sc
    (63) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (39) declaration_instruction -> . LET declaracion_list
    (50) assig_pro -> . LITERAL IGUAL a
    (51) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (55) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (56) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (57) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (60) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (34) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (30) continue_pro -> . CONTINUE
    (31) break_pro -> . BREAK
    (32) return_pro -> . RETURN
    (33) return_pro -> . RETURN a
    (20) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (21) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (22) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (23) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (106) sumadores -> . LITERAL MAS MAS
    (107) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 255
    CONSOLE         shift and go to state 18
    LET             shift and go to state 19
    LITERAL         shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    INTERFACE       shift and go to state 24
    CONTINUE        shift and go to state 25
    BREAK           shift and go to state 26
    RETURN          shift and go to state 27
    FUNCTION        shift and go to state 28

    instruccion                    shift and go to state 29
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    continue_pro                   shift and go to state 12
    break_pro                      shift and go to state 13
    return_pro                     shift and go to state 14
    function_pro                   shift and go to state 15
    call_function_pro              shift and go to state 16
    sumadores                      shift and go to state 17

state 255

    (52) else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE . else_pro
    (52) else_pro -> . ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (53) else_pro -> . ELSE L_LLAVE instrucciones R_LLAVE
    (54) else_pro -> .

    ELSE            shift and go to state 235
    SEMI_COLON      reduce using rule 54 (else_pro -> .)
    CONSOLE         reduce using rule 54 (else_pro -> .)
    LET             reduce using rule 54 (else_pro -> .)
    LITERAL         reduce using rule 54 (else_pro -> .)
    IF              reduce using rule 54 (else_pro -> .)
    WHILE           reduce using rule 54 (else_pro -> .)
    FOR             reduce using rule 54 (else_pro -> .)
    INTERFACE       reduce using rule 54 (else_pro -> .)
    CONTINUE        reduce using rule 54 (else_pro -> .)
    BREAK           reduce using rule 54 (else_pro -> .)
    RETURN          reduce using rule 54 (else_pro -> .)
    FUNCTION        reduce using rule 54 (else_pro -> .)
    $end            reduce using rule 54 (else_pro -> .)
    R_LLAVE         reduce using rule 54 (else_pro -> .)

    else_pro                       shift and go to state 256

state 256

    (52) else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .

    SEMI_COLON      reduce using rule 52 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    CONSOLE         reduce using rule 52 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    LET             reduce using rule 52 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    LITERAL         reduce using rule 52 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    IF              reduce using rule 52 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    WHILE           reduce using rule 52 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    FOR             reduce using rule 52 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    INTERFACE       reduce using rule 52 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    CONTINUE        reduce using rule 52 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    BREAK           reduce using rule 52 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    RETURN          reduce using rule 52 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    FUNCTION        reduce using rule 52 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    $end            reduce using rule 52 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    R_LLAVE         reduce using rule 52 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LITERAL in state 27 resolved as shift
