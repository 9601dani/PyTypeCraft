Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BREAK
    CONTINUE
    FUNCTION
    L_CORCHETE
    NULL
    RETURN
    R_CORCHETE

Grammar

Rule 0     S' -> init
Rule 1     init -> instrucciones
Rule 2     instrucciones -> instrucciones instruccion
Rule 3     instrucciones -> instruccion
Rule 4     instruccion -> console_pro sc
Rule 5     instruccion -> declaration_instruction sc
Rule 6     instruccion -> assig_pro sc
Rule 7     instruccion -> if_pro sc
Rule 8     instruccion -> while_pro sc
Rule 9     instruccion -> for_pro sc
Rule 10    instruccion -> for_each_pro sc
Rule 11    instruccion -> interface_pro sc
Rule 12    instruccion -> sumadores sc
Rule 13    sc -> SEMI_COLON
Rule 14    sc -> <empty>
Rule 15    interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
Rule 16    interface_atributos -> interface_atributos interface_atributo sc
Rule 17    interface_atributos -> <empty>
Rule 18    interface_atributo -> LITERAL COLON type
Rule 19    interface_atributo -> LITERAL
Rule 20    declaration_instruction -> LET declaracion_list
Rule 21    declaracion_list -> declaracion_list COMA assignacion_instruction
Rule 22    declaracion_list -> assignacion_instruction
Rule 23    assignacion_instruction -> LITERAL COLON type IGUAL a
Rule 24    assignacion_instruction -> LITERAL COLON type
Rule 25    assignacion_instruction -> LITERAL IGUAL a
Rule 26    type -> NUMBER
Rule 27    type -> STRING
Rule 28    type -> BOOLEAN
Rule 29    type -> ANY
Rule 30    type -> LITERAL
Rule 31    assig_pro -> LITERAL IGUAL a
Rule 32    if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
Rule 33    else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
Rule 34    else_pro -> ELSE L_LLAVE instrucciones R_LLAVE
Rule 35    else_pro -> <empty>
Rule 36    while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 37    for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 38    for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 39    for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 40    for_each_dec -> LET LITERAL OF a
Rule 41    for_each_dec -> LET LITERAL COLON type OF a
Rule 42    console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
Rule 43    expresion -> expresion COMA a
Rule 44    expresion -> a
Rule 45    a -> a OR b
Rule 46    a -> b
Rule 47    b -> b AND c
Rule 48    b -> c
Rule 49    c -> NOT d
Rule 50    c -> d
Rule 51    d -> d DISTINTO_QUE e
Rule 52    d -> d MENOR_QUE e
Rule 53    d -> d MENOR_IGUAL_QUE e
Rule 54    d -> d MAYOR_QUE e
Rule 55    d -> d MAYOR_IGUAL_QUE e
Rule 56    d -> d TRIPLE_IGUAL e
Rule 57    d -> e
Rule 58    e -> e MAS f
Rule 59    e -> e MENOS f
Rule 60    e -> f
Rule 61    f -> f TIMES g
Rule 62    f -> f DIVIDE g
Rule 63    f -> f MOD g
Rule 64    f -> f POTENCIA g
Rule 65    f -> g
Rule 66    f -> g PUNTO nativeFun L_PAREN expresion R_PAREN
Rule 67    g -> ENTERO
Rule 68    g -> DECIMAL
Rule 69    g -> CADENA
Rule 70    g -> LITERAL
Rule 71    g -> interface_assi
Rule 72    g -> L_PAREN a R_PAREN
Rule 73    sumadores -> LITERAL MAS MAS
Rule 74    sumadores -> LITERAL MENOS MENOS
Rule 75    interface_assi -> L_LLAVE atributos_assi R_LLAVE
Rule 76    atributos_assi -> atributos_assi COMA LITERAL COLON a
Rule 77    atributos_assi -> LITERAL COLON a
Rule 78    nativeFun -> TOSTRING
Rule 79    nativeFun -> TOFIXED
Rule 80    nativeFun -> TOEXPONENTIAL
Rule 81    nativeFun -> TOLOWERCASE
Rule 82    nativeFun -> TOUPPERCASE
Rule 83    nativeFun -> SPLIT
Rule 84    nativeFun -> CONCAT

Terminals, with rules where they appear

AND                  : 47
ANY                  : 29
BOOLEAN              : 28
BREAK                : 
CADENA               : 69
COLON                : 18 23 24 41 76 77
COMA                 : 21 43 76
CONCAT               : 84
CONSOLE              : 42
CONTINUE             : 
DECIMAL              : 68
DISTINTO_QUE         : 51
DIVIDE               : 62
ELSE                 : 33 34
ENTERO               : 67
FOR                  : 37 38 39
FUNCTION             : 
IF                   : 32 33
IGUAL                : 23 25 31
INTERFACE            : 15
LET                  : 20 40 41
LITERAL              : 15 18 19 23 24 25 30 31 40 41 70 73 74 76 77
LOG                  : 42
L_CORCHETE           : 
L_LLAVE              : 15 32 33 34 36 37 38 39 75
L_PAREN              : 32 33 36 37 38 39 42 66 72
MAS                  : 58 73 73
MAYOR_IGUAL_QUE      : 55
MAYOR_QUE            : 54
MENOR_IGUAL_QUE      : 53
MENOR_QUE            : 52
MENOS                : 59 74 74
MOD                  : 63
NOT                  : 49
NULL                 : 
NUMBER               : 26
OF                   : 40 41
OR                   : 45
POTENCIA             : 64
PUNTO                : 42 66
RETURN               : 
R_CORCHETE           : 
R_LLAVE              : 15 32 33 34 36 37 38 39 75
R_PAREN              : 32 33 36 37 38 39 42 66 72
SEMI_COLON           : 13 37 37 38 38
SPLIT                : 83
STRING               : 27
TIMES                : 61
TOEXPONENTIAL        : 80
TOFIXED              : 79
TOLOWERCASE          : 81
TOSTRING             : 78
TOUPPERCASE          : 82
TRIPLE_IGUAL         : 56
WHILE                : 36
error                : 

Nonterminals, with rules where they appear

a                    : 23 25 31 32 33 36 37 38 40 41 43 44 45 72 76 77
assig_pro            : 6 37 38 38
assignacion_instruction : 21 22
atributos_assi       : 75 76
b                    : 45 46 47
c                    : 47 48
console_pro          : 4
d                    : 49 50 51 52 53 54 55 56
declaracion_list     : 20 21
declaration_instruction : 5 37
e                    : 51 52 53 54 55 56 57 58 59
else_pro             : 32 33
expresion            : 42 43 66
f                    : 58 59 60 61 62 63 64
for_each_dec         : 39
for_each_pro         : 10
for_pro              : 9
g                    : 61 62 63 64 65 66
if_pro               : 7
init                 : 0
instruccion          : 2 3
instrucciones        : 1 2 32 33 34 36 37 38 39
interface_assi       : 71
interface_atributo   : 16
interface_atributos  : 15 16
interface_pro        : 11
nativeFun            : 66
sc                   : 4 5 6 7 8 9 10 11 12 16
sumadores            : 12
type                 : 18 23 24 41
while_pro            : 8

Parsing method: LALR

state 0

    (0) S' -> . init
    (1) init -> . instrucciones
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . sumadores sc
    (42) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (20) declaration_instruction -> . LET declaracion_list
    (31) assig_pro -> . LITERAL IGUAL a
    (32) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (36) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (37) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (38) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (39) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (15) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (73) sumadores -> . LITERAL MAS MAS
    (74) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 13
    LET             shift and go to state 14
    LITERAL         shift and go to state 15
    IF              shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    INTERFACE       shift and go to state 19

    init                           shift and go to state 1
    instrucciones                  shift and go to state 2
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    sumadores                      shift and go to state 12

state 1

    (0) S' -> init .



state 2

    (1) init -> instrucciones .
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . sumadores sc
    (42) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (20) declaration_instruction -> . LET declaracion_list
    (31) assig_pro -> . LITERAL IGUAL a
    (32) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (36) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (37) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (38) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (39) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (15) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (73) sumadores -> . LITERAL MAS MAS
    (74) sumadores -> . LITERAL MENOS MENOS

    $end            reduce using rule 1 (init -> instrucciones .)
    CONSOLE         shift and go to state 13
    LET             shift and go to state 14
    LITERAL         shift and go to state 15
    IF              shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    INTERFACE       shift and go to state 19

    instruccion                    shift and go to state 20
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    sumadores                      shift and go to state 12

state 3

    (3) instrucciones -> instruccion .

    CONSOLE         reduce using rule 3 (instrucciones -> instruccion .)
    LET             reduce using rule 3 (instrucciones -> instruccion .)
    LITERAL         reduce using rule 3 (instrucciones -> instruccion .)
    IF              reduce using rule 3 (instrucciones -> instruccion .)
    WHILE           reduce using rule 3 (instrucciones -> instruccion .)
    FOR             reduce using rule 3 (instrucciones -> instruccion .)
    INTERFACE       reduce using rule 3 (instrucciones -> instruccion .)
    $end            reduce using rule 3 (instrucciones -> instruccion .)
    R_LLAVE         reduce using rule 3 (instrucciones -> instruccion .)


state 4

    (4) instruccion -> console_pro . sc
    (13) sc -> . SEMI_COLON
    (14) sc -> .

    SEMI_COLON      shift and go to state 22
    CONSOLE         reduce using rule 14 (sc -> .)
    LET             reduce using rule 14 (sc -> .)
    LITERAL         reduce using rule 14 (sc -> .)
    IF              reduce using rule 14 (sc -> .)
    WHILE           reduce using rule 14 (sc -> .)
    FOR             reduce using rule 14 (sc -> .)
    INTERFACE       reduce using rule 14 (sc -> .)
    $end            reduce using rule 14 (sc -> .)
    R_LLAVE         reduce using rule 14 (sc -> .)

    sc                             shift and go to state 21

state 5

    (5) instruccion -> declaration_instruction . sc
    (13) sc -> . SEMI_COLON
    (14) sc -> .

    SEMI_COLON      shift and go to state 22
    CONSOLE         reduce using rule 14 (sc -> .)
    LET             reduce using rule 14 (sc -> .)
    LITERAL         reduce using rule 14 (sc -> .)
    IF              reduce using rule 14 (sc -> .)
    WHILE           reduce using rule 14 (sc -> .)
    FOR             reduce using rule 14 (sc -> .)
    INTERFACE       reduce using rule 14 (sc -> .)
    $end            reduce using rule 14 (sc -> .)
    R_LLAVE         reduce using rule 14 (sc -> .)

    sc                             shift and go to state 23

state 6

    (6) instruccion -> assig_pro . sc
    (13) sc -> . SEMI_COLON
    (14) sc -> .

    SEMI_COLON      shift and go to state 22
    CONSOLE         reduce using rule 14 (sc -> .)
    LET             reduce using rule 14 (sc -> .)
    LITERAL         reduce using rule 14 (sc -> .)
    IF              reduce using rule 14 (sc -> .)
    WHILE           reduce using rule 14 (sc -> .)
    FOR             reduce using rule 14 (sc -> .)
    INTERFACE       reduce using rule 14 (sc -> .)
    $end            reduce using rule 14 (sc -> .)
    R_LLAVE         reduce using rule 14 (sc -> .)

    sc                             shift and go to state 24

state 7

    (7) instruccion -> if_pro . sc
    (13) sc -> . SEMI_COLON
    (14) sc -> .

    SEMI_COLON      shift and go to state 22
    CONSOLE         reduce using rule 14 (sc -> .)
    LET             reduce using rule 14 (sc -> .)
    LITERAL         reduce using rule 14 (sc -> .)
    IF              reduce using rule 14 (sc -> .)
    WHILE           reduce using rule 14 (sc -> .)
    FOR             reduce using rule 14 (sc -> .)
    INTERFACE       reduce using rule 14 (sc -> .)
    $end            reduce using rule 14 (sc -> .)
    R_LLAVE         reduce using rule 14 (sc -> .)

    sc                             shift and go to state 25

state 8

    (8) instruccion -> while_pro . sc
    (13) sc -> . SEMI_COLON
    (14) sc -> .

    SEMI_COLON      shift and go to state 22
    CONSOLE         reduce using rule 14 (sc -> .)
    LET             reduce using rule 14 (sc -> .)
    LITERAL         reduce using rule 14 (sc -> .)
    IF              reduce using rule 14 (sc -> .)
    WHILE           reduce using rule 14 (sc -> .)
    FOR             reduce using rule 14 (sc -> .)
    INTERFACE       reduce using rule 14 (sc -> .)
    $end            reduce using rule 14 (sc -> .)
    R_LLAVE         reduce using rule 14 (sc -> .)

    sc                             shift and go to state 26

state 9

    (9) instruccion -> for_pro . sc
    (13) sc -> . SEMI_COLON
    (14) sc -> .

    SEMI_COLON      shift and go to state 22
    CONSOLE         reduce using rule 14 (sc -> .)
    LET             reduce using rule 14 (sc -> .)
    LITERAL         reduce using rule 14 (sc -> .)
    IF              reduce using rule 14 (sc -> .)
    WHILE           reduce using rule 14 (sc -> .)
    FOR             reduce using rule 14 (sc -> .)
    INTERFACE       reduce using rule 14 (sc -> .)
    $end            reduce using rule 14 (sc -> .)
    R_LLAVE         reduce using rule 14 (sc -> .)

    sc                             shift and go to state 27

state 10

    (10) instruccion -> for_each_pro . sc
    (13) sc -> . SEMI_COLON
    (14) sc -> .

    SEMI_COLON      shift and go to state 22
    CONSOLE         reduce using rule 14 (sc -> .)
    LET             reduce using rule 14 (sc -> .)
    LITERAL         reduce using rule 14 (sc -> .)
    IF              reduce using rule 14 (sc -> .)
    WHILE           reduce using rule 14 (sc -> .)
    FOR             reduce using rule 14 (sc -> .)
    INTERFACE       reduce using rule 14 (sc -> .)
    $end            reduce using rule 14 (sc -> .)
    R_LLAVE         reduce using rule 14 (sc -> .)

    sc                             shift and go to state 28

state 11

    (11) instruccion -> interface_pro . sc
    (13) sc -> . SEMI_COLON
    (14) sc -> .

    SEMI_COLON      shift and go to state 22
    CONSOLE         reduce using rule 14 (sc -> .)
    LET             reduce using rule 14 (sc -> .)
    LITERAL         reduce using rule 14 (sc -> .)
    IF              reduce using rule 14 (sc -> .)
    WHILE           reduce using rule 14 (sc -> .)
    FOR             reduce using rule 14 (sc -> .)
    INTERFACE       reduce using rule 14 (sc -> .)
    $end            reduce using rule 14 (sc -> .)
    R_LLAVE         reduce using rule 14 (sc -> .)

    sc                             shift and go to state 29

state 12

    (12) instruccion -> sumadores . sc
    (13) sc -> . SEMI_COLON
    (14) sc -> .

    SEMI_COLON      shift and go to state 22
    CONSOLE         reduce using rule 14 (sc -> .)
    LET             reduce using rule 14 (sc -> .)
    LITERAL         reduce using rule 14 (sc -> .)
    IF              reduce using rule 14 (sc -> .)
    WHILE           reduce using rule 14 (sc -> .)
    FOR             reduce using rule 14 (sc -> .)
    INTERFACE       reduce using rule 14 (sc -> .)
    $end            reduce using rule 14 (sc -> .)
    R_LLAVE         reduce using rule 14 (sc -> .)

    sc                             shift and go to state 30

state 13

    (42) console_pro -> CONSOLE . PUNTO LOG L_PAREN expresion R_PAREN

    PUNTO           shift and go to state 31


state 14

    (20) declaration_instruction -> LET . declaracion_list
    (21) declaracion_list -> . declaracion_list COMA assignacion_instruction
    (22) declaracion_list -> . assignacion_instruction
    (23) assignacion_instruction -> . LITERAL COLON type IGUAL a
    (24) assignacion_instruction -> . LITERAL COLON type
    (25) assignacion_instruction -> . LITERAL IGUAL a

    LITERAL         shift and go to state 34

    declaracion_list               shift and go to state 32
    assignacion_instruction        shift and go to state 33

state 15

    (31) assig_pro -> LITERAL . IGUAL a
    (73) sumadores -> LITERAL . MAS MAS
    (74) sumadores -> LITERAL . MENOS MENOS

    IGUAL           shift and go to state 35
    MAS             shift and go to state 36
    MENOS           shift and go to state 37


state 16

    (32) if_pro -> IF . L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro

    L_PAREN         shift and go to state 38


state 17

    (36) while_pro -> WHILE . L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE

    L_PAREN         shift and go to state 39


state 18

    (37) for_pro -> FOR . L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (38) for_pro -> FOR . L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (39) for_each_pro -> FOR . L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE

    L_PAREN         shift and go to state 40


state 19

    (15) interface_pro -> INTERFACE . LITERAL L_LLAVE interface_atributos R_LLAVE

    LITERAL         shift and go to state 41


state 20

    (2) instrucciones -> instrucciones instruccion .

    CONSOLE         reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    LET             reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    LITERAL         reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    IF              reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    WHILE           reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    FOR             reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    INTERFACE       reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    $end            reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    R_LLAVE         reduce using rule 2 (instrucciones -> instrucciones instruccion .)


state 21

    (4) instruccion -> console_pro sc .

    CONSOLE         reduce using rule 4 (instruccion -> console_pro sc .)
    LET             reduce using rule 4 (instruccion -> console_pro sc .)
    LITERAL         reduce using rule 4 (instruccion -> console_pro sc .)
    IF              reduce using rule 4 (instruccion -> console_pro sc .)
    WHILE           reduce using rule 4 (instruccion -> console_pro sc .)
    FOR             reduce using rule 4 (instruccion -> console_pro sc .)
    INTERFACE       reduce using rule 4 (instruccion -> console_pro sc .)
    $end            reduce using rule 4 (instruccion -> console_pro sc .)
    R_LLAVE         reduce using rule 4 (instruccion -> console_pro sc .)


state 22

    (13) sc -> SEMI_COLON .

    CONSOLE         reduce using rule 13 (sc -> SEMI_COLON .)
    LET             reduce using rule 13 (sc -> SEMI_COLON .)
    LITERAL         reduce using rule 13 (sc -> SEMI_COLON .)
    IF              reduce using rule 13 (sc -> SEMI_COLON .)
    WHILE           reduce using rule 13 (sc -> SEMI_COLON .)
    FOR             reduce using rule 13 (sc -> SEMI_COLON .)
    INTERFACE       reduce using rule 13 (sc -> SEMI_COLON .)
    $end            reduce using rule 13 (sc -> SEMI_COLON .)
    R_LLAVE         reduce using rule 13 (sc -> SEMI_COLON .)


state 23

    (5) instruccion -> declaration_instruction sc .

    CONSOLE         reduce using rule 5 (instruccion -> declaration_instruction sc .)
    LET             reduce using rule 5 (instruccion -> declaration_instruction sc .)
    LITERAL         reduce using rule 5 (instruccion -> declaration_instruction sc .)
    IF              reduce using rule 5 (instruccion -> declaration_instruction sc .)
    WHILE           reduce using rule 5 (instruccion -> declaration_instruction sc .)
    FOR             reduce using rule 5 (instruccion -> declaration_instruction sc .)
    INTERFACE       reduce using rule 5 (instruccion -> declaration_instruction sc .)
    $end            reduce using rule 5 (instruccion -> declaration_instruction sc .)
    R_LLAVE         reduce using rule 5 (instruccion -> declaration_instruction sc .)


state 24

    (6) instruccion -> assig_pro sc .

    CONSOLE         reduce using rule 6 (instruccion -> assig_pro sc .)
    LET             reduce using rule 6 (instruccion -> assig_pro sc .)
    LITERAL         reduce using rule 6 (instruccion -> assig_pro sc .)
    IF              reduce using rule 6 (instruccion -> assig_pro sc .)
    WHILE           reduce using rule 6 (instruccion -> assig_pro sc .)
    FOR             reduce using rule 6 (instruccion -> assig_pro sc .)
    INTERFACE       reduce using rule 6 (instruccion -> assig_pro sc .)
    $end            reduce using rule 6 (instruccion -> assig_pro sc .)
    R_LLAVE         reduce using rule 6 (instruccion -> assig_pro sc .)


state 25

    (7) instruccion -> if_pro sc .

    CONSOLE         reduce using rule 7 (instruccion -> if_pro sc .)
    LET             reduce using rule 7 (instruccion -> if_pro sc .)
    LITERAL         reduce using rule 7 (instruccion -> if_pro sc .)
    IF              reduce using rule 7 (instruccion -> if_pro sc .)
    WHILE           reduce using rule 7 (instruccion -> if_pro sc .)
    FOR             reduce using rule 7 (instruccion -> if_pro sc .)
    INTERFACE       reduce using rule 7 (instruccion -> if_pro sc .)
    $end            reduce using rule 7 (instruccion -> if_pro sc .)
    R_LLAVE         reduce using rule 7 (instruccion -> if_pro sc .)


state 26

    (8) instruccion -> while_pro sc .

    CONSOLE         reduce using rule 8 (instruccion -> while_pro sc .)
    LET             reduce using rule 8 (instruccion -> while_pro sc .)
    LITERAL         reduce using rule 8 (instruccion -> while_pro sc .)
    IF              reduce using rule 8 (instruccion -> while_pro sc .)
    WHILE           reduce using rule 8 (instruccion -> while_pro sc .)
    FOR             reduce using rule 8 (instruccion -> while_pro sc .)
    INTERFACE       reduce using rule 8 (instruccion -> while_pro sc .)
    $end            reduce using rule 8 (instruccion -> while_pro sc .)
    R_LLAVE         reduce using rule 8 (instruccion -> while_pro sc .)


state 27

    (9) instruccion -> for_pro sc .

    CONSOLE         reduce using rule 9 (instruccion -> for_pro sc .)
    LET             reduce using rule 9 (instruccion -> for_pro sc .)
    LITERAL         reduce using rule 9 (instruccion -> for_pro sc .)
    IF              reduce using rule 9 (instruccion -> for_pro sc .)
    WHILE           reduce using rule 9 (instruccion -> for_pro sc .)
    FOR             reduce using rule 9 (instruccion -> for_pro sc .)
    INTERFACE       reduce using rule 9 (instruccion -> for_pro sc .)
    $end            reduce using rule 9 (instruccion -> for_pro sc .)
    R_LLAVE         reduce using rule 9 (instruccion -> for_pro sc .)


state 28

    (10) instruccion -> for_each_pro sc .

    CONSOLE         reduce using rule 10 (instruccion -> for_each_pro sc .)
    LET             reduce using rule 10 (instruccion -> for_each_pro sc .)
    LITERAL         reduce using rule 10 (instruccion -> for_each_pro sc .)
    IF              reduce using rule 10 (instruccion -> for_each_pro sc .)
    WHILE           reduce using rule 10 (instruccion -> for_each_pro sc .)
    FOR             reduce using rule 10 (instruccion -> for_each_pro sc .)
    INTERFACE       reduce using rule 10 (instruccion -> for_each_pro sc .)
    $end            reduce using rule 10 (instruccion -> for_each_pro sc .)
    R_LLAVE         reduce using rule 10 (instruccion -> for_each_pro sc .)


state 29

    (11) instruccion -> interface_pro sc .

    CONSOLE         reduce using rule 11 (instruccion -> interface_pro sc .)
    LET             reduce using rule 11 (instruccion -> interface_pro sc .)
    LITERAL         reduce using rule 11 (instruccion -> interface_pro sc .)
    IF              reduce using rule 11 (instruccion -> interface_pro sc .)
    WHILE           reduce using rule 11 (instruccion -> interface_pro sc .)
    FOR             reduce using rule 11 (instruccion -> interface_pro sc .)
    INTERFACE       reduce using rule 11 (instruccion -> interface_pro sc .)
    $end            reduce using rule 11 (instruccion -> interface_pro sc .)
    R_LLAVE         reduce using rule 11 (instruccion -> interface_pro sc .)


state 30

    (12) instruccion -> sumadores sc .

    CONSOLE         reduce using rule 12 (instruccion -> sumadores sc .)
    LET             reduce using rule 12 (instruccion -> sumadores sc .)
    LITERAL         reduce using rule 12 (instruccion -> sumadores sc .)
    IF              reduce using rule 12 (instruccion -> sumadores sc .)
    WHILE           reduce using rule 12 (instruccion -> sumadores sc .)
    FOR             reduce using rule 12 (instruccion -> sumadores sc .)
    INTERFACE       reduce using rule 12 (instruccion -> sumadores sc .)
    $end            reduce using rule 12 (instruccion -> sumadores sc .)
    R_LLAVE         reduce using rule 12 (instruccion -> sumadores sc .)


state 31

    (42) console_pro -> CONSOLE PUNTO . LOG L_PAREN expresion R_PAREN

    LOG             shift and go to state 42


state 32

    (20) declaration_instruction -> LET declaracion_list .
    (21) declaracion_list -> declaracion_list . COMA assignacion_instruction

    SEMI_COLON      reduce using rule 20 (declaration_instruction -> LET declaracion_list .)
    CONSOLE         reduce using rule 20 (declaration_instruction -> LET declaracion_list .)
    LET             reduce using rule 20 (declaration_instruction -> LET declaracion_list .)
    LITERAL         reduce using rule 20 (declaration_instruction -> LET declaracion_list .)
    IF              reduce using rule 20 (declaration_instruction -> LET declaracion_list .)
    WHILE           reduce using rule 20 (declaration_instruction -> LET declaracion_list .)
    FOR             reduce using rule 20 (declaration_instruction -> LET declaracion_list .)
    INTERFACE       reduce using rule 20 (declaration_instruction -> LET declaracion_list .)
    $end            reduce using rule 20 (declaration_instruction -> LET declaracion_list .)
    R_LLAVE         reduce using rule 20 (declaration_instruction -> LET declaracion_list .)
    COMA            shift and go to state 43


state 33

    (22) declaracion_list -> assignacion_instruction .

    COMA            reduce using rule 22 (declaracion_list -> assignacion_instruction .)
    SEMI_COLON      reduce using rule 22 (declaracion_list -> assignacion_instruction .)
    CONSOLE         reduce using rule 22 (declaracion_list -> assignacion_instruction .)
    LET             reduce using rule 22 (declaracion_list -> assignacion_instruction .)
    LITERAL         reduce using rule 22 (declaracion_list -> assignacion_instruction .)
    IF              reduce using rule 22 (declaracion_list -> assignacion_instruction .)
    WHILE           reduce using rule 22 (declaracion_list -> assignacion_instruction .)
    FOR             reduce using rule 22 (declaracion_list -> assignacion_instruction .)
    INTERFACE       reduce using rule 22 (declaracion_list -> assignacion_instruction .)
    $end            reduce using rule 22 (declaracion_list -> assignacion_instruction .)
    R_LLAVE         reduce using rule 22 (declaracion_list -> assignacion_instruction .)


state 34

    (23) assignacion_instruction -> LITERAL . COLON type IGUAL a
    (24) assignacion_instruction -> LITERAL . COLON type
    (25) assignacion_instruction -> LITERAL . IGUAL a

    COLON           shift and go to state 44
    IGUAL           shift and go to state 45


state 35

    (31) assig_pro -> LITERAL IGUAL . a
    (45) a -> . a OR b
    (46) a -> . b
    (47) b -> . b AND c
    (48) b -> . c
    (49) c -> . NOT d
    (50) c -> . d
    (51) d -> . d DISTINTO_QUE e
    (52) d -> . d MENOR_QUE e
    (53) d -> . d MENOR_IGUAL_QUE e
    (54) d -> . d MAYOR_QUE e
    (55) d -> . d MAYOR_IGUAL_QUE e
    (56) d -> . d TRIPLE_IGUAL e
    (57) d -> . e
    (58) e -> . e MAS f
    (59) e -> . e MENOS f
    (60) e -> . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 50
    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    a                              shift and go to state 47
    b                              shift and go to state 48
    c                              shift and go to state 49
    d                              shift and go to state 51
    e                              shift and go to state 52
    f                              shift and go to state 53
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 36

    (73) sumadores -> LITERAL MAS . MAS

    MAS             shift and go to state 61


state 37

    (74) sumadores -> LITERAL MENOS . MENOS

    MENOS           shift and go to state 62


state 38

    (32) if_pro -> IF L_PAREN . a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (45) a -> . a OR b
    (46) a -> . b
    (47) b -> . b AND c
    (48) b -> . c
    (49) c -> . NOT d
    (50) c -> . d
    (51) d -> . d DISTINTO_QUE e
    (52) d -> . d MENOR_QUE e
    (53) d -> . d MENOR_IGUAL_QUE e
    (54) d -> . d MAYOR_QUE e
    (55) d -> . d MAYOR_IGUAL_QUE e
    (56) d -> . d TRIPLE_IGUAL e
    (57) d -> . e
    (58) e -> . e MAS f
    (59) e -> . e MENOS f
    (60) e -> . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 50
    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    a                              shift and go to state 63
    b                              shift and go to state 48
    c                              shift and go to state 49
    d                              shift and go to state 51
    e                              shift and go to state 52
    f                              shift and go to state 53
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 39

    (36) while_pro -> WHILE L_PAREN . a R_PAREN L_LLAVE instrucciones R_LLAVE
    (45) a -> . a OR b
    (46) a -> . b
    (47) b -> . b AND c
    (48) b -> . c
    (49) c -> . NOT d
    (50) c -> . d
    (51) d -> . d DISTINTO_QUE e
    (52) d -> . d MENOR_QUE e
    (53) d -> . d MENOR_IGUAL_QUE e
    (54) d -> . d MAYOR_QUE e
    (55) d -> . d MAYOR_IGUAL_QUE e
    (56) d -> . d TRIPLE_IGUAL e
    (57) d -> . e
    (58) e -> . e MAS f
    (59) e -> . e MENOS f
    (60) e -> . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 50
    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    a                              shift and go to state 64
    b                              shift and go to state 48
    c                              shift and go to state 49
    d                              shift and go to state 51
    e                              shift and go to state 52
    f                              shift and go to state 53
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 40

    (37) for_pro -> FOR L_PAREN . declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (38) for_pro -> FOR L_PAREN . assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (39) for_each_pro -> FOR L_PAREN . for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (20) declaration_instruction -> . LET declaracion_list
    (31) assig_pro -> . LITERAL IGUAL a
    (40) for_each_dec -> . LET LITERAL OF a
    (41) for_each_dec -> . LET LITERAL COLON type OF a

    LET             shift and go to state 68
    LITERAL         shift and go to state 69

    declaration_instruction        shift and go to state 65
    assig_pro                      shift and go to state 66
    for_each_dec                   shift and go to state 67

state 41

    (15) interface_pro -> INTERFACE LITERAL . L_LLAVE interface_atributos R_LLAVE

    L_LLAVE         shift and go to state 70


state 42

    (42) console_pro -> CONSOLE PUNTO LOG . L_PAREN expresion R_PAREN

    L_PAREN         shift and go to state 71


state 43

    (21) declaracion_list -> declaracion_list COMA . assignacion_instruction
    (23) assignacion_instruction -> . LITERAL COLON type IGUAL a
    (24) assignacion_instruction -> . LITERAL COLON type
    (25) assignacion_instruction -> . LITERAL IGUAL a

    LITERAL         shift and go to state 34

    assignacion_instruction        shift and go to state 72

state 44

    (23) assignacion_instruction -> LITERAL COLON . type IGUAL a
    (24) assignacion_instruction -> LITERAL COLON . type
    (26) type -> . NUMBER
    (27) type -> . STRING
    (28) type -> . BOOLEAN
    (29) type -> . ANY
    (30) type -> . LITERAL

    NUMBER          shift and go to state 75
    STRING          shift and go to state 76
    BOOLEAN         shift and go to state 77
    ANY             shift and go to state 78
    LITERAL         shift and go to state 73

    type                           shift and go to state 74

state 45

    (25) assignacion_instruction -> LITERAL IGUAL . a
    (45) a -> . a OR b
    (46) a -> . b
    (47) b -> . b AND c
    (48) b -> . c
    (49) c -> . NOT d
    (50) c -> . d
    (51) d -> . d DISTINTO_QUE e
    (52) d -> . d MENOR_QUE e
    (53) d -> . d MENOR_IGUAL_QUE e
    (54) d -> . d MAYOR_QUE e
    (55) d -> . d MAYOR_IGUAL_QUE e
    (56) d -> . d TRIPLE_IGUAL e
    (57) d -> . e
    (58) e -> . e MAS f
    (59) e -> . e MENOS f
    (60) e -> . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 50
    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    a                              shift and go to state 79
    b                              shift and go to state 48
    c                              shift and go to state 49
    d                              shift and go to state 51
    e                              shift and go to state 52
    f                              shift and go to state 53
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 46

    (70) g -> LITERAL .

    PUNTO           reduce using rule 70 (g -> LITERAL .)
    TIMES           reduce using rule 70 (g -> LITERAL .)
    DIVIDE          reduce using rule 70 (g -> LITERAL .)
    MOD             reduce using rule 70 (g -> LITERAL .)
    POTENCIA        reduce using rule 70 (g -> LITERAL .)
    MAS             reduce using rule 70 (g -> LITERAL .)
    MENOS           reduce using rule 70 (g -> LITERAL .)
    DISTINTO_QUE    reduce using rule 70 (g -> LITERAL .)
    MENOR_QUE       reduce using rule 70 (g -> LITERAL .)
    MENOR_IGUAL_QUE reduce using rule 70 (g -> LITERAL .)
    MAYOR_QUE       reduce using rule 70 (g -> LITERAL .)
    MAYOR_IGUAL_QUE reduce using rule 70 (g -> LITERAL .)
    TRIPLE_IGUAL    reduce using rule 70 (g -> LITERAL .)
    AND             reduce using rule 70 (g -> LITERAL .)
    OR              reduce using rule 70 (g -> LITERAL .)
    SEMI_COLON      reduce using rule 70 (g -> LITERAL .)
    CONSOLE         reduce using rule 70 (g -> LITERAL .)
    LET             reduce using rule 70 (g -> LITERAL .)
    LITERAL         reduce using rule 70 (g -> LITERAL .)
    IF              reduce using rule 70 (g -> LITERAL .)
    WHILE           reduce using rule 70 (g -> LITERAL .)
    FOR             reduce using rule 70 (g -> LITERAL .)
    INTERFACE       reduce using rule 70 (g -> LITERAL .)
    $end            reduce using rule 70 (g -> LITERAL .)
    R_LLAVE         reduce using rule 70 (g -> LITERAL .)
    R_PAREN         reduce using rule 70 (g -> LITERAL .)
    COMA            reduce using rule 70 (g -> LITERAL .)


state 47

    (31) assig_pro -> LITERAL IGUAL a .
    (45) a -> a . OR b

    SEMI_COLON      reduce using rule 31 (assig_pro -> LITERAL IGUAL a .)
    CONSOLE         reduce using rule 31 (assig_pro -> LITERAL IGUAL a .)
    LET             reduce using rule 31 (assig_pro -> LITERAL IGUAL a .)
    LITERAL         reduce using rule 31 (assig_pro -> LITERAL IGUAL a .)
    IF              reduce using rule 31 (assig_pro -> LITERAL IGUAL a .)
    WHILE           reduce using rule 31 (assig_pro -> LITERAL IGUAL a .)
    FOR             reduce using rule 31 (assig_pro -> LITERAL IGUAL a .)
    INTERFACE       reduce using rule 31 (assig_pro -> LITERAL IGUAL a .)
    $end            reduce using rule 31 (assig_pro -> LITERAL IGUAL a .)
    R_LLAVE         reduce using rule 31 (assig_pro -> LITERAL IGUAL a .)
    R_PAREN         reduce using rule 31 (assig_pro -> LITERAL IGUAL a .)
    OR              shift and go to state 80


state 48

    (46) a -> b .
    (47) b -> b . AND c

    OR              reduce using rule 46 (a -> b .)
    SEMI_COLON      reduce using rule 46 (a -> b .)
    CONSOLE         reduce using rule 46 (a -> b .)
    LET             reduce using rule 46 (a -> b .)
    LITERAL         reduce using rule 46 (a -> b .)
    IF              reduce using rule 46 (a -> b .)
    WHILE           reduce using rule 46 (a -> b .)
    FOR             reduce using rule 46 (a -> b .)
    INTERFACE       reduce using rule 46 (a -> b .)
    $end            reduce using rule 46 (a -> b .)
    R_LLAVE         reduce using rule 46 (a -> b .)
    R_PAREN         reduce using rule 46 (a -> b .)
    COMA            reduce using rule 46 (a -> b .)
    AND             shift and go to state 81


state 49

    (48) b -> c .

    AND             reduce using rule 48 (b -> c .)
    OR              reduce using rule 48 (b -> c .)
    SEMI_COLON      reduce using rule 48 (b -> c .)
    CONSOLE         reduce using rule 48 (b -> c .)
    LET             reduce using rule 48 (b -> c .)
    LITERAL         reduce using rule 48 (b -> c .)
    IF              reduce using rule 48 (b -> c .)
    WHILE           reduce using rule 48 (b -> c .)
    FOR             reduce using rule 48 (b -> c .)
    INTERFACE       reduce using rule 48 (b -> c .)
    $end            reduce using rule 48 (b -> c .)
    R_LLAVE         reduce using rule 48 (b -> c .)
    R_PAREN         reduce using rule 48 (b -> c .)
    COMA            reduce using rule 48 (b -> c .)


state 50

    (49) c -> NOT . d
    (51) d -> . d DISTINTO_QUE e
    (52) d -> . d MENOR_QUE e
    (53) d -> . d MENOR_IGUAL_QUE e
    (54) d -> . d MAYOR_QUE e
    (55) d -> . d MAYOR_IGUAL_QUE e
    (56) d -> . d TRIPLE_IGUAL e
    (57) d -> . e
    (58) e -> . e MAS f
    (59) e -> . e MENOS f
    (60) e -> . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    d                              shift and go to state 82
    e                              shift and go to state 52
    f                              shift and go to state 53
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 51

    (50) c -> d .
    (51) d -> d . DISTINTO_QUE e
    (52) d -> d . MENOR_QUE e
    (53) d -> d . MENOR_IGUAL_QUE e
    (54) d -> d . MAYOR_QUE e
    (55) d -> d . MAYOR_IGUAL_QUE e
    (56) d -> d . TRIPLE_IGUAL e

    AND             reduce using rule 50 (c -> d .)
    OR              reduce using rule 50 (c -> d .)
    SEMI_COLON      reduce using rule 50 (c -> d .)
    CONSOLE         reduce using rule 50 (c -> d .)
    LET             reduce using rule 50 (c -> d .)
    LITERAL         reduce using rule 50 (c -> d .)
    IF              reduce using rule 50 (c -> d .)
    WHILE           reduce using rule 50 (c -> d .)
    FOR             reduce using rule 50 (c -> d .)
    INTERFACE       reduce using rule 50 (c -> d .)
    $end            reduce using rule 50 (c -> d .)
    R_LLAVE         reduce using rule 50 (c -> d .)
    R_PAREN         reduce using rule 50 (c -> d .)
    COMA            reduce using rule 50 (c -> d .)
    DISTINTO_QUE    shift and go to state 83
    MENOR_QUE       shift and go to state 84
    MENOR_IGUAL_QUE shift and go to state 85
    MAYOR_QUE       shift and go to state 86
    MAYOR_IGUAL_QUE shift and go to state 87
    TRIPLE_IGUAL    shift and go to state 88


state 52

    (57) d -> e .
    (58) e -> e . MAS f
    (59) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 57 (d -> e .)
    MENOR_QUE       reduce using rule 57 (d -> e .)
    MENOR_IGUAL_QUE reduce using rule 57 (d -> e .)
    MAYOR_QUE       reduce using rule 57 (d -> e .)
    MAYOR_IGUAL_QUE reduce using rule 57 (d -> e .)
    TRIPLE_IGUAL    reduce using rule 57 (d -> e .)
    AND             reduce using rule 57 (d -> e .)
    OR              reduce using rule 57 (d -> e .)
    SEMI_COLON      reduce using rule 57 (d -> e .)
    CONSOLE         reduce using rule 57 (d -> e .)
    LET             reduce using rule 57 (d -> e .)
    LITERAL         reduce using rule 57 (d -> e .)
    IF              reduce using rule 57 (d -> e .)
    WHILE           reduce using rule 57 (d -> e .)
    FOR             reduce using rule 57 (d -> e .)
    INTERFACE       reduce using rule 57 (d -> e .)
    $end            reduce using rule 57 (d -> e .)
    R_LLAVE         reduce using rule 57 (d -> e .)
    R_PAREN         reduce using rule 57 (d -> e .)
    COMA            reduce using rule 57 (d -> e .)
    MAS             shift and go to state 89
    MENOS           shift and go to state 90


state 53

    (60) e -> f .
    (61) f -> f . TIMES g
    (62) f -> f . DIVIDE g
    (63) f -> f . MOD g
    (64) f -> f . POTENCIA g

    MAS             reduce using rule 60 (e -> f .)
    MENOS           reduce using rule 60 (e -> f .)
    DISTINTO_QUE    reduce using rule 60 (e -> f .)
    MENOR_QUE       reduce using rule 60 (e -> f .)
    MENOR_IGUAL_QUE reduce using rule 60 (e -> f .)
    MAYOR_QUE       reduce using rule 60 (e -> f .)
    MAYOR_IGUAL_QUE reduce using rule 60 (e -> f .)
    TRIPLE_IGUAL    reduce using rule 60 (e -> f .)
    AND             reduce using rule 60 (e -> f .)
    OR              reduce using rule 60 (e -> f .)
    SEMI_COLON      reduce using rule 60 (e -> f .)
    CONSOLE         reduce using rule 60 (e -> f .)
    LET             reduce using rule 60 (e -> f .)
    LITERAL         reduce using rule 60 (e -> f .)
    IF              reduce using rule 60 (e -> f .)
    WHILE           reduce using rule 60 (e -> f .)
    FOR             reduce using rule 60 (e -> f .)
    INTERFACE       reduce using rule 60 (e -> f .)
    $end            reduce using rule 60 (e -> f .)
    R_LLAVE         reduce using rule 60 (e -> f .)
    R_PAREN         reduce using rule 60 (e -> f .)
    COMA            reduce using rule 60 (e -> f .)
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MOD             shift and go to state 93
    POTENCIA        shift and go to state 94


state 54

    (65) f -> g .
    (66) f -> g . PUNTO nativeFun L_PAREN expresion R_PAREN

    TIMES           reduce using rule 65 (f -> g .)
    DIVIDE          reduce using rule 65 (f -> g .)
    MOD             reduce using rule 65 (f -> g .)
    POTENCIA        reduce using rule 65 (f -> g .)
    MAS             reduce using rule 65 (f -> g .)
    MENOS           reduce using rule 65 (f -> g .)
    DISTINTO_QUE    reduce using rule 65 (f -> g .)
    MENOR_QUE       reduce using rule 65 (f -> g .)
    MENOR_IGUAL_QUE reduce using rule 65 (f -> g .)
    MAYOR_QUE       reduce using rule 65 (f -> g .)
    MAYOR_IGUAL_QUE reduce using rule 65 (f -> g .)
    TRIPLE_IGUAL    reduce using rule 65 (f -> g .)
    AND             reduce using rule 65 (f -> g .)
    OR              reduce using rule 65 (f -> g .)
    SEMI_COLON      reduce using rule 65 (f -> g .)
    CONSOLE         reduce using rule 65 (f -> g .)
    LET             reduce using rule 65 (f -> g .)
    LITERAL         reduce using rule 65 (f -> g .)
    IF              reduce using rule 65 (f -> g .)
    WHILE           reduce using rule 65 (f -> g .)
    FOR             reduce using rule 65 (f -> g .)
    INTERFACE       reduce using rule 65 (f -> g .)
    $end            reduce using rule 65 (f -> g .)
    R_LLAVE         reduce using rule 65 (f -> g .)
    R_PAREN         reduce using rule 65 (f -> g .)
    COMA            reduce using rule 65 (f -> g .)
    PUNTO           shift and go to state 95


state 55

    (72) g -> L_PAREN . a R_PAREN
    (45) a -> . a OR b
    (46) a -> . b
    (47) b -> . b AND c
    (48) b -> . c
    (49) c -> . NOT d
    (50) c -> . d
    (51) d -> . d DISTINTO_QUE e
    (52) d -> . d MENOR_QUE e
    (53) d -> . d MENOR_IGUAL_QUE e
    (54) d -> . d MAYOR_QUE e
    (55) d -> . d MAYOR_IGUAL_QUE e
    (56) d -> . d TRIPLE_IGUAL e
    (57) d -> . e
    (58) e -> . e MAS f
    (59) e -> . e MENOS f
    (60) e -> . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 50
    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    a                              shift and go to state 96
    b                              shift and go to state 48
    c                              shift and go to state 49
    d                              shift and go to state 51
    e                              shift and go to state 52
    f                              shift and go to state 53
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 56

    (67) g -> ENTERO .

    PUNTO           reduce using rule 67 (g -> ENTERO .)
    TIMES           reduce using rule 67 (g -> ENTERO .)
    DIVIDE          reduce using rule 67 (g -> ENTERO .)
    MOD             reduce using rule 67 (g -> ENTERO .)
    POTENCIA        reduce using rule 67 (g -> ENTERO .)
    MAS             reduce using rule 67 (g -> ENTERO .)
    MENOS           reduce using rule 67 (g -> ENTERO .)
    DISTINTO_QUE    reduce using rule 67 (g -> ENTERO .)
    MENOR_QUE       reduce using rule 67 (g -> ENTERO .)
    MENOR_IGUAL_QUE reduce using rule 67 (g -> ENTERO .)
    MAYOR_QUE       reduce using rule 67 (g -> ENTERO .)
    MAYOR_IGUAL_QUE reduce using rule 67 (g -> ENTERO .)
    TRIPLE_IGUAL    reduce using rule 67 (g -> ENTERO .)
    AND             reduce using rule 67 (g -> ENTERO .)
    OR              reduce using rule 67 (g -> ENTERO .)
    SEMI_COLON      reduce using rule 67 (g -> ENTERO .)
    CONSOLE         reduce using rule 67 (g -> ENTERO .)
    LET             reduce using rule 67 (g -> ENTERO .)
    LITERAL         reduce using rule 67 (g -> ENTERO .)
    IF              reduce using rule 67 (g -> ENTERO .)
    WHILE           reduce using rule 67 (g -> ENTERO .)
    FOR             reduce using rule 67 (g -> ENTERO .)
    INTERFACE       reduce using rule 67 (g -> ENTERO .)
    $end            reduce using rule 67 (g -> ENTERO .)
    R_LLAVE         reduce using rule 67 (g -> ENTERO .)
    R_PAREN         reduce using rule 67 (g -> ENTERO .)
    COMA            reduce using rule 67 (g -> ENTERO .)


state 57

    (68) g -> DECIMAL .

    PUNTO           reduce using rule 68 (g -> DECIMAL .)
    TIMES           reduce using rule 68 (g -> DECIMAL .)
    DIVIDE          reduce using rule 68 (g -> DECIMAL .)
    MOD             reduce using rule 68 (g -> DECIMAL .)
    POTENCIA        reduce using rule 68 (g -> DECIMAL .)
    MAS             reduce using rule 68 (g -> DECIMAL .)
    MENOS           reduce using rule 68 (g -> DECIMAL .)
    DISTINTO_QUE    reduce using rule 68 (g -> DECIMAL .)
    MENOR_QUE       reduce using rule 68 (g -> DECIMAL .)
    MENOR_IGUAL_QUE reduce using rule 68 (g -> DECIMAL .)
    MAYOR_QUE       reduce using rule 68 (g -> DECIMAL .)
    MAYOR_IGUAL_QUE reduce using rule 68 (g -> DECIMAL .)
    TRIPLE_IGUAL    reduce using rule 68 (g -> DECIMAL .)
    AND             reduce using rule 68 (g -> DECIMAL .)
    OR              reduce using rule 68 (g -> DECIMAL .)
    SEMI_COLON      reduce using rule 68 (g -> DECIMAL .)
    CONSOLE         reduce using rule 68 (g -> DECIMAL .)
    LET             reduce using rule 68 (g -> DECIMAL .)
    LITERAL         reduce using rule 68 (g -> DECIMAL .)
    IF              reduce using rule 68 (g -> DECIMAL .)
    WHILE           reduce using rule 68 (g -> DECIMAL .)
    FOR             reduce using rule 68 (g -> DECIMAL .)
    INTERFACE       reduce using rule 68 (g -> DECIMAL .)
    $end            reduce using rule 68 (g -> DECIMAL .)
    R_LLAVE         reduce using rule 68 (g -> DECIMAL .)
    R_PAREN         reduce using rule 68 (g -> DECIMAL .)
    COMA            reduce using rule 68 (g -> DECIMAL .)


state 58

    (69) g -> CADENA .

    PUNTO           reduce using rule 69 (g -> CADENA .)
    TIMES           reduce using rule 69 (g -> CADENA .)
    DIVIDE          reduce using rule 69 (g -> CADENA .)
    MOD             reduce using rule 69 (g -> CADENA .)
    POTENCIA        reduce using rule 69 (g -> CADENA .)
    MAS             reduce using rule 69 (g -> CADENA .)
    MENOS           reduce using rule 69 (g -> CADENA .)
    DISTINTO_QUE    reduce using rule 69 (g -> CADENA .)
    MENOR_QUE       reduce using rule 69 (g -> CADENA .)
    MENOR_IGUAL_QUE reduce using rule 69 (g -> CADENA .)
    MAYOR_QUE       reduce using rule 69 (g -> CADENA .)
    MAYOR_IGUAL_QUE reduce using rule 69 (g -> CADENA .)
    TRIPLE_IGUAL    reduce using rule 69 (g -> CADENA .)
    AND             reduce using rule 69 (g -> CADENA .)
    OR              reduce using rule 69 (g -> CADENA .)
    SEMI_COLON      reduce using rule 69 (g -> CADENA .)
    CONSOLE         reduce using rule 69 (g -> CADENA .)
    LET             reduce using rule 69 (g -> CADENA .)
    LITERAL         reduce using rule 69 (g -> CADENA .)
    IF              reduce using rule 69 (g -> CADENA .)
    WHILE           reduce using rule 69 (g -> CADENA .)
    FOR             reduce using rule 69 (g -> CADENA .)
    INTERFACE       reduce using rule 69 (g -> CADENA .)
    $end            reduce using rule 69 (g -> CADENA .)
    R_LLAVE         reduce using rule 69 (g -> CADENA .)
    R_PAREN         reduce using rule 69 (g -> CADENA .)
    COMA            reduce using rule 69 (g -> CADENA .)


state 59

    (71) g -> interface_assi .

    PUNTO           reduce using rule 71 (g -> interface_assi .)
    TIMES           reduce using rule 71 (g -> interface_assi .)
    DIVIDE          reduce using rule 71 (g -> interface_assi .)
    MOD             reduce using rule 71 (g -> interface_assi .)
    POTENCIA        reduce using rule 71 (g -> interface_assi .)
    MAS             reduce using rule 71 (g -> interface_assi .)
    MENOS           reduce using rule 71 (g -> interface_assi .)
    DISTINTO_QUE    reduce using rule 71 (g -> interface_assi .)
    MENOR_QUE       reduce using rule 71 (g -> interface_assi .)
    MENOR_IGUAL_QUE reduce using rule 71 (g -> interface_assi .)
    MAYOR_QUE       reduce using rule 71 (g -> interface_assi .)
    MAYOR_IGUAL_QUE reduce using rule 71 (g -> interface_assi .)
    TRIPLE_IGUAL    reduce using rule 71 (g -> interface_assi .)
    AND             reduce using rule 71 (g -> interface_assi .)
    OR              reduce using rule 71 (g -> interface_assi .)
    SEMI_COLON      reduce using rule 71 (g -> interface_assi .)
    CONSOLE         reduce using rule 71 (g -> interface_assi .)
    LET             reduce using rule 71 (g -> interface_assi .)
    LITERAL         reduce using rule 71 (g -> interface_assi .)
    IF              reduce using rule 71 (g -> interface_assi .)
    WHILE           reduce using rule 71 (g -> interface_assi .)
    FOR             reduce using rule 71 (g -> interface_assi .)
    INTERFACE       reduce using rule 71 (g -> interface_assi .)
    $end            reduce using rule 71 (g -> interface_assi .)
    R_LLAVE         reduce using rule 71 (g -> interface_assi .)
    R_PAREN         reduce using rule 71 (g -> interface_assi .)
    COMA            reduce using rule 71 (g -> interface_assi .)


state 60

    (75) interface_assi -> L_LLAVE . atributos_assi R_LLAVE
    (76) atributos_assi -> . atributos_assi COMA LITERAL COLON a
    (77) atributos_assi -> . LITERAL COLON a

    LITERAL         shift and go to state 98

    atributos_assi                 shift and go to state 97

state 61

    (73) sumadores -> LITERAL MAS MAS .

    SEMI_COLON      reduce using rule 73 (sumadores -> LITERAL MAS MAS .)
    CONSOLE         reduce using rule 73 (sumadores -> LITERAL MAS MAS .)
    LET             reduce using rule 73 (sumadores -> LITERAL MAS MAS .)
    LITERAL         reduce using rule 73 (sumadores -> LITERAL MAS MAS .)
    IF              reduce using rule 73 (sumadores -> LITERAL MAS MAS .)
    WHILE           reduce using rule 73 (sumadores -> LITERAL MAS MAS .)
    FOR             reduce using rule 73 (sumadores -> LITERAL MAS MAS .)
    INTERFACE       reduce using rule 73 (sumadores -> LITERAL MAS MAS .)
    $end            reduce using rule 73 (sumadores -> LITERAL MAS MAS .)
    R_LLAVE         reduce using rule 73 (sumadores -> LITERAL MAS MAS .)


state 62

    (74) sumadores -> LITERAL MENOS MENOS .

    SEMI_COLON      reduce using rule 74 (sumadores -> LITERAL MENOS MENOS .)
    CONSOLE         reduce using rule 74 (sumadores -> LITERAL MENOS MENOS .)
    LET             reduce using rule 74 (sumadores -> LITERAL MENOS MENOS .)
    LITERAL         reduce using rule 74 (sumadores -> LITERAL MENOS MENOS .)
    IF              reduce using rule 74 (sumadores -> LITERAL MENOS MENOS .)
    WHILE           reduce using rule 74 (sumadores -> LITERAL MENOS MENOS .)
    FOR             reduce using rule 74 (sumadores -> LITERAL MENOS MENOS .)
    INTERFACE       reduce using rule 74 (sumadores -> LITERAL MENOS MENOS .)
    $end            reduce using rule 74 (sumadores -> LITERAL MENOS MENOS .)
    R_LLAVE         reduce using rule 74 (sumadores -> LITERAL MENOS MENOS .)


state 63

    (32) if_pro -> IF L_PAREN a . R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (45) a -> a . OR b

    R_PAREN         shift and go to state 99
    OR              shift and go to state 80


state 64

    (36) while_pro -> WHILE L_PAREN a . R_PAREN L_LLAVE instrucciones R_LLAVE
    (45) a -> a . OR b

    R_PAREN         shift and go to state 100
    OR              shift and go to state 80


state 65

    (37) for_pro -> FOR L_PAREN declaration_instruction . SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE

    SEMI_COLON      shift and go to state 101


state 66

    (38) for_pro -> FOR L_PAREN assig_pro . SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE

    SEMI_COLON      shift and go to state 102


state 67

    (39) for_each_pro -> FOR L_PAREN for_each_dec . R_PAREN L_LLAVE instrucciones R_LLAVE

    R_PAREN         shift and go to state 103


state 68

    (20) declaration_instruction -> LET . declaracion_list
    (40) for_each_dec -> LET . LITERAL OF a
    (41) for_each_dec -> LET . LITERAL COLON type OF a
    (21) declaracion_list -> . declaracion_list COMA assignacion_instruction
    (22) declaracion_list -> . assignacion_instruction
    (23) assignacion_instruction -> . LITERAL COLON type IGUAL a
    (24) assignacion_instruction -> . LITERAL COLON type
    (25) assignacion_instruction -> . LITERAL IGUAL a

    LITERAL         shift and go to state 104

    declaracion_list               shift and go to state 32
    assignacion_instruction        shift and go to state 33

state 69

    (31) assig_pro -> LITERAL . IGUAL a

    IGUAL           shift and go to state 35


state 70

    (15) interface_pro -> INTERFACE LITERAL L_LLAVE . interface_atributos R_LLAVE
    (16) interface_atributos -> . interface_atributos interface_atributo sc
    (17) interface_atributos -> .

    R_LLAVE         reduce using rule 17 (interface_atributos -> .)
    LITERAL         reduce using rule 17 (interface_atributos -> .)

    interface_atributos            shift and go to state 105

state 71

    (42) console_pro -> CONSOLE PUNTO LOG L_PAREN . expresion R_PAREN
    (43) expresion -> . expresion COMA a
    (44) expresion -> . a
    (45) a -> . a OR b
    (46) a -> . b
    (47) b -> . b AND c
    (48) b -> . c
    (49) c -> . NOT d
    (50) c -> . d
    (51) d -> . d DISTINTO_QUE e
    (52) d -> . d MENOR_QUE e
    (53) d -> . d MENOR_IGUAL_QUE e
    (54) d -> . d MAYOR_QUE e
    (55) d -> . d MAYOR_IGUAL_QUE e
    (56) d -> . d TRIPLE_IGUAL e
    (57) d -> . e
    (58) e -> . e MAS f
    (59) e -> . e MENOS f
    (60) e -> . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 50
    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    expresion                      shift and go to state 106
    a                              shift and go to state 107
    b                              shift and go to state 48
    c                              shift and go to state 49
    d                              shift and go to state 51
    e                              shift and go to state 52
    f                              shift and go to state 53
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 72

    (21) declaracion_list -> declaracion_list COMA assignacion_instruction .

    COMA            reduce using rule 21 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    SEMI_COLON      reduce using rule 21 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    CONSOLE         reduce using rule 21 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    LET             reduce using rule 21 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    LITERAL         reduce using rule 21 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    IF              reduce using rule 21 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    WHILE           reduce using rule 21 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    FOR             reduce using rule 21 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    INTERFACE       reduce using rule 21 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    $end            reduce using rule 21 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    R_LLAVE         reduce using rule 21 (declaracion_list -> declaracion_list COMA assignacion_instruction .)


state 73

    (30) type -> LITERAL .

    IGUAL           reduce using rule 30 (type -> LITERAL .)
    COMA            reduce using rule 30 (type -> LITERAL .)
    SEMI_COLON      reduce using rule 30 (type -> LITERAL .)
    CONSOLE         reduce using rule 30 (type -> LITERAL .)
    LET             reduce using rule 30 (type -> LITERAL .)
    LITERAL         reduce using rule 30 (type -> LITERAL .)
    IF              reduce using rule 30 (type -> LITERAL .)
    WHILE           reduce using rule 30 (type -> LITERAL .)
    FOR             reduce using rule 30 (type -> LITERAL .)
    INTERFACE       reduce using rule 30 (type -> LITERAL .)
    $end            reduce using rule 30 (type -> LITERAL .)
    R_LLAVE         reduce using rule 30 (type -> LITERAL .)
    OF              reduce using rule 30 (type -> LITERAL .)


state 74

    (23) assignacion_instruction -> LITERAL COLON type . IGUAL a
    (24) assignacion_instruction -> LITERAL COLON type .

    IGUAL           shift and go to state 108
    COMA            reduce using rule 24 (assignacion_instruction -> LITERAL COLON type .)
    SEMI_COLON      reduce using rule 24 (assignacion_instruction -> LITERAL COLON type .)
    CONSOLE         reduce using rule 24 (assignacion_instruction -> LITERAL COLON type .)
    LET             reduce using rule 24 (assignacion_instruction -> LITERAL COLON type .)
    LITERAL         reduce using rule 24 (assignacion_instruction -> LITERAL COLON type .)
    IF              reduce using rule 24 (assignacion_instruction -> LITERAL COLON type .)
    WHILE           reduce using rule 24 (assignacion_instruction -> LITERAL COLON type .)
    FOR             reduce using rule 24 (assignacion_instruction -> LITERAL COLON type .)
    INTERFACE       reduce using rule 24 (assignacion_instruction -> LITERAL COLON type .)
    $end            reduce using rule 24 (assignacion_instruction -> LITERAL COLON type .)
    R_LLAVE         reduce using rule 24 (assignacion_instruction -> LITERAL COLON type .)


state 75

    (26) type -> NUMBER .

    IGUAL           reduce using rule 26 (type -> NUMBER .)
    COMA            reduce using rule 26 (type -> NUMBER .)
    SEMI_COLON      reduce using rule 26 (type -> NUMBER .)
    CONSOLE         reduce using rule 26 (type -> NUMBER .)
    LET             reduce using rule 26 (type -> NUMBER .)
    LITERAL         reduce using rule 26 (type -> NUMBER .)
    IF              reduce using rule 26 (type -> NUMBER .)
    WHILE           reduce using rule 26 (type -> NUMBER .)
    FOR             reduce using rule 26 (type -> NUMBER .)
    INTERFACE       reduce using rule 26 (type -> NUMBER .)
    $end            reduce using rule 26 (type -> NUMBER .)
    R_LLAVE         reduce using rule 26 (type -> NUMBER .)
    OF              reduce using rule 26 (type -> NUMBER .)


state 76

    (27) type -> STRING .

    IGUAL           reduce using rule 27 (type -> STRING .)
    COMA            reduce using rule 27 (type -> STRING .)
    SEMI_COLON      reduce using rule 27 (type -> STRING .)
    CONSOLE         reduce using rule 27 (type -> STRING .)
    LET             reduce using rule 27 (type -> STRING .)
    LITERAL         reduce using rule 27 (type -> STRING .)
    IF              reduce using rule 27 (type -> STRING .)
    WHILE           reduce using rule 27 (type -> STRING .)
    FOR             reduce using rule 27 (type -> STRING .)
    INTERFACE       reduce using rule 27 (type -> STRING .)
    $end            reduce using rule 27 (type -> STRING .)
    R_LLAVE         reduce using rule 27 (type -> STRING .)
    OF              reduce using rule 27 (type -> STRING .)


state 77

    (28) type -> BOOLEAN .

    IGUAL           reduce using rule 28 (type -> BOOLEAN .)
    COMA            reduce using rule 28 (type -> BOOLEAN .)
    SEMI_COLON      reduce using rule 28 (type -> BOOLEAN .)
    CONSOLE         reduce using rule 28 (type -> BOOLEAN .)
    LET             reduce using rule 28 (type -> BOOLEAN .)
    LITERAL         reduce using rule 28 (type -> BOOLEAN .)
    IF              reduce using rule 28 (type -> BOOLEAN .)
    WHILE           reduce using rule 28 (type -> BOOLEAN .)
    FOR             reduce using rule 28 (type -> BOOLEAN .)
    INTERFACE       reduce using rule 28 (type -> BOOLEAN .)
    $end            reduce using rule 28 (type -> BOOLEAN .)
    R_LLAVE         reduce using rule 28 (type -> BOOLEAN .)
    OF              reduce using rule 28 (type -> BOOLEAN .)


state 78

    (29) type -> ANY .

    IGUAL           reduce using rule 29 (type -> ANY .)
    COMA            reduce using rule 29 (type -> ANY .)
    SEMI_COLON      reduce using rule 29 (type -> ANY .)
    CONSOLE         reduce using rule 29 (type -> ANY .)
    LET             reduce using rule 29 (type -> ANY .)
    LITERAL         reduce using rule 29 (type -> ANY .)
    IF              reduce using rule 29 (type -> ANY .)
    WHILE           reduce using rule 29 (type -> ANY .)
    FOR             reduce using rule 29 (type -> ANY .)
    INTERFACE       reduce using rule 29 (type -> ANY .)
    $end            reduce using rule 29 (type -> ANY .)
    R_LLAVE         reduce using rule 29 (type -> ANY .)
    OF              reduce using rule 29 (type -> ANY .)


state 79

    (25) assignacion_instruction -> LITERAL IGUAL a .
    (45) a -> a . OR b

    COMA            reduce using rule 25 (assignacion_instruction -> LITERAL IGUAL a .)
    SEMI_COLON      reduce using rule 25 (assignacion_instruction -> LITERAL IGUAL a .)
    CONSOLE         reduce using rule 25 (assignacion_instruction -> LITERAL IGUAL a .)
    LET             reduce using rule 25 (assignacion_instruction -> LITERAL IGUAL a .)
    LITERAL         reduce using rule 25 (assignacion_instruction -> LITERAL IGUAL a .)
    IF              reduce using rule 25 (assignacion_instruction -> LITERAL IGUAL a .)
    WHILE           reduce using rule 25 (assignacion_instruction -> LITERAL IGUAL a .)
    FOR             reduce using rule 25 (assignacion_instruction -> LITERAL IGUAL a .)
    INTERFACE       reduce using rule 25 (assignacion_instruction -> LITERAL IGUAL a .)
    $end            reduce using rule 25 (assignacion_instruction -> LITERAL IGUAL a .)
    R_LLAVE         reduce using rule 25 (assignacion_instruction -> LITERAL IGUAL a .)
    OR              shift and go to state 80


state 80

    (45) a -> a OR . b
    (47) b -> . b AND c
    (48) b -> . c
    (49) c -> . NOT d
    (50) c -> . d
    (51) d -> . d DISTINTO_QUE e
    (52) d -> . d MENOR_QUE e
    (53) d -> . d MENOR_IGUAL_QUE e
    (54) d -> . d MAYOR_QUE e
    (55) d -> . d MAYOR_IGUAL_QUE e
    (56) d -> . d TRIPLE_IGUAL e
    (57) d -> . e
    (58) e -> . e MAS f
    (59) e -> . e MENOS f
    (60) e -> . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 50
    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    b                              shift and go to state 109
    c                              shift and go to state 49
    d                              shift and go to state 51
    e                              shift and go to state 52
    f                              shift and go to state 53
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 81

    (47) b -> b AND . c
    (49) c -> . NOT d
    (50) c -> . d
    (51) d -> . d DISTINTO_QUE e
    (52) d -> . d MENOR_QUE e
    (53) d -> . d MENOR_IGUAL_QUE e
    (54) d -> . d MAYOR_QUE e
    (55) d -> . d MAYOR_IGUAL_QUE e
    (56) d -> . d TRIPLE_IGUAL e
    (57) d -> . e
    (58) e -> . e MAS f
    (59) e -> . e MENOS f
    (60) e -> . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 50
    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    c                              shift and go to state 110
    d                              shift and go to state 51
    e                              shift and go to state 52
    f                              shift and go to state 53
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 82

    (49) c -> NOT d .
    (51) d -> d . DISTINTO_QUE e
    (52) d -> d . MENOR_QUE e
    (53) d -> d . MENOR_IGUAL_QUE e
    (54) d -> d . MAYOR_QUE e
    (55) d -> d . MAYOR_IGUAL_QUE e
    (56) d -> d . TRIPLE_IGUAL e

    AND             reduce using rule 49 (c -> NOT d .)
    OR              reduce using rule 49 (c -> NOT d .)
    SEMI_COLON      reduce using rule 49 (c -> NOT d .)
    CONSOLE         reduce using rule 49 (c -> NOT d .)
    LET             reduce using rule 49 (c -> NOT d .)
    LITERAL         reduce using rule 49 (c -> NOT d .)
    IF              reduce using rule 49 (c -> NOT d .)
    WHILE           reduce using rule 49 (c -> NOT d .)
    FOR             reduce using rule 49 (c -> NOT d .)
    INTERFACE       reduce using rule 49 (c -> NOT d .)
    $end            reduce using rule 49 (c -> NOT d .)
    R_LLAVE         reduce using rule 49 (c -> NOT d .)
    R_PAREN         reduce using rule 49 (c -> NOT d .)
    COMA            reduce using rule 49 (c -> NOT d .)
    DISTINTO_QUE    shift and go to state 83
    MENOR_QUE       shift and go to state 84
    MENOR_IGUAL_QUE shift and go to state 85
    MAYOR_QUE       shift and go to state 86
    MAYOR_IGUAL_QUE shift and go to state 87
    TRIPLE_IGUAL    shift and go to state 88


state 83

    (51) d -> d DISTINTO_QUE . e
    (58) e -> . e MAS f
    (59) e -> . e MENOS f
    (60) e -> . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    e                              shift and go to state 111
    f                              shift and go to state 53
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 84

    (52) d -> d MENOR_QUE . e
    (58) e -> . e MAS f
    (59) e -> . e MENOS f
    (60) e -> . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    e                              shift and go to state 112
    f                              shift and go to state 53
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 85

    (53) d -> d MENOR_IGUAL_QUE . e
    (58) e -> . e MAS f
    (59) e -> . e MENOS f
    (60) e -> . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    e                              shift and go to state 113
    f                              shift and go to state 53
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 86

    (54) d -> d MAYOR_QUE . e
    (58) e -> . e MAS f
    (59) e -> . e MENOS f
    (60) e -> . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    e                              shift and go to state 114
    f                              shift and go to state 53
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 87

    (55) d -> d MAYOR_IGUAL_QUE . e
    (58) e -> . e MAS f
    (59) e -> . e MENOS f
    (60) e -> . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    e                              shift and go to state 115
    f                              shift and go to state 53
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 88

    (56) d -> d TRIPLE_IGUAL . e
    (58) e -> . e MAS f
    (59) e -> . e MENOS f
    (60) e -> . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    e                              shift and go to state 116
    f                              shift and go to state 53
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 89

    (58) e -> e MAS . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    f                              shift and go to state 117
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 90

    (59) e -> e MENOS . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    f                              shift and go to state 118
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 91

    (61) f -> f TIMES . g
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    g                              shift and go to state 119
    interface_assi                 shift and go to state 59

state 92

    (62) f -> f DIVIDE . g
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    g                              shift and go to state 120
    interface_assi                 shift and go to state 59

state 93

    (63) f -> f MOD . g
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    g                              shift and go to state 121
    interface_assi                 shift and go to state 59

state 94

    (64) f -> f POTENCIA . g
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    g                              shift and go to state 122
    interface_assi                 shift and go to state 59

state 95

    (66) f -> g PUNTO . nativeFun L_PAREN expresion R_PAREN
    (78) nativeFun -> . TOSTRING
    (79) nativeFun -> . TOFIXED
    (80) nativeFun -> . TOEXPONENTIAL
    (81) nativeFun -> . TOLOWERCASE
    (82) nativeFun -> . TOUPPERCASE
    (83) nativeFun -> . SPLIT
    (84) nativeFun -> . CONCAT

    TOSTRING        shift and go to state 124
    TOFIXED         shift and go to state 125
    TOEXPONENTIAL   shift and go to state 126
    TOLOWERCASE     shift and go to state 127
    TOUPPERCASE     shift and go to state 128
    SPLIT           shift and go to state 129
    CONCAT          shift and go to state 130

    nativeFun                      shift and go to state 123

state 96

    (72) g -> L_PAREN a . R_PAREN
    (45) a -> a . OR b

    R_PAREN         shift and go to state 131
    OR              shift and go to state 80


state 97

    (75) interface_assi -> L_LLAVE atributos_assi . R_LLAVE
    (76) atributos_assi -> atributos_assi . COMA LITERAL COLON a

    R_LLAVE         shift and go to state 132
    COMA            shift and go to state 133


state 98

    (77) atributos_assi -> LITERAL . COLON a

    COLON           shift and go to state 134


state 99

    (32) if_pro -> IF L_PAREN a R_PAREN . L_LLAVE instrucciones R_LLAVE else_pro

    L_LLAVE         shift and go to state 135


state 100

    (36) while_pro -> WHILE L_PAREN a R_PAREN . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 136


state 101

    (37) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON . a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (45) a -> . a OR b
    (46) a -> . b
    (47) b -> . b AND c
    (48) b -> . c
    (49) c -> . NOT d
    (50) c -> . d
    (51) d -> . d DISTINTO_QUE e
    (52) d -> . d MENOR_QUE e
    (53) d -> . d MENOR_IGUAL_QUE e
    (54) d -> . d MAYOR_QUE e
    (55) d -> . d MAYOR_IGUAL_QUE e
    (56) d -> . d TRIPLE_IGUAL e
    (57) d -> . e
    (58) e -> . e MAS f
    (59) e -> . e MENOS f
    (60) e -> . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 50
    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    a                              shift and go to state 137
    b                              shift and go to state 48
    c                              shift and go to state 49
    d                              shift and go to state 51
    e                              shift and go to state 52
    f                              shift and go to state 53
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 102

    (38) for_pro -> FOR L_PAREN assig_pro SEMI_COLON . a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (45) a -> . a OR b
    (46) a -> . b
    (47) b -> . b AND c
    (48) b -> . c
    (49) c -> . NOT d
    (50) c -> . d
    (51) d -> . d DISTINTO_QUE e
    (52) d -> . d MENOR_QUE e
    (53) d -> . d MENOR_IGUAL_QUE e
    (54) d -> . d MAYOR_QUE e
    (55) d -> . d MAYOR_IGUAL_QUE e
    (56) d -> . d TRIPLE_IGUAL e
    (57) d -> . e
    (58) e -> . e MAS f
    (59) e -> . e MENOS f
    (60) e -> . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 50
    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    a                              shift and go to state 138
    b                              shift and go to state 48
    c                              shift and go to state 49
    d                              shift and go to state 51
    e                              shift and go to state 52
    f                              shift and go to state 53
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 103

    (39) for_each_pro -> FOR L_PAREN for_each_dec R_PAREN . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 139


state 104

    (40) for_each_dec -> LET LITERAL . OF a
    (41) for_each_dec -> LET LITERAL . COLON type OF a
    (23) assignacion_instruction -> LITERAL . COLON type IGUAL a
    (24) assignacion_instruction -> LITERAL . COLON type
    (25) assignacion_instruction -> LITERAL . IGUAL a

    OF              shift and go to state 140
    COLON           shift and go to state 141
    IGUAL           shift and go to state 45


state 105

    (15) interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos . R_LLAVE
    (16) interface_atributos -> interface_atributos . interface_atributo sc
    (18) interface_atributo -> . LITERAL COLON type
    (19) interface_atributo -> . LITERAL

    R_LLAVE         shift and go to state 143
    LITERAL         shift and go to state 142

    interface_atributo             shift and go to state 144

state 106

    (42) console_pro -> CONSOLE PUNTO LOG L_PAREN expresion . R_PAREN
    (43) expresion -> expresion . COMA a

    R_PAREN         shift and go to state 145
    COMA            shift and go to state 146


state 107

    (44) expresion -> a .
    (45) a -> a . OR b

    R_PAREN         reduce using rule 44 (expresion -> a .)
    COMA            reduce using rule 44 (expresion -> a .)
    OR              shift and go to state 80


state 108

    (23) assignacion_instruction -> LITERAL COLON type IGUAL . a
    (45) a -> . a OR b
    (46) a -> . b
    (47) b -> . b AND c
    (48) b -> . c
    (49) c -> . NOT d
    (50) c -> . d
    (51) d -> . d DISTINTO_QUE e
    (52) d -> . d MENOR_QUE e
    (53) d -> . d MENOR_IGUAL_QUE e
    (54) d -> . d MAYOR_QUE e
    (55) d -> . d MAYOR_IGUAL_QUE e
    (56) d -> . d TRIPLE_IGUAL e
    (57) d -> . e
    (58) e -> . e MAS f
    (59) e -> . e MENOS f
    (60) e -> . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 50
    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    a                              shift and go to state 147
    b                              shift and go to state 48
    c                              shift and go to state 49
    d                              shift and go to state 51
    e                              shift and go to state 52
    f                              shift and go to state 53
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 109

    (45) a -> a OR b .
    (47) b -> b . AND c

    OR              reduce using rule 45 (a -> a OR b .)
    SEMI_COLON      reduce using rule 45 (a -> a OR b .)
    CONSOLE         reduce using rule 45 (a -> a OR b .)
    LET             reduce using rule 45 (a -> a OR b .)
    LITERAL         reduce using rule 45 (a -> a OR b .)
    IF              reduce using rule 45 (a -> a OR b .)
    WHILE           reduce using rule 45 (a -> a OR b .)
    FOR             reduce using rule 45 (a -> a OR b .)
    INTERFACE       reduce using rule 45 (a -> a OR b .)
    $end            reduce using rule 45 (a -> a OR b .)
    R_LLAVE         reduce using rule 45 (a -> a OR b .)
    R_PAREN         reduce using rule 45 (a -> a OR b .)
    COMA            reduce using rule 45 (a -> a OR b .)
    AND             shift and go to state 81


state 110

    (47) b -> b AND c .

    AND             reduce using rule 47 (b -> b AND c .)
    OR              reduce using rule 47 (b -> b AND c .)
    SEMI_COLON      reduce using rule 47 (b -> b AND c .)
    CONSOLE         reduce using rule 47 (b -> b AND c .)
    LET             reduce using rule 47 (b -> b AND c .)
    LITERAL         reduce using rule 47 (b -> b AND c .)
    IF              reduce using rule 47 (b -> b AND c .)
    WHILE           reduce using rule 47 (b -> b AND c .)
    FOR             reduce using rule 47 (b -> b AND c .)
    INTERFACE       reduce using rule 47 (b -> b AND c .)
    $end            reduce using rule 47 (b -> b AND c .)
    R_LLAVE         reduce using rule 47 (b -> b AND c .)
    R_PAREN         reduce using rule 47 (b -> b AND c .)
    COMA            reduce using rule 47 (b -> b AND c .)


state 111

    (51) d -> d DISTINTO_QUE e .
    (58) e -> e . MAS f
    (59) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 51 (d -> d DISTINTO_QUE e .)
    MENOR_QUE       reduce using rule 51 (d -> d DISTINTO_QUE e .)
    MENOR_IGUAL_QUE reduce using rule 51 (d -> d DISTINTO_QUE e .)
    MAYOR_QUE       reduce using rule 51 (d -> d DISTINTO_QUE e .)
    MAYOR_IGUAL_QUE reduce using rule 51 (d -> d DISTINTO_QUE e .)
    TRIPLE_IGUAL    reduce using rule 51 (d -> d DISTINTO_QUE e .)
    AND             reduce using rule 51 (d -> d DISTINTO_QUE e .)
    OR              reduce using rule 51 (d -> d DISTINTO_QUE e .)
    SEMI_COLON      reduce using rule 51 (d -> d DISTINTO_QUE e .)
    CONSOLE         reduce using rule 51 (d -> d DISTINTO_QUE e .)
    LET             reduce using rule 51 (d -> d DISTINTO_QUE e .)
    LITERAL         reduce using rule 51 (d -> d DISTINTO_QUE e .)
    IF              reduce using rule 51 (d -> d DISTINTO_QUE e .)
    WHILE           reduce using rule 51 (d -> d DISTINTO_QUE e .)
    FOR             reduce using rule 51 (d -> d DISTINTO_QUE e .)
    INTERFACE       reduce using rule 51 (d -> d DISTINTO_QUE e .)
    $end            reduce using rule 51 (d -> d DISTINTO_QUE e .)
    R_LLAVE         reduce using rule 51 (d -> d DISTINTO_QUE e .)
    R_PAREN         reduce using rule 51 (d -> d DISTINTO_QUE e .)
    COMA            reduce using rule 51 (d -> d DISTINTO_QUE e .)
    MAS             shift and go to state 89
    MENOS           shift and go to state 90


state 112

    (52) d -> d MENOR_QUE e .
    (58) e -> e . MAS f
    (59) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 52 (d -> d MENOR_QUE e .)
    MENOR_QUE       reduce using rule 52 (d -> d MENOR_QUE e .)
    MENOR_IGUAL_QUE reduce using rule 52 (d -> d MENOR_QUE e .)
    MAYOR_QUE       reduce using rule 52 (d -> d MENOR_QUE e .)
    MAYOR_IGUAL_QUE reduce using rule 52 (d -> d MENOR_QUE e .)
    TRIPLE_IGUAL    reduce using rule 52 (d -> d MENOR_QUE e .)
    AND             reduce using rule 52 (d -> d MENOR_QUE e .)
    OR              reduce using rule 52 (d -> d MENOR_QUE e .)
    SEMI_COLON      reduce using rule 52 (d -> d MENOR_QUE e .)
    CONSOLE         reduce using rule 52 (d -> d MENOR_QUE e .)
    LET             reduce using rule 52 (d -> d MENOR_QUE e .)
    LITERAL         reduce using rule 52 (d -> d MENOR_QUE e .)
    IF              reduce using rule 52 (d -> d MENOR_QUE e .)
    WHILE           reduce using rule 52 (d -> d MENOR_QUE e .)
    FOR             reduce using rule 52 (d -> d MENOR_QUE e .)
    INTERFACE       reduce using rule 52 (d -> d MENOR_QUE e .)
    $end            reduce using rule 52 (d -> d MENOR_QUE e .)
    R_LLAVE         reduce using rule 52 (d -> d MENOR_QUE e .)
    R_PAREN         reduce using rule 52 (d -> d MENOR_QUE e .)
    COMA            reduce using rule 52 (d -> d MENOR_QUE e .)
    MAS             shift and go to state 89
    MENOS           shift and go to state 90


state 113

    (53) d -> d MENOR_IGUAL_QUE e .
    (58) e -> e . MAS f
    (59) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 53 (d -> d MENOR_IGUAL_QUE e .)
    MENOR_QUE       reduce using rule 53 (d -> d MENOR_IGUAL_QUE e .)
    MENOR_IGUAL_QUE reduce using rule 53 (d -> d MENOR_IGUAL_QUE e .)
    MAYOR_QUE       reduce using rule 53 (d -> d MENOR_IGUAL_QUE e .)
    MAYOR_IGUAL_QUE reduce using rule 53 (d -> d MENOR_IGUAL_QUE e .)
    TRIPLE_IGUAL    reduce using rule 53 (d -> d MENOR_IGUAL_QUE e .)
    AND             reduce using rule 53 (d -> d MENOR_IGUAL_QUE e .)
    OR              reduce using rule 53 (d -> d MENOR_IGUAL_QUE e .)
    SEMI_COLON      reduce using rule 53 (d -> d MENOR_IGUAL_QUE e .)
    CONSOLE         reduce using rule 53 (d -> d MENOR_IGUAL_QUE e .)
    LET             reduce using rule 53 (d -> d MENOR_IGUAL_QUE e .)
    LITERAL         reduce using rule 53 (d -> d MENOR_IGUAL_QUE e .)
    IF              reduce using rule 53 (d -> d MENOR_IGUAL_QUE e .)
    WHILE           reduce using rule 53 (d -> d MENOR_IGUAL_QUE e .)
    FOR             reduce using rule 53 (d -> d MENOR_IGUAL_QUE e .)
    INTERFACE       reduce using rule 53 (d -> d MENOR_IGUAL_QUE e .)
    $end            reduce using rule 53 (d -> d MENOR_IGUAL_QUE e .)
    R_LLAVE         reduce using rule 53 (d -> d MENOR_IGUAL_QUE e .)
    R_PAREN         reduce using rule 53 (d -> d MENOR_IGUAL_QUE e .)
    COMA            reduce using rule 53 (d -> d MENOR_IGUAL_QUE e .)
    MAS             shift and go to state 89
    MENOS           shift and go to state 90


state 114

    (54) d -> d MAYOR_QUE e .
    (58) e -> e . MAS f
    (59) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 54 (d -> d MAYOR_QUE e .)
    MENOR_QUE       reduce using rule 54 (d -> d MAYOR_QUE e .)
    MENOR_IGUAL_QUE reduce using rule 54 (d -> d MAYOR_QUE e .)
    MAYOR_QUE       reduce using rule 54 (d -> d MAYOR_QUE e .)
    MAYOR_IGUAL_QUE reduce using rule 54 (d -> d MAYOR_QUE e .)
    TRIPLE_IGUAL    reduce using rule 54 (d -> d MAYOR_QUE e .)
    AND             reduce using rule 54 (d -> d MAYOR_QUE e .)
    OR              reduce using rule 54 (d -> d MAYOR_QUE e .)
    SEMI_COLON      reduce using rule 54 (d -> d MAYOR_QUE e .)
    CONSOLE         reduce using rule 54 (d -> d MAYOR_QUE e .)
    LET             reduce using rule 54 (d -> d MAYOR_QUE e .)
    LITERAL         reduce using rule 54 (d -> d MAYOR_QUE e .)
    IF              reduce using rule 54 (d -> d MAYOR_QUE e .)
    WHILE           reduce using rule 54 (d -> d MAYOR_QUE e .)
    FOR             reduce using rule 54 (d -> d MAYOR_QUE e .)
    INTERFACE       reduce using rule 54 (d -> d MAYOR_QUE e .)
    $end            reduce using rule 54 (d -> d MAYOR_QUE e .)
    R_LLAVE         reduce using rule 54 (d -> d MAYOR_QUE e .)
    R_PAREN         reduce using rule 54 (d -> d MAYOR_QUE e .)
    COMA            reduce using rule 54 (d -> d MAYOR_QUE e .)
    MAS             shift and go to state 89
    MENOS           shift and go to state 90


state 115

    (55) d -> d MAYOR_IGUAL_QUE e .
    (58) e -> e . MAS f
    (59) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 55 (d -> d MAYOR_IGUAL_QUE e .)
    MENOR_QUE       reduce using rule 55 (d -> d MAYOR_IGUAL_QUE e .)
    MENOR_IGUAL_QUE reduce using rule 55 (d -> d MAYOR_IGUAL_QUE e .)
    MAYOR_QUE       reduce using rule 55 (d -> d MAYOR_IGUAL_QUE e .)
    MAYOR_IGUAL_QUE reduce using rule 55 (d -> d MAYOR_IGUAL_QUE e .)
    TRIPLE_IGUAL    reduce using rule 55 (d -> d MAYOR_IGUAL_QUE e .)
    AND             reduce using rule 55 (d -> d MAYOR_IGUAL_QUE e .)
    OR              reduce using rule 55 (d -> d MAYOR_IGUAL_QUE e .)
    SEMI_COLON      reduce using rule 55 (d -> d MAYOR_IGUAL_QUE e .)
    CONSOLE         reduce using rule 55 (d -> d MAYOR_IGUAL_QUE e .)
    LET             reduce using rule 55 (d -> d MAYOR_IGUAL_QUE e .)
    LITERAL         reduce using rule 55 (d -> d MAYOR_IGUAL_QUE e .)
    IF              reduce using rule 55 (d -> d MAYOR_IGUAL_QUE e .)
    WHILE           reduce using rule 55 (d -> d MAYOR_IGUAL_QUE e .)
    FOR             reduce using rule 55 (d -> d MAYOR_IGUAL_QUE e .)
    INTERFACE       reduce using rule 55 (d -> d MAYOR_IGUAL_QUE e .)
    $end            reduce using rule 55 (d -> d MAYOR_IGUAL_QUE e .)
    R_LLAVE         reduce using rule 55 (d -> d MAYOR_IGUAL_QUE e .)
    R_PAREN         reduce using rule 55 (d -> d MAYOR_IGUAL_QUE e .)
    COMA            reduce using rule 55 (d -> d MAYOR_IGUAL_QUE e .)
    MAS             shift and go to state 89
    MENOS           shift and go to state 90


state 116

    (56) d -> d TRIPLE_IGUAL e .
    (58) e -> e . MAS f
    (59) e -> e . MENOS f

    DISTINTO_QUE    reduce using rule 56 (d -> d TRIPLE_IGUAL e .)
    MENOR_QUE       reduce using rule 56 (d -> d TRIPLE_IGUAL e .)
    MENOR_IGUAL_QUE reduce using rule 56 (d -> d TRIPLE_IGUAL e .)
    MAYOR_QUE       reduce using rule 56 (d -> d TRIPLE_IGUAL e .)
    MAYOR_IGUAL_QUE reduce using rule 56 (d -> d TRIPLE_IGUAL e .)
    TRIPLE_IGUAL    reduce using rule 56 (d -> d TRIPLE_IGUAL e .)
    AND             reduce using rule 56 (d -> d TRIPLE_IGUAL e .)
    OR              reduce using rule 56 (d -> d TRIPLE_IGUAL e .)
    SEMI_COLON      reduce using rule 56 (d -> d TRIPLE_IGUAL e .)
    CONSOLE         reduce using rule 56 (d -> d TRIPLE_IGUAL e .)
    LET             reduce using rule 56 (d -> d TRIPLE_IGUAL e .)
    LITERAL         reduce using rule 56 (d -> d TRIPLE_IGUAL e .)
    IF              reduce using rule 56 (d -> d TRIPLE_IGUAL e .)
    WHILE           reduce using rule 56 (d -> d TRIPLE_IGUAL e .)
    FOR             reduce using rule 56 (d -> d TRIPLE_IGUAL e .)
    INTERFACE       reduce using rule 56 (d -> d TRIPLE_IGUAL e .)
    $end            reduce using rule 56 (d -> d TRIPLE_IGUAL e .)
    R_LLAVE         reduce using rule 56 (d -> d TRIPLE_IGUAL e .)
    R_PAREN         reduce using rule 56 (d -> d TRIPLE_IGUAL e .)
    COMA            reduce using rule 56 (d -> d TRIPLE_IGUAL e .)
    MAS             shift and go to state 89
    MENOS           shift and go to state 90


state 117

    (58) e -> e MAS f .
    (61) f -> f . TIMES g
    (62) f -> f . DIVIDE g
    (63) f -> f . MOD g
    (64) f -> f . POTENCIA g

    MAS             reduce using rule 58 (e -> e MAS f .)
    MENOS           reduce using rule 58 (e -> e MAS f .)
    DISTINTO_QUE    reduce using rule 58 (e -> e MAS f .)
    MENOR_QUE       reduce using rule 58 (e -> e MAS f .)
    MENOR_IGUAL_QUE reduce using rule 58 (e -> e MAS f .)
    MAYOR_QUE       reduce using rule 58 (e -> e MAS f .)
    MAYOR_IGUAL_QUE reduce using rule 58 (e -> e MAS f .)
    TRIPLE_IGUAL    reduce using rule 58 (e -> e MAS f .)
    AND             reduce using rule 58 (e -> e MAS f .)
    OR              reduce using rule 58 (e -> e MAS f .)
    SEMI_COLON      reduce using rule 58 (e -> e MAS f .)
    CONSOLE         reduce using rule 58 (e -> e MAS f .)
    LET             reduce using rule 58 (e -> e MAS f .)
    LITERAL         reduce using rule 58 (e -> e MAS f .)
    IF              reduce using rule 58 (e -> e MAS f .)
    WHILE           reduce using rule 58 (e -> e MAS f .)
    FOR             reduce using rule 58 (e -> e MAS f .)
    INTERFACE       reduce using rule 58 (e -> e MAS f .)
    $end            reduce using rule 58 (e -> e MAS f .)
    R_LLAVE         reduce using rule 58 (e -> e MAS f .)
    R_PAREN         reduce using rule 58 (e -> e MAS f .)
    COMA            reduce using rule 58 (e -> e MAS f .)
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MOD             shift and go to state 93
    POTENCIA        shift and go to state 94


state 118

    (59) e -> e MENOS f .
    (61) f -> f . TIMES g
    (62) f -> f . DIVIDE g
    (63) f -> f . MOD g
    (64) f -> f . POTENCIA g

    MAS             reduce using rule 59 (e -> e MENOS f .)
    MENOS           reduce using rule 59 (e -> e MENOS f .)
    DISTINTO_QUE    reduce using rule 59 (e -> e MENOS f .)
    MENOR_QUE       reduce using rule 59 (e -> e MENOS f .)
    MENOR_IGUAL_QUE reduce using rule 59 (e -> e MENOS f .)
    MAYOR_QUE       reduce using rule 59 (e -> e MENOS f .)
    MAYOR_IGUAL_QUE reduce using rule 59 (e -> e MENOS f .)
    TRIPLE_IGUAL    reduce using rule 59 (e -> e MENOS f .)
    AND             reduce using rule 59 (e -> e MENOS f .)
    OR              reduce using rule 59 (e -> e MENOS f .)
    SEMI_COLON      reduce using rule 59 (e -> e MENOS f .)
    CONSOLE         reduce using rule 59 (e -> e MENOS f .)
    LET             reduce using rule 59 (e -> e MENOS f .)
    LITERAL         reduce using rule 59 (e -> e MENOS f .)
    IF              reduce using rule 59 (e -> e MENOS f .)
    WHILE           reduce using rule 59 (e -> e MENOS f .)
    FOR             reduce using rule 59 (e -> e MENOS f .)
    INTERFACE       reduce using rule 59 (e -> e MENOS f .)
    $end            reduce using rule 59 (e -> e MENOS f .)
    R_LLAVE         reduce using rule 59 (e -> e MENOS f .)
    R_PAREN         reduce using rule 59 (e -> e MENOS f .)
    COMA            reduce using rule 59 (e -> e MENOS f .)
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MOD             shift and go to state 93
    POTENCIA        shift and go to state 94


state 119

    (61) f -> f TIMES g .

    TIMES           reduce using rule 61 (f -> f TIMES g .)
    DIVIDE          reduce using rule 61 (f -> f TIMES g .)
    MOD             reduce using rule 61 (f -> f TIMES g .)
    POTENCIA        reduce using rule 61 (f -> f TIMES g .)
    MAS             reduce using rule 61 (f -> f TIMES g .)
    MENOS           reduce using rule 61 (f -> f TIMES g .)
    DISTINTO_QUE    reduce using rule 61 (f -> f TIMES g .)
    MENOR_QUE       reduce using rule 61 (f -> f TIMES g .)
    MENOR_IGUAL_QUE reduce using rule 61 (f -> f TIMES g .)
    MAYOR_QUE       reduce using rule 61 (f -> f TIMES g .)
    MAYOR_IGUAL_QUE reduce using rule 61 (f -> f TIMES g .)
    TRIPLE_IGUAL    reduce using rule 61 (f -> f TIMES g .)
    AND             reduce using rule 61 (f -> f TIMES g .)
    OR              reduce using rule 61 (f -> f TIMES g .)
    SEMI_COLON      reduce using rule 61 (f -> f TIMES g .)
    CONSOLE         reduce using rule 61 (f -> f TIMES g .)
    LET             reduce using rule 61 (f -> f TIMES g .)
    LITERAL         reduce using rule 61 (f -> f TIMES g .)
    IF              reduce using rule 61 (f -> f TIMES g .)
    WHILE           reduce using rule 61 (f -> f TIMES g .)
    FOR             reduce using rule 61 (f -> f TIMES g .)
    INTERFACE       reduce using rule 61 (f -> f TIMES g .)
    $end            reduce using rule 61 (f -> f TIMES g .)
    R_LLAVE         reduce using rule 61 (f -> f TIMES g .)
    R_PAREN         reduce using rule 61 (f -> f TIMES g .)
    COMA            reduce using rule 61 (f -> f TIMES g .)


state 120

    (62) f -> f DIVIDE g .

    TIMES           reduce using rule 62 (f -> f DIVIDE g .)
    DIVIDE          reduce using rule 62 (f -> f DIVIDE g .)
    MOD             reduce using rule 62 (f -> f DIVIDE g .)
    POTENCIA        reduce using rule 62 (f -> f DIVIDE g .)
    MAS             reduce using rule 62 (f -> f DIVIDE g .)
    MENOS           reduce using rule 62 (f -> f DIVIDE g .)
    DISTINTO_QUE    reduce using rule 62 (f -> f DIVIDE g .)
    MENOR_QUE       reduce using rule 62 (f -> f DIVIDE g .)
    MENOR_IGUAL_QUE reduce using rule 62 (f -> f DIVIDE g .)
    MAYOR_QUE       reduce using rule 62 (f -> f DIVIDE g .)
    MAYOR_IGUAL_QUE reduce using rule 62 (f -> f DIVIDE g .)
    TRIPLE_IGUAL    reduce using rule 62 (f -> f DIVIDE g .)
    AND             reduce using rule 62 (f -> f DIVIDE g .)
    OR              reduce using rule 62 (f -> f DIVIDE g .)
    SEMI_COLON      reduce using rule 62 (f -> f DIVIDE g .)
    CONSOLE         reduce using rule 62 (f -> f DIVIDE g .)
    LET             reduce using rule 62 (f -> f DIVIDE g .)
    LITERAL         reduce using rule 62 (f -> f DIVIDE g .)
    IF              reduce using rule 62 (f -> f DIVIDE g .)
    WHILE           reduce using rule 62 (f -> f DIVIDE g .)
    FOR             reduce using rule 62 (f -> f DIVIDE g .)
    INTERFACE       reduce using rule 62 (f -> f DIVIDE g .)
    $end            reduce using rule 62 (f -> f DIVIDE g .)
    R_LLAVE         reduce using rule 62 (f -> f DIVIDE g .)
    R_PAREN         reduce using rule 62 (f -> f DIVIDE g .)
    COMA            reduce using rule 62 (f -> f DIVIDE g .)


state 121

    (63) f -> f MOD g .

    TIMES           reduce using rule 63 (f -> f MOD g .)
    DIVIDE          reduce using rule 63 (f -> f MOD g .)
    MOD             reduce using rule 63 (f -> f MOD g .)
    POTENCIA        reduce using rule 63 (f -> f MOD g .)
    MAS             reduce using rule 63 (f -> f MOD g .)
    MENOS           reduce using rule 63 (f -> f MOD g .)
    DISTINTO_QUE    reduce using rule 63 (f -> f MOD g .)
    MENOR_QUE       reduce using rule 63 (f -> f MOD g .)
    MENOR_IGUAL_QUE reduce using rule 63 (f -> f MOD g .)
    MAYOR_QUE       reduce using rule 63 (f -> f MOD g .)
    MAYOR_IGUAL_QUE reduce using rule 63 (f -> f MOD g .)
    TRIPLE_IGUAL    reduce using rule 63 (f -> f MOD g .)
    AND             reduce using rule 63 (f -> f MOD g .)
    OR              reduce using rule 63 (f -> f MOD g .)
    SEMI_COLON      reduce using rule 63 (f -> f MOD g .)
    CONSOLE         reduce using rule 63 (f -> f MOD g .)
    LET             reduce using rule 63 (f -> f MOD g .)
    LITERAL         reduce using rule 63 (f -> f MOD g .)
    IF              reduce using rule 63 (f -> f MOD g .)
    WHILE           reduce using rule 63 (f -> f MOD g .)
    FOR             reduce using rule 63 (f -> f MOD g .)
    INTERFACE       reduce using rule 63 (f -> f MOD g .)
    $end            reduce using rule 63 (f -> f MOD g .)
    R_LLAVE         reduce using rule 63 (f -> f MOD g .)
    R_PAREN         reduce using rule 63 (f -> f MOD g .)
    COMA            reduce using rule 63 (f -> f MOD g .)


state 122

    (64) f -> f POTENCIA g .

    TIMES           reduce using rule 64 (f -> f POTENCIA g .)
    DIVIDE          reduce using rule 64 (f -> f POTENCIA g .)
    MOD             reduce using rule 64 (f -> f POTENCIA g .)
    POTENCIA        reduce using rule 64 (f -> f POTENCIA g .)
    MAS             reduce using rule 64 (f -> f POTENCIA g .)
    MENOS           reduce using rule 64 (f -> f POTENCIA g .)
    DISTINTO_QUE    reduce using rule 64 (f -> f POTENCIA g .)
    MENOR_QUE       reduce using rule 64 (f -> f POTENCIA g .)
    MENOR_IGUAL_QUE reduce using rule 64 (f -> f POTENCIA g .)
    MAYOR_QUE       reduce using rule 64 (f -> f POTENCIA g .)
    MAYOR_IGUAL_QUE reduce using rule 64 (f -> f POTENCIA g .)
    TRIPLE_IGUAL    reduce using rule 64 (f -> f POTENCIA g .)
    AND             reduce using rule 64 (f -> f POTENCIA g .)
    OR              reduce using rule 64 (f -> f POTENCIA g .)
    SEMI_COLON      reduce using rule 64 (f -> f POTENCIA g .)
    CONSOLE         reduce using rule 64 (f -> f POTENCIA g .)
    LET             reduce using rule 64 (f -> f POTENCIA g .)
    LITERAL         reduce using rule 64 (f -> f POTENCIA g .)
    IF              reduce using rule 64 (f -> f POTENCIA g .)
    WHILE           reduce using rule 64 (f -> f POTENCIA g .)
    FOR             reduce using rule 64 (f -> f POTENCIA g .)
    INTERFACE       reduce using rule 64 (f -> f POTENCIA g .)
    $end            reduce using rule 64 (f -> f POTENCIA g .)
    R_LLAVE         reduce using rule 64 (f -> f POTENCIA g .)
    R_PAREN         reduce using rule 64 (f -> f POTENCIA g .)
    COMA            reduce using rule 64 (f -> f POTENCIA g .)


state 123

    (66) f -> g PUNTO nativeFun . L_PAREN expresion R_PAREN

    L_PAREN         shift and go to state 148


state 124

    (78) nativeFun -> TOSTRING .

    L_PAREN         reduce using rule 78 (nativeFun -> TOSTRING .)


state 125

    (79) nativeFun -> TOFIXED .

    L_PAREN         reduce using rule 79 (nativeFun -> TOFIXED .)


state 126

    (80) nativeFun -> TOEXPONENTIAL .

    L_PAREN         reduce using rule 80 (nativeFun -> TOEXPONENTIAL .)


state 127

    (81) nativeFun -> TOLOWERCASE .

    L_PAREN         reduce using rule 81 (nativeFun -> TOLOWERCASE .)


state 128

    (82) nativeFun -> TOUPPERCASE .

    L_PAREN         reduce using rule 82 (nativeFun -> TOUPPERCASE .)


state 129

    (83) nativeFun -> SPLIT .

    L_PAREN         reduce using rule 83 (nativeFun -> SPLIT .)


state 130

    (84) nativeFun -> CONCAT .

    L_PAREN         reduce using rule 84 (nativeFun -> CONCAT .)


state 131

    (72) g -> L_PAREN a R_PAREN .

    PUNTO           reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    TIMES           reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    DIVIDE          reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    MOD             reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    POTENCIA        reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    MAS             reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    MENOS           reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    DISTINTO_QUE    reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    MENOR_QUE       reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    MENOR_IGUAL_QUE reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    MAYOR_QUE       reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    MAYOR_IGUAL_QUE reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    TRIPLE_IGUAL    reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    AND             reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    OR              reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    SEMI_COLON      reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    CONSOLE         reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    LET             reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    LITERAL         reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    IF              reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    WHILE           reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    FOR             reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    INTERFACE       reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    $end            reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    R_LLAVE         reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    R_PAREN         reduce using rule 72 (g -> L_PAREN a R_PAREN .)
    COMA            reduce using rule 72 (g -> L_PAREN a R_PAREN .)


state 132

    (75) interface_assi -> L_LLAVE atributos_assi R_LLAVE .

    PUNTO           reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    TIMES           reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    DIVIDE          reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MOD             reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    POTENCIA        reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MAS             reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MENOS           reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    DISTINTO_QUE    reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MENOR_QUE       reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MENOR_IGUAL_QUE reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MAYOR_QUE       reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MAYOR_IGUAL_QUE reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    TRIPLE_IGUAL    reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    AND             reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    OR              reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    SEMI_COLON      reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    CONSOLE         reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    LET             reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    LITERAL         reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    IF              reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    WHILE           reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    FOR             reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    INTERFACE       reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    $end            reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    R_LLAVE         reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    R_PAREN         reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    COMA            reduce using rule 75 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)


state 133

    (76) atributos_assi -> atributos_assi COMA . LITERAL COLON a

    LITERAL         shift and go to state 149


state 134

    (77) atributos_assi -> LITERAL COLON . a
    (45) a -> . a OR b
    (46) a -> . b
    (47) b -> . b AND c
    (48) b -> . c
    (49) c -> . NOT d
    (50) c -> . d
    (51) d -> . d DISTINTO_QUE e
    (52) d -> . d MENOR_QUE e
    (53) d -> . d MENOR_IGUAL_QUE e
    (54) d -> . d MAYOR_QUE e
    (55) d -> . d MAYOR_IGUAL_QUE e
    (56) d -> . d TRIPLE_IGUAL e
    (57) d -> . e
    (58) e -> . e MAS f
    (59) e -> . e MENOS f
    (60) e -> . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 50
    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    a                              shift and go to state 150
    b                              shift and go to state 48
    c                              shift and go to state 49
    d                              shift and go to state 51
    e                              shift and go to state 52
    f                              shift and go to state 53
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 135

    (32) if_pro -> IF L_PAREN a R_PAREN L_LLAVE . instrucciones R_LLAVE else_pro
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . sumadores sc
    (42) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (20) declaration_instruction -> . LET declaracion_list
    (31) assig_pro -> . LITERAL IGUAL a
    (32) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (36) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (37) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (38) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (39) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (15) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (73) sumadores -> . LITERAL MAS MAS
    (74) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 13
    LET             shift and go to state 14
    LITERAL         shift and go to state 15
    IF              shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    INTERFACE       shift and go to state 19

    instrucciones                  shift and go to state 151
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    sumadores                      shift and go to state 12

state 136

    (36) while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . sumadores sc
    (42) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (20) declaration_instruction -> . LET declaracion_list
    (31) assig_pro -> . LITERAL IGUAL a
    (32) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (36) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (37) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (38) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (39) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (15) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (73) sumadores -> . LITERAL MAS MAS
    (74) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 13
    LET             shift and go to state 14
    LITERAL         shift and go to state 15
    IF              shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    INTERFACE       shift and go to state 19

    instrucciones                  shift and go to state 152
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    sumadores                      shift and go to state 12

state 137

    (37) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a . SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (45) a -> a . OR b

    SEMI_COLON      shift and go to state 153
    OR              shift and go to state 80


state 138

    (38) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a . SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (45) a -> a . OR b

    SEMI_COLON      shift and go to state 154
    OR              shift and go to state 80


state 139

    (39) for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . sumadores sc
    (42) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (20) declaration_instruction -> . LET declaracion_list
    (31) assig_pro -> . LITERAL IGUAL a
    (32) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (36) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (37) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (38) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (39) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (15) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (73) sumadores -> . LITERAL MAS MAS
    (74) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 13
    LET             shift and go to state 14
    LITERAL         shift and go to state 15
    IF              shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    INTERFACE       shift and go to state 19

    instrucciones                  shift and go to state 155
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    sumadores                      shift and go to state 12

state 140

    (40) for_each_dec -> LET LITERAL OF . a
    (45) a -> . a OR b
    (46) a -> . b
    (47) b -> . b AND c
    (48) b -> . c
    (49) c -> . NOT d
    (50) c -> . d
    (51) d -> . d DISTINTO_QUE e
    (52) d -> . d MENOR_QUE e
    (53) d -> . d MENOR_IGUAL_QUE e
    (54) d -> . d MAYOR_QUE e
    (55) d -> . d MAYOR_IGUAL_QUE e
    (56) d -> . d TRIPLE_IGUAL e
    (57) d -> . e
    (58) e -> . e MAS f
    (59) e -> . e MENOS f
    (60) e -> . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 50
    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    a                              shift and go to state 156
    b                              shift and go to state 48
    c                              shift and go to state 49
    d                              shift and go to state 51
    e                              shift and go to state 52
    f                              shift and go to state 53
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 141

    (41) for_each_dec -> LET LITERAL COLON . type OF a
    (23) assignacion_instruction -> LITERAL COLON . type IGUAL a
    (24) assignacion_instruction -> LITERAL COLON . type
    (26) type -> . NUMBER
    (27) type -> . STRING
    (28) type -> . BOOLEAN
    (29) type -> . ANY
    (30) type -> . LITERAL

    NUMBER          shift and go to state 75
    STRING          shift and go to state 76
    BOOLEAN         shift and go to state 77
    ANY             shift and go to state 78
    LITERAL         shift and go to state 73

    type                           shift and go to state 157

state 142

    (18) interface_atributo -> LITERAL . COLON type
    (19) interface_atributo -> LITERAL .

    COLON           shift and go to state 158
    SEMI_COLON      reduce using rule 19 (interface_atributo -> LITERAL .)
    R_LLAVE         reduce using rule 19 (interface_atributo -> LITERAL .)
    LITERAL         reduce using rule 19 (interface_atributo -> LITERAL .)


state 143

    (15) interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .

    SEMI_COLON      reduce using rule 15 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    CONSOLE         reduce using rule 15 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    LET             reduce using rule 15 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    LITERAL         reduce using rule 15 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    IF              reduce using rule 15 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    WHILE           reduce using rule 15 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    FOR             reduce using rule 15 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    INTERFACE       reduce using rule 15 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    $end            reduce using rule 15 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    R_LLAVE         reduce using rule 15 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)


state 144

    (16) interface_atributos -> interface_atributos interface_atributo . sc
    (13) sc -> . SEMI_COLON
    (14) sc -> .

    SEMI_COLON      shift and go to state 22
    R_LLAVE         reduce using rule 14 (sc -> .)
    LITERAL         reduce using rule 14 (sc -> .)

    sc                             shift and go to state 159

state 145

    (42) console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .

    SEMI_COLON      reduce using rule 42 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    CONSOLE         reduce using rule 42 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    LET             reduce using rule 42 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    LITERAL         reduce using rule 42 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    IF              reduce using rule 42 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    WHILE           reduce using rule 42 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    FOR             reduce using rule 42 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    INTERFACE       reduce using rule 42 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    $end            reduce using rule 42 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    R_LLAVE         reduce using rule 42 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)


state 146

    (43) expresion -> expresion COMA . a
    (45) a -> . a OR b
    (46) a -> . b
    (47) b -> . b AND c
    (48) b -> . c
    (49) c -> . NOT d
    (50) c -> . d
    (51) d -> . d DISTINTO_QUE e
    (52) d -> . d MENOR_QUE e
    (53) d -> . d MENOR_IGUAL_QUE e
    (54) d -> . d MAYOR_QUE e
    (55) d -> . d MAYOR_IGUAL_QUE e
    (56) d -> . d TRIPLE_IGUAL e
    (57) d -> . e
    (58) e -> . e MAS f
    (59) e -> . e MENOS f
    (60) e -> . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 50
    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    a                              shift and go to state 160
    b                              shift and go to state 48
    c                              shift and go to state 49
    d                              shift and go to state 51
    e                              shift and go to state 52
    f                              shift and go to state 53
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 147

    (23) assignacion_instruction -> LITERAL COLON type IGUAL a .
    (45) a -> a . OR b

    COMA            reduce using rule 23 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    SEMI_COLON      reduce using rule 23 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    CONSOLE         reduce using rule 23 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    LET             reduce using rule 23 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    LITERAL         reduce using rule 23 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    IF              reduce using rule 23 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    WHILE           reduce using rule 23 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    FOR             reduce using rule 23 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    INTERFACE       reduce using rule 23 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    $end            reduce using rule 23 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    R_LLAVE         reduce using rule 23 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    OR              shift and go to state 80


state 148

    (66) f -> g PUNTO nativeFun L_PAREN . expresion R_PAREN
    (43) expresion -> . expresion COMA a
    (44) expresion -> . a
    (45) a -> . a OR b
    (46) a -> . b
    (47) b -> . b AND c
    (48) b -> . c
    (49) c -> . NOT d
    (50) c -> . d
    (51) d -> . d DISTINTO_QUE e
    (52) d -> . d MENOR_QUE e
    (53) d -> . d MENOR_IGUAL_QUE e
    (54) d -> . d MAYOR_QUE e
    (55) d -> . d MAYOR_IGUAL_QUE e
    (56) d -> . d TRIPLE_IGUAL e
    (57) d -> . e
    (58) e -> . e MAS f
    (59) e -> . e MENOS f
    (60) e -> . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 50
    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    g                              shift and go to state 54
    expresion                      shift and go to state 161
    a                              shift and go to state 107
    b                              shift and go to state 48
    c                              shift and go to state 49
    d                              shift and go to state 51
    e                              shift and go to state 52
    f                              shift and go to state 53
    interface_assi                 shift and go to state 59

state 149

    (76) atributos_assi -> atributos_assi COMA LITERAL . COLON a

    COLON           shift and go to state 162


state 150

    (77) atributos_assi -> LITERAL COLON a .
    (45) a -> a . OR b

    R_LLAVE         reduce using rule 77 (atributos_assi -> LITERAL COLON a .)
    COMA            reduce using rule 77 (atributos_assi -> LITERAL COLON a .)
    OR              shift and go to state 80


state 151

    (32) if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones . R_LLAVE else_pro
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . sumadores sc
    (42) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (20) declaration_instruction -> . LET declaracion_list
    (31) assig_pro -> . LITERAL IGUAL a
    (32) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (36) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (37) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (38) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (39) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (15) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (73) sumadores -> . LITERAL MAS MAS
    (74) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 163
    CONSOLE         shift and go to state 13
    LET             shift and go to state 14
    LITERAL         shift and go to state 15
    IF              shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    INTERFACE       shift and go to state 19

    instruccion                    shift and go to state 20
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    sumadores                      shift and go to state 12

state 152

    (36) while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . sumadores sc
    (42) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (20) declaration_instruction -> . LET declaracion_list
    (31) assig_pro -> . LITERAL IGUAL a
    (32) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (36) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (37) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (38) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (39) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (15) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (73) sumadores -> . LITERAL MAS MAS
    (74) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 164
    CONSOLE         shift and go to state 13
    LET             shift and go to state 14
    LITERAL         shift and go to state 15
    IF              shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    INTERFACE       shift and go to state 19

    instruccion                    shift and go to state 20
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    sumadores                      shift and go to state 12

state 153

    (37) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON . assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (31) assig_pro -> . LITERAL IGUAL a

    LITERAL         shift and go to state 69

    assig_pro                      shift and go to state 165

state 154

    (38) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON . assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (31) assig_pro -> . LITERAL IGUAL a

    LITERAL         shift and go to state 69

    assig_pro                      shift and go to state 166

state 155

    (39) for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . sumadores sc
    (42) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (20) declaration_instruction -> . LET declaracion_list
    (31) assig_pro -> . LITERAL IGUAL a
    (32) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (36) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (37) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (38) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (39) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (15) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (73) sumadores -> . LITERAL MAS MAS
    (74) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 167
    CONSOLE         shift and go to state 13
    LET             shift and go to state 14
    LITERAL         shift and go to state 15
    IF              shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    INTERFACE       shift and go to state 19

    instruccion                    shift and go to state 20
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    sumadores                      shift and go to state 12

state 156

    (40) for_each_dec -> LET LITERAL OF a .
    (45) a -> a . OR b

    R_PAREN         reduce using rule 40 (for_each_dec -> LET LITERAL OF a .)
    OR              shift and go to state 80


state 157

    (41) for_each_dec -> LET LITERAL COLON type . OF a
    (23) assignacion_instruction -> LITERAL COLON type . IGUAL a
    (24) assignacion_instruction -> LITERAL COLON type .

    OF              shift and go to state 168
    IGUAL           shift and go to state 108
    COMA            reduce using rule 24 (assignacion_instruction -> LITERAL COLON type .)
    SEMI_COLON      reduce using rule 24 (assignacion_instruction -> LITERAL COLON type .)


state 158

    (18) interface_atributo -> LITERAL COLON . type
    (26) type -> . NUMBER
    (27) type -> . STRING
    (28) type -> . BOOLEAN
    (29) type -> . ANY
    (30) type -> . LITERAL

    NUMBER          shift and go to state 75
    STRING          shift and go to state 76
    BOOLEAN         shift and go to state 77
    ANY             shift and go to state 78
    LITERAL         shift and go to state 73

    type                           shift and go to state 169

state 159

    (16) interface_atributos -> interface_atributos interface_atributo sc .

    R_LLAVE         reduce using rule 16 (interface_atributos -> interface_atributos interface_atributo sc .)
    LITERAL         reduce using rule 16 (interface_atributos -> interface_atributos interface_atributo sc .)


state 160

    (43) expresion -> expresion COMA a .
    (45) a -> a . OR b

    R_PAREN         reduce using rule 43 (expresion -> expresion COMA a .)
    COMA            reduce using rule 43 (expresion -> expresion COMA a .)
    OR              shift and go to state 80


state 161

    (66) f -> g PUNTO nativeFun L_PAREN expresion . R_PAREN
    (43) expresion -> expresion . COMA a

    R_PAREN         shift and go to state 170
    COMA            shift and go to state 146


state 162

    (76) atributos_assi -> atributos_assi COMA LITERAL COLON . a
    (45) a -> . a OR b
    (46) a -> . b
    (47) b -> . b AND c
    (48) b -> . c
    (49) c -> . NOT d
    (50) c -> . d
    (51) d -> . d DISTINTO_QUE e
    (52) d -> . d MENOR_QUE e
    (53) d -> . d MENOR_IGUAL_QUE e
    (54) d -> . d MAYOR_QUE e
    (55) d -> . d MAYOR_IGUAL_QUE e
    (56) d -> . d TRIPLE_IGUAL e
    (57) d -> . e
    (58) e -> . e MAS f
    (59) e -> . e MENOS f
    (60) e -> . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 50
    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    a                              shift and go to state 171
    b                              shift and go to state 48
    c                              shift and go to state 49
    d                              shift and go to state 51
    e                              shift and go to state 52
    f                              shift and go to state 53
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 163

    (32) if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE . else_pro
    (33) else_pro -> . ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (34) else_pro -> . ELSE L_LLAVE instrucciones R_LLAVE
    (35) else_pro -> .

    ELSE            shift and go to state 173
    SEMI_COLON      reduce using rule 35 (else_pro -> .)
    CONSOLE         reduce using rule 35 (else_pro -> .)
    LET             reduce using rule 35 (else_pro -> .)
    LITERAL         reduce using rule 35 (else_pro -> .)
    IF              reduce using rule 35 (else_pro -> .)
    WHILE           reduce using rule 35 (else_pro -> .)
    FOR             reduce using rule 35 (else_pro -> .)
    INTERFACE       reduce using rule 35 (else_pro -> .)
    $end            reduce using rule 35 (else_pro -> .)
    R_LLAVE         reduce using rule 35 (else_pro -> .)

    else_pro                       shift and go to state 172

state 164

    (36) while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 36 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 36 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 36 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 36 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 36 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 36 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 36 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 36 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 36 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 36 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 165

    (37) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro . R_PAREN L_LLAVE instrucciones R_LLAVE

    R_PAREN         shift and go to state 174


state 166

    (38) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro . R_PAREN L_LLAVE instrucciones R_LLAVE

    R_PAREN         shift and go to state 175


state 167

    (39) for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 39 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 39 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 39 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 39 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 39 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 39 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 39 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 39 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 39 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 39 (for_each_pro -> FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 168

    (41) for_each_dec -> LET LITERAL COLON type OF . a
    (45) a -> . a OR b
    (46) a -> . b
    (47) b -> . b AND c
    (48) b -> . c
    (49) c -> . NOT d
    (50) c -> . d
    (51) d -> . d DISTINTO_QUE e
    (52) d -> . d MENOR_QUE e
    (53) d -> . d MENOR_IGUAL_QUE e
    (54) d -> . d MAYOR_QUE e
    (55) d -> . d MAYOR_IGUAL_QUE e
    (56) d -> . d TRIPLE_IGUAL e
    (57) d -> . e
    (58) e -> . e MAS f
    (59) e -> . e MENOS f
    (60) e -> . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 50
    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    a                              shift and go to state 176
    b                              shift and go to state 48
    c                              shift and go to state 49
    d                              shift and go to state 51
    e                              shift and go to state 52
    f                              shift and go to state 53
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 169

    (18) interface_atributo -> LITERAL COLON type .

    SEMI_COLON      reduce using rule 18 (interface_atributo -> LITERAL COLON type .)
    R_LLAVE         reduce using rule 18 (interface_atributo -> LITERAL COLON type .)
    LITERAL         reduce using rule 18 (interface_atributo -> LITERAL COLON type .)


state 170

    (66) f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .

    TIMES           reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    DIVIDE          reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MOD             reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    POTENCIA        reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MAS             reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MENOS           reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    DISTINTO_QUE    reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MENOR_QUE       reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MENOR_IGUAL_QUE reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MAYOR_QUE       reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MAYOR_IGUAL_QUE reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    TRIPLE_IGUAL    reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    AND             reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    OR              reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    SEMI_COLON      reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    CONSOLE         reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    LET             reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    LITERAL         reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    IF              reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    WHILE           reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    FOR             reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    INTERFACE       reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    $end            reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    R_LLAVE         reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    R_PAREN         reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)
    COMA            reduce using rule 66 (f -> g PUNTO nativeFun L_PAREN expresion R_PAREN .)


state 171

    (76) atributos_assi -> atributos_assi COMA LITERAL COLON a .
    (45) a -> a . OR b

    R_LLAVE         reduce using rule 76 (atributos_assi -> atributos_assi COMA LITERAL COLON a .)
    COMA            reduce using rule 76 (atributos_assi -> atributos_assi COMA LITERAL COLON a .)
    OR              shift and go to state 80


state 172

    (32) if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .

    SEMI_COLON      reduce using rule 32 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    CONSOLE         reduce using rule 32 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    LET             reduce using rule 32 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    LITERAL         reduce using rule 32 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    IF              reduce using rule 32 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    WHILE           reduce using rule 32 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    FOR             reduce using rule 32 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    INTERFACE       reduce using rule 32 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    $end            reduce using rule 32 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    R_LLAVE         reduce using rule 32 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)


state 173

    (33) else_pro -> ELSE . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (34) else_pro -> ELSE . L_LLAVE instrucciones R_LLAVE

    IF              shift and go to state 177
    L_LLAVE         shift and go to state 178


state 174

    (37) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 179


state 175

    (38) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 180


state 176

    (41) for_each_dec -> LET LITERAL COLON type OF a .
    (45) a -> a . OR b

    R_PAREN         reduce using rule 41 (for_each_dec -> LET LITERAL COLON type OF a .)
    OR              shift and go to state 80


state 177

    (33) else_pro -> ELSE IF . L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro

    L_PAREN         shift and go to state 181


state 178

    (34) else_pro -> ELSE L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . sumadores sc
    (42) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (20) declaration_instruction -> . LET declaracion_list
    (31) assig_pro -> . LITERAL IGUAL a
    (32) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (36) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (37) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (38) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (39) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (15) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (73) sumadores -> . LITERAL MAS MAS
    (74) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 13
    LET             shift and go to state 14
    LITERAL         shift and go to state 15
    IF              shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    INTERFACE       shift and go to state 19

    instrucciones                  shift and go to state 182
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    sumadores                      shift and go to state 12

state 179

    (37) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . sumadores sc
    (42) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (20) declaration_instruction -> . LET declaracion_list
    (31) assig_pro -> . LITERAL IGUAL a
    (32) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (36) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (37) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (38) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (39) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (15) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (73) sumadores -> . LITERAL MAS MAS
    (74) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 13
    LET             shift and go to state 14
    LITERAL         shift and go to state 15
    IF              shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    INTERFACE       shift and go to state 19

    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    instrucciones                  shift and go to state 183
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    sumadores                      shift and go to state 12

state 180

    (38) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . sumadores sc
    (42) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (20) declaration_instruction -> . LET declaracion_list
    (31) assig_pro -> . LITERAL IGUAL a
    (32) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (36) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (37) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (38) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (39) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (15) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (73) sumadores -> . LITERAL MAS MAS
    (74) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 13
    LET             shift and go to state 14
    LITERAL         shift and go to state 15
    IF              shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    INTERFACE       shift and go to state 19

    assig_pro                      shift and go to state 6
    instrucciones                  shift and go to state 184
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    sumadores                      shift and go to state 12

state 181

    (33) else_pro -> ELSE IF L_PAREN . a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (45) a -> . a OR b
    (46) a -> . b
    (47) b -> . b AND c
    (48) b -> . c
    (49) c -> . NOT d
    (50) c -> . d
    (51) d -> . d DISTINTO_QUE e
    (52) d -> . d MENOR_QUE e
    (53) d -> . d MENOR_IGUAL_QUE e
    (54) d -> . d MAYOR_QUE e
    (55) d -> . d MAYOR_IGUAL_QUE e
    (56) d -> . d TRIPLE_IGUAL e
    (57) d -> . e
    (58) e -> . e MAS f
    (59) e -> . e MENOS f
    (60) e -> . f
    (61) f -> . f TIMES g
    (62) f -> . f DIVIDE g
    (63) f -> . f MOD g
    (64) f -> . f POTENCIA g
    (65) f -> . g
    (66) f -> . g PUNTO nativeFun L_PAREN expresion R_PAREN
    (67) g -> . ENTERO
    (68) g -> . DECIMAL
    (69) g -> . CADENA
    (70) g -> . LITERAL
    (71) g -> . interface_assi
    (72) g -> . L_PAREN a R_PAREN
    (75) interface_assi -> . L_LLAVE atributos_assi R_LLAVE

    NOT             shift and go to state 50
    ENTERO          shift and go to state 56
    DECIMAL         shift and go to state 57
    CADENA          shift and go to state 58
    LITERAL         shift and go to state 46
    L_PAREN         shift and go to state 55
    L_LLAVE         shift and go to state 60

    a                              shift and go to state 185
    b                              shift and go to state 48
    c                              shift and go to state 49
    d                              shift and go to state 51
    e                              shift and go to state 52
    f                              shift and go to state 53
    g                              shift and go to state 54
    interface_assi                 shift and go to state 59

state 182

    (34) else_pro -> ELSE L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . sumadores sc
    (42) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (20) declaration_instruction -> . LET declaracion_list
    (31) assig_pro -> . LITERAL IGUAL a
    (32) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (36) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (37) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (38) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (39) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (15) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (73) sumadores -> . LITERAL MAS MAS
    (74) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 186
    CONSOLE         shift and go to state 13
    LET             shift and go to state 14
    LITERAL         shift and go to state 15
    IF              shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    INTERFACE       shift and go to state 19

    instruccion                    shift and go to state 20
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    sumadores                      shift and go to state 12

state 183

    (37) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . sumadores sc
    (42) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (20) declaration_instruction -> . LET declaracion_list
    (31) assig_pro -> . LITERAL IGUAL a
    (32) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (36) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (37) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (38) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (39) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (15) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (73) sumadores -> . LITERAL MAS MAS
    (74) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 187
    CONSOLE         shift and go to state 13
    LET             shift and go to state 14
    LITERAL         shift and go to state 15
    IF              shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    INTERFACE       shift and go to state 19

    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    instruccion                    shift and go to state 20
    console_pro                    shift and go to state 4
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    sumadores                      shift and go to state 12

state 184

    (38) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . sumadores sc
    (42) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (20) declaration_instruction -> . LET declaracion_list
    (31) assig_pro -> . LITERAL IGUAL a
    (32) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (36) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (37) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (38) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (39) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (15) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (73) sumadores -> . LITERAL MAS MAS
    (74) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 188
    CONSOLE         shift and go to state 13
    LET             shift and go to state 14
    LITERAL         shift and go to state 15
    IF              shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    INTERFACE       shift and go to state 19

    assig_pro                      shift and go to state 6
    instruccion                    shift and go to state 20
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    sumadores                      shift and go to state 12

state 185

    (33) else_pro -> ELSE IF L_PAREN a . R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (45) a -> a . OR b

    R_PAREN         shift and go to state 189
    OR              shift and go to state 80


state 186

    (34) else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 34 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 34 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 34 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 34 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 34 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 34 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 34 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 34 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 34 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 34 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)


state 187

    (37) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 37 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 37 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 37 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 37 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 37 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 37 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 37 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 37 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 37 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 37 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 188

    (38) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 38 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 38 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 38 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 38 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 38 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 38 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 38 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 38 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 38 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 38 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 189

    (33) else_pro -> ELSE IF L_PAREN a R_PAREN . L_LLAVE instrucciones R_LLAVE else_pro

    L_LLAVE         shift and go to state 190


state 190

    (33) else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE . instrucciones R_LLAVE else_pro
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . sumadores sc
    (42) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (20) declaration_instruction -> . LET declaracion_list
    (31) assig_pro -> . LITERAL IGUAL a
    (32) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (36) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (37) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (38) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (39) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (15) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (73) sumadores -> . LITERAL MAS MAS
    (74) sumadores -> . LITERAL MENOS MENOS

    CONSOLE         shift and go to state 13
    LET             shift and go to state 14
    LITERAL         shift and go to state 15
    IF              shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    INTERFACE       shift and go to state 19

    instrucciones                  shift and go to state 191
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    sumadores                      shift and go to state 12

state 191

    (33) else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones . R_LLAVE else_pro
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . if_pro sc
    (8) instruccion -> . while_pro sc
    (9) instruccion -> . for_pro sc
    (10) instruccion -> . for_each_pro sc
    (11) instruccion -> . interface_pro sc
    (12) instruccion -> . sumadores sc
    (42) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (20) declaration_instruction -> . LET declaracion_list
    (31) assig_pro -> . LITERAL IGUAL a
    (32) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (36) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (37) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (38) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON assig_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (39) for_each_pro -> . FOR L_PAREN for_each_dec R_PAREN L_LLAVE instrucciones R_LLAVE
    (15) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (73) sumadores -> . LITERAL MAS MAS
    (74) sumadores -> . LITERAL MENOS MENOS

    R_LLAVE         shift and go to state 192
    CONSOLE         shift and go to state 13
    LET             shift and go to state 14
    LITERAL         shift and go to state 15
    IF              shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    INTERFACE       shift and go to state 19

    instruccion                    shift and go to state 20
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    if_pro                         shift and go to state 7
    while_pro                      shift and go to state 8
    for_pro                        shift and go to state 9
    for_each_pro                   shift and go to state 10
    interface_pro                  shift and go to state 11
    sumadores                      shift and go to state 12

state 192

    (33) else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE . else_pro
    (33) else_pro -> . ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (34) else_pro -> . ELSE L_LLAVE instrucciones R_LLAVE
    (35) else_pro -> .

    ELSE            shift and go to state 173
    SEMI_COLON      reduce using rule 35 (else_pro -> .)
    CONSOLE         reduce using rule 35 (else_pro -> .)
    LET             reduce using rule 35 (else_pro -> .)
    LITERAL         reduce using rule 35 (else_pro -> .)
    IF              reduce using rule 35 (else_pro -> .)
    WHILE           reduce using rule 35 (else_pro -> .)
    FOR             reduce using rule 35 (else_pro -> .)
    INTERFACE       reduce using rule 35 (else_pro -> .)
    $end            reduce using rule 35 (else_pro -> .)
    R_LLAVE         reduce using rule 35 (else_pro -> .)

    else_pro                       shift and go to state 193

state 193

    (33) else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .

    SEMI_COLON      reduce using rule 33 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    CONSOLE         reduce using rule 33 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    LET             reduce using rule 33 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    LITERAL         reduce using rule 33 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    IF              reduce using rule 33 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    WHILE           reduce using rule 33 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    FOR             reduce using rule 33 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    INTERFACE       reduce using rule 33 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    $end            reduce using rule 33 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    R_LLAVE         reduce using rule 33 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)

