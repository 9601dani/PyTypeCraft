Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> init
Rule 1     init -> instrucciones
Rule 2     instrucciones -> instrucciones instruccion
Rule 3     instrucciones -> instruccion
Rule 4     instruccion -> console_pro sc
Rule 5     instruccion -> declaration_instruction sc
Rule 6     instruccion -> assig_pro sc
Rule 7     instruccion -> interface_assign_pro sc
Rule 8     instruccion -> array_assign_pro sc
Rule 9     instruccion -> if_pro sc
Rule 10    instruccion -> while_pro sc
Rule 11    instruccion -> for_pro sc
Rule 12    instruccion -> for_each_pro sc
Rule 13    instruccion -> interface_pro sc
Rule 14    instruccion -> continue_pro sc
Rule 15    instruccion -> break_pro sc
Rule 16    instruccion -> return_pro sc
Rule 17    instruccion -> function_pro sc
Rule 18    instruccion -> call_function_pro sc
Rule 19    instruccion -> a sc
Rule 20    instruccion -> sumadores sc
Rule 21    sc -> SEMI_COLON
Rule 22    sc -> <empty>
Rule 23    function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 24    function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 25    function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
Rule 26    function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
Rule 27    function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
Rule 28    function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
Rule 29    call_function_pro -> LITERAL L_PAREN values R_PAREN
Rule 30    call_function_pro -> LITERAL L_PAREN R_PAREN
Rule 31    call_function_pro -> TOSTRING L_PAREN values R_PAREN
Rule 32    values -> values COMA a
Rule 33    values -> a
Rule 34    parameters_pro -> parameters_pro COMA parameter_pro
Rule 35    parameters_pro -> parameter_pro
Rule 36    parameter_pro -> LITERAL COLON type
Rule 37    parameter_pro -> LITERAL
Rule 38    continue_pro -> CONTINUE
Rule 39    break_pro -> BREAK
Rule 40    return_pro -> RETURN
Rule 41    return_pro -> RETURN a
Rule 42    interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
Rule 43    interface_atributos -> interface_atributos interface_atributo sc
Rule 44    interface_atributos -> <empty>
Rule 45    interface_atributo -> LITERAL COLON type
Rule 46    interface_atributo -> LITERAL
Rule 47    interface_assign_pro -> i PUNTO LITERAL IGUAL a
Rule 48    declaration_instruction -> LET declaracion_list
Rule 49    declaracion_list -> declaracion_list COMA assignacion_instruction
Rule 50    declaracion_list -> assignacion_instruction
Rule 51    assignacion_instruction -> LITERAL COLON type IGUAL a
Rule 52    assignacion_instruction -> LITERAL COLON type
Rule 53    assignacion_instruction -> LITERAL IGUAL a
Rule 54    assignacion_instruction -> LITERAL
Rule 55    type -> NUMBER
Rule 56    type -> STRING
Rule 57    type -> BOOLEAN
Rule 58    type -> ANY
Rule 59    type -> LITERAL
Rule 60    type -> NULL
Rule 61    assig_pro -> LITERAL IGUAL a
Rule 62    if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
Rule 63    else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
Rule 64    else_pro -> ELSE L_LLAVE instrucciones R_LLAVE
Rule 65    else_pro -> <empty>
Rule 66    while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 67    for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 68    for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 69    inDec_pro -> assig_pro
Rule 70    inDec_pro -> sumadores
Rule 71    for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
Rule 72    console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
Rule 73    expresion -> expresion COMA a
Rule 74    expresion -> a
Rule 75    a -> a OR b
Rule 76    a -> b
Rule 77    b -> b AND c
Rule 78    b -> c
Rule 79    c -> NOT d
Rule 80    c -> d
Rule 81    d -> d DISTINTO_QUE e
Rule 82    d -> d MENOR_QUE e
Rule 83    d -> d MENOR_IGUAL_QUE e
Rule 84    d -> d MAYOR_QUE e
Rule 85    d -> d MAYOR_IGUAL_QUE e
Rule 86    d -> d TRIPLE_IGUAL e
Rule 87    d -> e
Rule 88    e -> e MAS f
Rule 89    e -> e MENOS f
Rule 90    e -> f
Rule 91    f -> MENOS g
Rule 92    f -> MAS g
Rule 93    f -> g
Rule 94    g -> g TIMES h
Rule 95    g -> g DIVIDE h
Rule 96    g -> g MOD h
Rule 97    g -> h
Rule 98    h -> h POTENCIA i
Rule 99    h -> i
Rule 100   i -> ENTERO
Rule 101   i -> DECIMAL
Rule 102   i -> CADENA
Rule 103   i -> LITERAL
Rule 104   i -> TRUE
Rule 105   i -> FALSE
Rule 106   i -> call_function_pro
Rule 107   i -> array_pro
Rule 108   i -> interface_assi
Rule 109   i -> L_PAREN a R_PAREN
Rule 110   i -> array_val_pro
Rule 111   i -> i PUNTO LITERAL
Rule 112   i -> i PUNTO nativeFun L_PAREN expresion R_PAREN
Rule 113   i -> i PUNTO nativeFun L_PAREN R_PAREN
Rule 114   array_val_pro -> LITERAL dimensions
Rule 115   dimensions -> dimensions L_CORCHETE a R_CORCHETE
Rule 116   dimensions -> L_CORCHETE a R_CORCHETE
Rule 117   sumadores -> LITERAL MAS MAS
Rule 118   sumadores -> LITERAL MENOS MENOS
Rule 119   interface_assi -> L_LLAVE atributos_assi R_LLAVE
Rule 120   atributos_assi -> atributos_assi COMA LITERAL COLON a
Rule 121   atributos_assi -> LITERAL COLON a
Rule 122   array_pro -> L_CORCHETE values R_CORCHETE
Rule 123   array_assign_pro -> LITERAL dimensions IGUAL a
Rule 124   nativeFun -> TOSTRING
Rule 125   nativeFun -> TOFIXED
Rule 126   nativeFun -> TOEXPONENTIAL
Rule 127   nativeFun -> TOLOWERCASE
Rule 128   nativeFun -> TOUPPERCASE
Rule 129   nativeFun -> SPLIT
Rule 130   nativeFun -> CONCAT
Rule 131   nativeFun -> LENGTH
Rule 132   nativeFun -> PUSH

Terminals, with rules where they appear

AND                  : 77
ANY                  : 58
BOOLEAN              : 57
BREAK                : 39
CADENA               : 102
COLON                : 25 26 27 28 36 45 51 52 120 121
COMA                 : 32 34 49 73 120
CONCAT               : 130
CONSOLE              : 72
CONTINUE             : 38
DECIMAL              : 101
DISTINTO_QUE         : 81
DIVIDE               : 95
ELSE                 : 63 64
ENTERO               : 100
FALSE                : 105
FOR                  : 67 68 71
FUNCTION             : 23 24 25 26 27 28
IF                   : 62 63
IGUAL                : 47 51 53 61 123
INTERFACE            : 42
LENGTH               : 131
LET                  : 48 71
LITERAL              : 23 24 25 26 26 27 28 28 29 30 36 37 42 45 46 47 51 52 53 54 59 61 71 103 111 114 117 118 120 121 123
LOG                  : 72
L_CORCHETE           : 115 116 122
L_LLAVE              : 23 24 25 26 27 28 42 62 63 64 66 67 68 71 119
L_PAREN              : 23 24 25 26 27 28 29 30 31 62 63 66 67 68 71 72 109 112 113
MAS                  : 88 92 117 117
MAYOR_IGUAL_QUE      : 85
MAYOR_QUE            : 84
MENOR_IGUAL_QUE      : 83
MENOR_QUE            : 82
MENOS                : 89 91 118 118
MOD                  : 96
NOT                  : 79
NULL                 : 60
NUMBER               : 55
OF                   : 71
OR                   : 75
POTENCIA             : 98
PUNTO                : 47 72 111 112 113
PUSH                 : 132
RETURN               : 40 41
R_CORCHETE           : 115 116 122
R_LLAVE              : 23 24 25 26 27 28 42 62 63 64 66 67 68 71 119
R_PAREN              : 23 24 25 26 27 28 29 30 31 62 63 66 67 68 71 72 109 112 113
SEMI_COLON           : 21 67 67 68 68
SPLIT                : 129
STRING               : 56
TIMES                : 94
TOEXPONENTIAL        : 126
TOFIXED              : 125
TOLOWERCASE          : 127
TOSTRING             : 31 124
TOUPPERCASE          : 128
TRIPLE_IGUAL         : 86
TRUE                 : 104
WHILE                : 66
error                : 

Nonterminals, with rules where they appear

a                    : 19 32 33 41 47 51 53 61 62 63 66 67 68 71 73 74 75 109 115 116 120 121 123
array_assign_pro     : 8
array_pro            : 107
array_val_pro        : 110
assig_pro            : 6 68 69
assignacion_instruction : 49 50
atributos_assi       : 119 120
b                    : 75 76 77
break_pro            : 15
c                    : 77 78
call_function_pro    : 18 106
console_pro          : 4
continue_pro         : 14
d                    : 79 80 81 82 83 84 85 86
declaracion_list     : 48 49
declaration_instruction : 5 67
dimensions           : 114 115 123
e                    : 81 82 83 84 85 86 87 88 89
else_pro             : 62 63
expresion            : 72 73 112
f                    : 88 89 90
for_each_pro         : 12
for_pro              : 11
function_pro         : 17
g                    : 91 92 93 94 95 96
h                    : 94 95 96 97 98
i                    : 47 98 99 111 112 113
if_pro               : 9
inDec_pro            : 67 68
init                 : 0
instruccion          : 2 3
instrucciones        : 1 2 23 24 25 26 27 28 62 63 64 66 67 68 71
interface_assi       : 108
interface_assign_pro : 7
interface_atributo   : 43
interface_atributos  : 42 43
interface_pro        : 13
nativeFun            : 112 113
parameter_pro        : 34 35
parameters_pro       : 23 25 26 34
return_pro           : 16
sc                   : 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 43
sumadores            : 20 70
type                 : 25 27 36 45 51 52
values               : 29 31 32 122
while_pro            : 10

Parsing method: LALR

state 0

    (0) S' -> . init
    (1) init -> . instrucciones
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    init                           shift and go to state 1
    instrucciones                  shift and go to state 2
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    a                              shift and go to state 19
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 1

    (0) S' -> init .



state 2

    (1) init -> instrucciones .
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    $end            reduce using rule 1 (init -> instrucciones .)
    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    instruccion                    shift and go to state 55
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    a                              shift and go to state 19
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 3

    (3) instrucciones -> instruccion .

    CONSOLE         reduce using rule 3 (instrucciones -> instruccion .)
    LET             reduce using rule 3 (instrucciones -> instruccion .)
    LITERAL         reduce using rule 3 (instrucciones -> instruccion .)
    IF              reduce using rule 3 (instrucciones -> instruccion .)
    WHILE           reduce using rule 3 (instrucciones -> instruccion .)
    FOR             reduce using rule 3 (instrucciones -> instruccion .)
    INTERFACE       reduce using rule 3 (instrucciones -> instruccion .)
    CONTINUE        reduce using rule 3 (instrucciones -> instruccion .)
    BREAK           reduce using rule 3 (instrucciones -> instruccion .)
    RETURN          reduce using rule 3 (instrucciones -> instruccion .)
    FUNCTION        reduce using rule 3 (instrucciones -> instruccion .)
    TOSTRING        reduce using rule 3 (instrucciones -> instruccion .)
    ENTERO          reduce using rule 3 (instrucciones -> instruccion .)
    DECIMAL         reduce using rule 3 (instrucciones -> instruccion .)
    CADENA          reduce using rule 3 (instrucciones -> instruccion .)
    TRUE            reduce using rule 3 (instrucciones -> instruccion .)
    FALSE           reduce using rule 3 (instrucciones -> instruccion .)
    L_PAREN         reduce using rule 3 (instrucciones -> instruccion .)
    L_CORCHETE      reduce using rule 3 (instrucciones -> instruccion .)
    L_LLAVE         reduce using rule 3 (instrucciones -> instruccion .)
    NOT             reduce using rule 3 (instrucciones -> instruccion .)
    MENOS           reduce using rule 3 (instrucciones -> instruccion .)
    MAS             reduce using rule 3 (instrucciones -> instruccion .)
    $end            reduce using rule 3 (instrucciones -> instruccion .)
    R_LLAVE         reduce using rule 3 (instrucciones -> instruccion .)


state 4

    (4) instruccion -> console_pro . sc
    (21) sc -> . SEMI_COLON
    (22) sc -> .

    SEMI_COLON      shift and go to state 57
    CONSOLE         reduce using rule 22 (sc -> .)
    LET             reduce using rule 22 (sc -> .)
    LITERAL         reduce using rule 22 (sc -> .)
    IF              reduce using rule 22 (sc -> .)
    WHILE           reduce using rule 22 (sc -> .)
    FOR             reduce using rule 22 (sc -> .)
    INTERFACE       reduce using rule 22 (sc -> .)
    CONTINUE        reduce using rule 22 (sc -> .)
    BREAK           reduce using rule 22 (sc -> .)
    RETURN          reduce using rule 22 (sc -> .)
    FUNCTION        reduce using rule 22 (sc -> .)
    TOSTRING        reduce using rule 22 (sc -> .)
    ENTERO          reduce using rule 22 (sc -> .)
    DECIMAL         reduce using rule 22 (sc -> .)
    CADENA          reduce using rule 22 (sc -> .)
    TRUE            reduce using rule 22 (sc -> .)
    FALSE           reduce using rule 22 (sc -> .)
    L_PAREN         reduce using rule 22 (sc -> .)
    L_CORCHETE      reduce using rule 22 (sc -> .)
    L_LLAVE         reduce using rule 22 (sc -> .)
    NOT             reduce using rule 22 (sc -> .)
    MENOS           reduce using rule 22 (sc -> .)
    MAS             reduce using rule 22 (sc -> .)
    $end            reduce using rule 22 (sc -> .)
    R_LLAVE         reduce using rule 22 (sc -> .)

    sc                             shift and go to state 56

state 5

    (5) instruccion -> declaration_instruction . sc
    (21) sc -> . SEMI_COLON
    (22) sc -> .

    SEMI_COLON      shift and go to state 57
    CONSOLE         reduce using rule 22 (sc -> .)
    LET             reduce using rule 22 (sc -> .)
    LITERAL         reduce using rule 22 (sc -> .)
    IF              reduce using rule 22 (sc -> .)
    WHILE           reduce using rule 22 (sc -> .)
    FOR             reduce using rule 22 (sc -> .)
    INTERFACE       reduce using rule 22 (sc -> .)
    CONTINUE        reduce using rule 22 (sc -> .)
    BREAK           reduce using rule 22 (sc -> .)
    RETURN          reduce using rule 22 (sc -> .)
    FUNCTION        reduce using rule 22 (sc -> .)
    TOSTRING        reduce using rule 22 (sc -> .)
    ENTERO          reduce using rule 22 (sc -> .)
    DECIMAL         reduce using rule 22 (sc -> .)
    CADENA          reduce using rule 22 (sc -> .)
    TRUE            reduce using rule 22 (sc -> .)
    FALSE           reduce using rule 22 (sc -> .)
    L_PAREN         reduce using rule 22 (sc -> .)
    L_CORCHETE      reduce using rule 22 (sc -> .)
    L_LLAVE         reduce using rule 22 (sc -> .)
    NOT             reduce using rule 22 (sc -> .)
    MENOS           reduce using rule 22 (sc -> .)
    MAS             reduce using rule 22 (sc -> .)
    $end            reduce using rule 22 (sc -> .)
    R_LLAVE         reduce using rule 22 (sc -> .)

    sc                             shift and go to state 58

state 6

    (6) instruccion -> assig_pro . sc
    (21) sc -> . SEMI_COLON
    (22) sc -> .

    SEMI_COLON      shift and go to state 57
    CONSOLE         reduce using rule 22 (sc -> .)
    LET             reduce using rule 22 (sc -> .)
    LITERAL         reduce using rule 22 (sc -> .)
    IF              reduce using rule 22 (sc -> .)
    WHILE           reduce using rule 22 (sc -> .)
    FOR             reduce using rule 22 (sc -> .)
    INTERFACE       reduce using rule 22 (sc -> .)
    CONTINUE        reduce using rule 22 (sc -> .)
    BREAK           reduce using rule 22 (sc -> .)
    RETURN          reduce using rule 22 (sc -> .)
    FUNCTION        reduce using rule 22 (sc -> .)
    TOSTRING        reduce using rule 22 (sc -> .)
    ENTERO          reduce using rule 22 (sc -> .)
    DECIMAL         reduce using rule 22 (sc -> .)
    CADENA          reduce using rule 22 (sc -> .)
    TRUE            reduce using rule 22 (sc -> .)
    FALSE           reduce using rule 22 (sc -> .)
    L_PAREN         reduce using rule 22 (sc -> .)
    L_CORCHETE      reduce using rule 22 (sc -> .)
    L_LLAVE         reduce using rule 22 (sc -> .)
    NOT             reduce using rule 22 (sc -> .)
    MENOS           reduce using rule 22 (sc -> .)
    MAS             reduce using rule 22 (sc -> .)
    $end            reduce using rule 22 (sc -> .)
    R_LLAVE         reduce using rule 22 (sc -> .)

    sc                             shift and go to state 59

state 7

    (7) instruccion -> interface_assign_pro . sc
    (21) sc -> . SEMI_COLON
    (22) sc -> .

    SEMI_COLON      shift and go to state 57
    CONSOLE         reduce using rule 22 (sc -> .)
    LET             reduce using rule 22 (sc -> .)
    LITERAL         reduce using rule 22 (sc -> .)
    IF              reduce using rule 22 (sc -> .)
    WHILE           reduce using rule 22 (sc -> .)
    FOR             reduce using rule 22 (sc -> .)
    INTERFACE       reduce using rule 22 (sc -> .)
    CONTINUE        reduce using rule 22 (sc -> .)
    BREAK           reduce using rule 22 (sc -> .)
    RETURN          reduce using rule 22 (sc -> .)
    FUNCTION        reduce using rule 22 (sc -> .)
    TOSTRING        reduce using rule 22 (sc -> .)
    ENTERO          reduce using rule 22 (sc -> .)
    DECIMAL         reduce using rule 22 (sc -> .)
    CADENA          reduce using rule 22 (sc -> .)
    TRUE            reduce using rule 22 (sc -> .)
    FALSE           reduce using rule 22 (sc -> .)
    L_PAREN         reduce using rule 22 (sc -> .)
    L_CORCHETE      reduce using rule 22 (sc -> .)
    L_LLAVE         reduce using rule 22 (sc -> .)
    NOT             reduce using rule 22 (sc -> .)
    MENOS           reduce using rule 22 (sc -> .)
    MAS             reduce using rule 22 (sc -> .)
    $end            reduce using rule 22 (sc -> .)
    R_LLAVE         reduce using rule 22 (sc -> .)

    sc                             shift and go to state 60

state 8

    (8) instruccion -> array_assign_pro . sc
    (21) sc -> . SEMI_COLON
    (22) sc -> .

    SEMI_COLON      shift and go to state 57
    CONSOLE         reduce using rule 22 (sc -> .)
    LET             reduce using rule 22 (sc -> .)
    LITERAL         reduce using rule 22 (sc -> .)
    IF              reduce using rule 22 (sc -> .)
    WHILE           reduce using rule 22 (sc -> .)
    FOR             reduce using rule 22 (sc -> .)
    INTERFACE       reduce using rule 22 (sc -> .)
    CONTINUE        reduce using rule 22 (sc -> .)
    BREAK           reduce using rule 22 (sc -> .)
    RETURN          reduce using rule 22 (sc -> .)
    FUNCTION        reduce using rule 22 (sc -> .)
    TOSTRING        reduce using rule 22 (sc -> .)
    ENTERO          reduce using rule 22 (sc -> .)
    DECIMAL         reduce using rule 22 (sc -> .)
    CADENA          reduce using rule 22 (sc -> .)
    TRUE            reduce using rule 22 (sc -> .)
    FALSE           reduce using rule 22 (sc -> .)
    L_PAREN         reduce using rule 22 (sc -> .)
    L_CORCHETE      reduce using rule 22 (sc -> .)
    L_LLAVE         reduce using rule 22 (sc -> .)
    NOT             reduce using rule 22 (sc -> .)
    MENOS           reduce using rule 22 (sc -> .)
    MAS             reduce using rule 22 (sc -> .)
    $end            reduce using rule 22 (sc -> .)
    R_LLAVE         reduce using rule 22 (sc -> .)

    sc                             shift and go to state 61

state 9

    (9) instruccion -> if_pro . sc
    (21) sc -> . SEMI_COLON
    (22) sc -> .

    SEMI_COLON      shift and go to state 57
    CONSOLE         reduce using rule 22 (sc -> .)
    LET             reduce using rule 22 (sc -> .)
    LITERAL         reduce using rule 22 (sc -> .)
    IF              reduce using rule 22 (sc -> .)
    WHILE           reduce using rule 22 (sc -> .)
    FOR             reduce using rule 22 (sc -> .)
    INTERFACE       reduce using rule 22 (sc -> .)
    CONTINUE        reduce using rule 22 (sc -> .)
    BREAK           reduce using rule 22 (sc -> .)
    RETURN          reduce using rule 22 (sc -> .)
    FUNCTION        reduce using rule 22 (sc -> .)
    TOSTRING        reduce using rule 22 (sc -> .)
    ENTERO          reduce using rule 22 (sc -> .)
    DECIMAL         reduce using rule 22 (sc -> .)
    CADENA          reduce using rule 22 (sc -> .)
    TRUE            reduce using rule 22 (sc -> .)
    FALSE           reduce using rule 22 (sc -> .)
    L_PAREN         reduce using rule 22 (sc -> .)
    L_CORCHETE      reduce using rule 22 (sc -> .)
    L_LLAVE         reduce using rule 22 (sc -> .)
    NOT             reduce using rule 22 (sc -> .)
    MENOS           reduce using rule 22 (sc -> .)
    MAS             reduce using rule 22 (sc -> .)
    $end            reduce using rule 22 (sc -> .)
    R_LLAVE         reduce using rule 22 (sc -> .)

    sc                             shift and go to state 62

state 10

    (10) instruccion -> while_pro . sc
    (21) sc -> . SEMI_COLON
    (22) sc -> .

    SEMI_COLON      shift and go to state 57
    CONSOLE         reduce using rule 22 (sc -> .)
    LET             reduce using rule 22 (sc -> .)
    LITERAL         reduce using rule 22 (sc -> .)
    IF              reduce using rule 22 (sc -> .)
    WHILE           reduce using rule 22 (sc -> .)
    FOR             reduce using rule 22 (sc -> .)
    INTERFACE       reduce using rule 22 (sc -> .)
    CONTINUE        reduce using rule 22 (sc -> .)
    BREAK           reduce using rule 22 (sc -> .)
    RETURN          reduce using rule 22 (sc -> .)
    FUNCTION        reduce using rule 22 (sc -> .)
    TOSTRING        reduce using rule 22 (sc -> .)
    ENTERO          reduce using rule 22 (sc -> .)
    DECIMAL         reduce using rule 22 (sc -> .)
    CADENA          reduce using rule 22 (sc -> .)
    TRUE            reduce using rule 22 (sc -> .)
    FALSE           reduce using rule 22 (sc -> .)
    L_PAREN         reduce using rule 22 (sc -> .)
    L_CORCHETE      reduce using rule 22 (sc -> .)
    L_LLAVE         reduce using rule 22 (sc -> .)
    NOT             reduce using rule 22 (sc -> .)
    MENOS           reduce using rule 22 (sc -> .)
    MAS             reduce using rule 22 (sc -> .)
    $end            reduce using rule 22 (sc -> .)
    R_LLAVE         reduce using rule 22 (sc -> .)

    sc                             shift and go to state 63

state 11

    (11) instruccion -> for_pro . sc
    (21) sc -> . SEMI_COLON
    (22) sc -> .

    SEMI_COLON      shift and go to state 57
    CONSOLE         reduce using rule 22 (sc -> .)
    LET             reduce using rule 22 (sc -> .)
    LITERAL         reduce using rule 22 (sc -> .)
    IF              reduce using rule 22 (sc -> .)
    WHILE           reduce using rule 22 (sc -> .)
    FOR             reduce using rule 22 (sc -> .)
    INTERFACE       reduce using rule 22 (sc -> .)
    CONTINUE        reduce using rule 22 (sc -> .)
    BREAK           reduce using rule 22 (sc -> .)
    RETURN          reduce using rule 22 (sc -> .)
    FUNCTION        reduce using rule 22 (sc -> .)
    TOSTRING        reduce using rule 22 (sc -> .)
    ENTERO          reduce using rule 22 (sc -> .)
    DECIMAL         reduce using rule 22 (sc -> .)
    CADENA          reduce using rule 22 (sc -> .)
    TRUE            reduce using rule 22 (sc -> .)
    FALSE           reduce using rule 22 (sc -> .)
    L_PAREN         reduce using rule 22 (sc -> .)
    L_CORCHETE      reduce using rule 22 (sc -> .)
    L_LLAVE         reduce using rule 22 (sc -> .)
    NOT             reduce using rule 22 (sc -> .)
    MENOS           reduce using rule 22 (sc -> .)
    MAS             reduce using rule 22 (sc -> .)
    $end            reduce using rule 22 (sc -> .)
    R_LLAVE         reduce using rule 22 (sc -> .)

    sc                             shift and go to state 64

state 12

    (12) instruccion -> for_each_pro . sc
    (21) sc -> . SEMI_COLON
    (22) sc -> .

    SEMI_COLON      shift and go to state 57
    CONSOLE         reduce using rule 22 (sc -> .)
    LET             reduce using rule 22 (sc -> .)
    LITERAL         reduce using rule 22 (sc -> .)
    IF              reduce using rule 22 (sc -> .)
    WHILE           reduce using rule 22 (sc -> .)
    FOR             reduce using rule 22 (sc -> .)
    INTERFACE       reduce using rule 22 (sc -> .)
    CONTINUE        reduce using rule 22 (sc -> .)
    BREAK           reduce using rule 22 (sc -> .)
    RETURN          reduce using rule 22 (sc -> .)
    FUNCTION        reduce using rule 22 (sc -> .)
    TOSTRING        reduce using rule 22 (sc -> .)
    ENTERO          reduce using rule 22 (sc -> .)
    DECIMAL         reduce using rule 22 (sc -> .)
    CADENA          reduce using rule 22 (sc -> .)
    TRUE            reduce using rule 22 (sc -> .)
    FALSE           reduce using rule 22 (sc -> .)
    L_PAREN         reduce using rule 22 (sc -> .)
    L_CORCHETE      reduce using rule 22 (sc -> .)
    L_LLAVE         reduce using rule 22 (sc -> .)
    NOT             reduce using rule 22 (sc -> .)
    MENOS           reduce using rule 22 (sc -> .)
    MAS             reduce using rule 22 (sc -> .)
    $end            reduce using rule 22 (sc -> .)
    R_LLAVE         reduce using rule 22 (sc -> .)

    sc                             shift and go to state 65

state 13

    (13) instruccion -> interface_pro . sc
    (21) sc -> . SEMI_COLON
    (22) sc -> .

    SEMI_COLON      shift and go to state 57
    CONSOLE         reduce using rule 22 (sc -> .)
    LET             reduce using rule 22 (sc -> .)
    LITERAL         reduce using rule 22 (sc -> .)
    IF              reduce using rule 22 (sc -> .)
    WHILE           reduce using rule 22 (sc -> .)
    FOR             reduce using rule 22 (sc -> .)
    INTERFACE       reduce using rule 22 (sc -> .)
    CONTINUE        reduce using rule 22 (sc -> .)
    BREAK           reduce using rule 22 (sc -> .)
    RETURN          reduce using rule 22 (sc -> .)
    FUNCTION        reduce using rule 22 (sc -> .)
    TOSTRING        reduce using rule 22 (sc -> .)
    ENTERO          reduce using rule 22 (sc -> .)
    DECIMAL         reduce using rule 22 (sc -> .)
    CADENA          reduce using rule 22 (sc -> .)
    TRUE            reduce using rule 22 (sc -> .)
    FALSE           reduce using rule 22 (sc -> .)
    L_PAREN         reduce using rule 22 (sc -> .)
    L_CORCHETE      reduce using rule 22 (sc -> .)
    L_LLAVE         reduce using rule 22 (sc -> .)
    NOT             reduce using rule 22 (sc -> .)
    MENOS           reduce using rule 22 (sc -> .)
    MAS             reduce using rule 22 (sc -> .)
    $end            reduce using rule 22 (sc -> .)
    R_LLAVE         reduce using rule 22 (sc -> .)

    sc                             shift and go to state 66

state 14

    (14) instruccion -> continue_pro . sc
    (21) sc -> . SEMI_COLON
    (22) sc -> .

    SEMI_COLON      shift and go to state 57
    CONSOLE         reduce using rule 22 (sc -> .)
    LET             reduce using rule 22 (sc -> .)
    LITERAL         reduce using rule 22 (sc -> .)
    IF              reduce using rule 22 (sc -> .)
    WHILE           reduce using rule 22 (sc -> .)
    FOR             reduce using rule 22 (sc -> .)
    INTERFACE       reduce using rule 22 (sc -> .)
    CONTINUE        reduce using rule 22 (sc -> .)
    BREAK           reduce using rule 22 (sc -> .)
    RETURN          reduce using rule 22 (sc -> .)
    FUNCTION        reduce using rule 22 (sc -> .)
    TOSTRING        reduce using rule 22 (sc -> .)
    ENTERO          reduce using rule 22 (sc -> .)
    DECIMAL         reduce using rule 22 (sc -> .)
    CADENA          reduce using rule 22 (sc -> .)
    TRUE            reduce using rule 22 (sc -> .)
    FALSE           reduce using rule 22 (sc -> .)
    L_PAREN         reduce using rule 22 (sc -> .)
    L_CORCHETE      reduce using rule 22 (sc -> .)
    L_LLAVE         reduce using rule 22 (sc -> .)
    NOT             reduce using rule 22 (sc -> .)
    MENOS           reduce using rule 22 (sc -> .)
    MAS             reduce using rule 22 (sc -> .)
    $end            reduce using rule 22 (sc -> .)
    R_LLAVE         reduce using rule 22 (sc -> .)

    sc                             shift and go to state 67

state 15

    (15) instruccion -> break_pro . sc
    (21) sc -> . SEMI_COLON
    (22) sc -> .

    SEMI_COLON      shift and go to state 57
    CONSOLE         reduce using rule 22 (sc -> .)
    LET             reduce using rule 22 (sc -> .)
    LITERAL         reduce using rule 22 (sc -> .)
    IF              reduce using rule 22 (sc -> .)
    WHILE           reduce using rule 22 (sc -> .)
    FOR             reduce using rule 22 (sc -> .)
    INTERFACE       reduce using rule 22 (sc -> .)
    CONTINUE        reduce using rule 22 (sc -> .)
    BREAK           reduce using rule 22 (sc -> .)
    RETURN          reduce using rule 22 (sc -> .)
    FUNCTION        reduce using rule 22 (sc -> .)
    TOSTRING        reduce using rule 22 (sc -> .)
    ENTERO          reduce using rule 22 (sc -> .)
    DECIMAL         reduce using rule 22 (sc -> .)
    CADENA          reduce using rule 22 (sc -> .)
    TRUE            reduce using rule 22 (sc -> .)
    FALSE           reduce using rule 22 (sc -> .)
    L_PAREN         reduce using rule 22 (sc -> .)
    L_CORCHETE      reduce using rule 22 (sc -> .)
    L_LLAVE         reduce using rule 22 (sc -> .)
    NOT             reduce using rule 22 (sc -> .)
    MENOS           reduce using rule 22 (sc -> .)
    MAS             reduce using rule 22 (sc -> .)
    $end            reduce using rule 22 (sc -> .)
    R_LLAVE         reduce using rule 22 (sc -> .)

    sc                             shift and go to state 68

state 16

    (16) instruccion -> return_pro . sc
    (21) sc -> . SEMI_COLON
    (22) sc -> .

    SEMI_COLON      shift and go to state 57
    CONSOLE         reduce using rule 22 (sc -> .)
    LET             reduce using rule 22 (sc -> .)
    LITERAL         reduce using rule 22 (sc -> .)
    IF              reduce using rule 22 (sc -> .)
    WHILE           reduce using rule 22 (sc -> .)
    FOR             reduce using rule 22 (sc -> .)
    INTERFACE       reduce using rule 22 (sc -> .)
    CONTINUE        reduce using rule 22 (sc -> .)
    BREAK           reduce using rule 22 (sc -> .)
    RETURN          reduce using rule 22 (sc -> .)
    FUNCTION        reduce using rule 22 (sc -> .)
    TOSTRING        reduce using rule 22 (sc -> .)
    ENTERO          reduce using rule 22 (sc -> .)
    DECIMAL         reduce using rule 22 (sc -> .)
    CADENA          reduce using rule 22 (sc -> .)
    TRUE            reduce using rule 22 (sc -> .)
    FALSE           reduce using rule 22 (sc -> .)
    L_PAREN         reduce using rule 22 (sc -> .)
    L_CORCHETE      reduce using rule 22 (sc -> .)
    L_LLAVE         reduce using rule 22 (sc -> .)
    NOT             reduce using rule 22 (sc -> .)
    MENOS           reduce using rule 22 (sc -> .)
    MAS             reduce using rule 22 (sc -> .)
    $end            reduce using rule 22 (sc -> .)
    R_LLAVE         reduce using rule 22 (sc -> .)

    sc                             shift and go to state 69

state 17

    (17) instruccion -> function_pro . sc
    (21) sc -> . SEMI_COLON
    (22) sc -> .

    SEMI_COLON      shift and go to state 57
    CONSOLE         reduce using rule 22 (sc -> .)
    LET             reduce using rule 22 (sc -> .)
    LITERAL         reduce using rule 22 (sc -> .)
    IF              reduce using rule 22 (sc -> .)
    WHILE           reduce using rule 22 (sc -> .)
    FOR             reduce using rule 22 (sc -> .)
    INTERFACE       reduce using rule 22 (sc -> .)
    CONTINUE        reduce using rule 22 (sc -> .)
    BREAK           reduce using rule 22 (sc -> .)
    RETURN          reduce using rule 22 (sc -> .)
    FUNCTION        reduce using rule 22 (sc -> .)
    TOSTRING        reduce using rule 22 (sc -> .)
    ENTERO          reduce using rule 22 (sc -> .)
    DECIMAL         reduce using rule 22 (sc -> .)
    CADENA          reduce using rule 22 (sc -> .)
    TRUE            reduce using rule 22 (sc -> .)
    FALSE           reduce using rule 22 (sc -> .)
    L_PAREN         reduce using rule 22 (sc -> .)
    L_CORCHETE      reduce using rule 22 (sc -> .)
    L_LLAVE         reduce using rule 22 (sc -> .)
    NOT             reduce using rule 22 (sc -> .)
    MENOS           reduce using rule 22 (sc -> .)
    MAS             reduce using rule 22 (sc -> .)
    $end            reduce using rule 22 (sc -> .)
    R_LLAVE         reduce using rule 22 (sc -> .)

    sc                             shift and go to state 70

state 18

    (18) instruccion -> call_function_pro . sc
    (106) i -> call_function_pro .
    (21) sc -> . SEMI_COLON
    (22) sc -> .

  ! shift/reduce conflict for SEMI_COLON resolved as shift
  ! reduce/reduce conflict for CONSOLE resolved using rule 22 (sc -> .)
  ! reduce/reduce conflict for LET resolved using rule 22 (sc -> .)
  ! reduce/reduce conflict for LITERAL resolved using rule 22 (sc -> .)
  ! reduce/reduce conflict for IF resolved using rule 22 (sc -> .)
  ! reduce/reduce conflict for WHILE resolved using rule 22 (sc -> .)
  ! reduce/reduce conflict for FOR resolved using rule 22 (sc -> .)
  ! reduce/reduce conflict for INTERFACE resolved using rule 22 (sc -> .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 22 (sc -> .)
  ! reduce/reduce conflict for BREAK resolved using rule 22 (sc -> .)
  ! reduce/reduce conflict for RETURN resolved using rule 22 (sc -> .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 22 (sc -> .)
  ! reduce/reduce conflict for TOSTRING resolved using rule 22 (sc -> .)
  ! reduce/reduce conflict for ENTERO resolved using rule 22 (sc -> .)
  ! reduce/reduce conflict for DECIMAL resolved using rule 22 (sc -> .)
  ! reduce/reduce conflict for CADENA resolved using rule 22 (sc -> .)
  ! reduce/reduce conflict for TRUE resolved using rule 22 (sc -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 22 (sc -> .)
  ! reduce/reduce conflict for L_PAREN resolved using rule 22 (sc -> .)
  ! reduce/reduce conflict for L_CORCHETE resolved using rule 22 (sc -> .)
  ! reduce/reduce conflict for L_LLAVE resolved using rule 22 (sc -> .)
  ! reduce/reduce conflict for NOT resolved using rule 22 (sc -> .)
  ! reduce/reduce conflict for MENOS resolved using rule 22 (sc -> .)
  ! reduce/reduce conflict for MAS resolved using rule 22 (sc -> .)
  ! reduce/reduce conflict for $end resolved using rule 22 (sc -> .)
  ! reduce/reduce conflict for R_LLAVE resolved using rule 22 (sc -> .)
    PUNTO           reduce using rule 106 (i -> call_function_pro .)
    POTENCIA        reduce using rule 106 (i -> call_function_pro .)
    TIMES           reduce using rule 106 (i -> call_function_pro .)
    DIVIDE          reduce using rule 106 (i -> call_function_pro .)
    MOD             reduce using rule 106 (i -> call_function_pro .)
    DISTINTO_QUE    reduce using rule 106 (i -> call_function_pro .)
    MENOR_QUE       reduce using rule 106 (i -> call_function_pro .)
    MENOR_IGUAL_QUE reduce using rule 106 (i -> call_function_pro .)
    MAYOR_QUE       reduce using rule 106 (i -> call_function_pro .)
    MAYOR_IGUAL_QUE reduce using rule 106 (i -> call_function_pro .)
    TRIPLE_IGUAL    reduce using rule 106 (i -> call_function_pro .)
    AND             reduce using rule 106 (i -> call_function_pro .)
    OR              reduce using rule 106 (i -> call_function_pro .)
    SEMI_COLON      shift and go to state 57
    CONSOLE         reduce using rule 22 (sc -> .)
    LET             reduce using rule 22 (sc -> .)
    LITERAL         reduce using rule 22 (sc -> .)
    IF              reduce using rule 22 (sc -> .)
    WHILE           reduce using rule 22 (sc -> .)
    FOR             reduce using rule 22 (sc -> .)
    INTERFACE       reduce using rule 22 (sc -> .)
    CONTINUE        reduce using rule 22 (sc -> .)
    BREAK           reduce using rule 22 (sc -> .)
    RETURN          reduce using rule 22 (sc -> .)
    FUNCTION        reduce using rule 22 (sc -> .)
    TOSTRING        reduce using rule 22 (sc -> .)
    ENTERO          reduce using rule 22 (sc -> .)
    DECIMAL         reduce using rule 22 (sc -> .)
    CADENA          reduce using rule 22 (sc -> .)
    TRUE            reduce using rule 22 (sc -> .)
    FALSE           reduce using rule 22 (sc -> .)
    L_PAREN         reduce using rule 22 (sc -> .)
    L_CORCHETE      reduce using rule 22 (sc -> .)
    L_LLAVE         reduce using rule 22 (sc -> .)
    NOT             reduce using rule 22 (sc -> .)
    MENOS           reduce using rule 22 (sc -> .)
    MAS             reduce using rule 22 (sc -> .)
    $end            reduce using rule 22 (sc -> .)
    R_LLAVE         reduce using rule 22 (sc -> .)

  ! MAS             [ reduce using rule 106 (i -> call_function_pro .) ]
  ! MENOS           [ reduce using rule 106 (i -> call_function_pro .) ]
  ! SEMI_COLON      [ reduce using rule 106 (i -> call_function_pro .) ]
  ! CONSOLE         [ reduce using rule 106 (i -> call_function_pro .) ]
  ! LET             [ reduce using rule 106 (i -> call_function_pro .) ]
  ! LITERAL         [ reduce using rule 106 (i -> call_function_pro .) ]
  ! IF              [ reduce using rule 106 (i -> call_function_pro .) ]
  ! WHILE           [ reduce using rule 106 (i -> call_function_pro .) ]
  ! FOR             [ reduce using rule 106 (i -> call_function_pro .) ]
  ! INTERFACE       [ reduce using rule 106 (i -> call_function_pro .) ]
  ! CONTINUE        [ reduce using rule 106 (i -> call_function_pro .) ]
  ! BREAK           [ reduce using rule 106 (i -> call_function_pro .) ]
  ! RETURN          [ reduce using rule 106 (i -> call_function_pro .) ]
  ! FUNCTION        [ reduce using rule 106 (i -> call_function_pro .) ]
  ! TOSTRING        [ reduce using rule 106 (i -> call_function_pro .) ]
  ! ENTERO          [ reduce using rule 106 (i -> call_function_pro .) ]
  ! DECIMAL         [ reduce using rule 106 (i -> call_function_pro .) ]
  ! CADENA          [ reduce using rule 106 (i -> call_function_pro .) ]
  ! TRUE            [ reduce using rule 106 (i -> call_function_pro .) ]
  ! FALSE           [ reduce using rule 106 (i -> call_function_pro .) ]
  ! L_PAREN         [ reduce using rule 106 (i -> call_function_pro .) ]
  ! L_CORCHETE      [ reduce using rule 106 (i -> call_function_pro .) ]
  ! L_LLAVE         [ reduce using rule 106 (i -> call_function_pro .) ]
  ! NOT             [ reduce using rule 106 (i -> call_function_pro .) ]
  ! $end            [ reduce using rule 106 (i -> call_function_pro .) ]
  ! R_LLAVE         [ reduce using rule 106 (i -> call_function_pro .) ]

    sc                             shift and go to state 71

state 19

    (19) instruccion -> a . sc
    (75) a -> a . OR b
    (21) sc -> . SEMI_COLON
    (22) sc -> .

    OR              shift and go to state 73
    SEMI_COLON      shift and go to state 57
    CONSOLE         reduce using rule 22 (sc -> .)
    LET             reduce using rule 22 (sc -> .)
    LITERAL         reduce using rule 22 (sc -> .)
    IF              reduce using rule 22 (sc -> .)
    WHILE           reduce using rule 22 (sc -> .)
    FOR             reduce using rule 22 (sc -> .)
    INTERFACE       reduce using rule 22 (sc -> .)
    CONTINUE        reduce using rule 22 (sc -> .)
    BREAK           reduce using rule 22 (sc -> .)
    RETURN          reduce using rule 22 (sc -> .)
    FUNCTION        reduce using rule 22 (sc -> .)
    TOSTRING        reduce using rule 22 (sc -> .)
    ENTERO          reduce using rule 22 (sc -> .)
    DECIMAL         reduce using rule 22 (sc -> .)
    CADENA          reduce using rule 22 (sc -> .)
    TRUE            reduce using rule 22 (sc -> .)
    FALSE           reduce using rule 22 (sc -> .)
    L_PAREN         reduce using rule 22 (sc -> .)
    L_CORCHETE      reduce using rule 22 (sc -> .)
    L_LLAVE         reduce using rule 22 (sc -> .)
    NOT             reduce using rule 22 (sc -> .)
    MENOS           reduce using rule 22 (sc -> .)
    MAS             reduce using rule 22 (sc -> .)
    $end            reduce using rule 22 (sc -> .)
    R_LLAVE         reduce using rule 22 (sc -> .)

    sc                             shift and go to state 72

state 20

    (20) instruccion -> sumadores . sc
    (21) sc -> . SEMI_COLON
    (22) sc -> .

    SEMI_COLON      shift and go to state 57
    CONSOLE         reduce using rule 22 (sc -> .)
    LET             reduce using rule 22 (sc -> .)
    LITERAL         reduce using rule 22 (sc -> .)
    IF              reduce using rule 22 (sc -> .)
    WHILE           reduce using rule 22 (sc -> .)
    FOR             reduce using rule 22 (sc -> .)
    INTERFACE       reduce using rule 22 (sc -> .)
    CONTINUE        reduce using rule 22 (sc -> .)
    BREAK           reduce using rule 22 (sc -> .)
    RETURN          reduce using rule 22 (sc -> .)
    FUNCTION        reduce using rule 22 (sc -> .)
    TOSTRING        reduce using rule 22 (sc -> .)
    ENTERO          reduce using rule 22 (sc -> .)
    DECIMAL         reduce using rule 22 (sc -> .)
    CADENA          reduce using rule 22 (sc -> .)
    TRUE            reduce using rule 22 (sc -> .)
    FALSE           reduce using rule 22 (sc -> .)
    L_PAREN         reduce using rule 22 (sc -> .)
    L_CORCHETE      reduce using rule 22 (sc -> .)
    L_LLAVE         reduce using rule 22 (sc -> .)
    NOT             reduce using rule 22 (sc -> .)
    MENOS           reduce using rule 22 (sc -> .)
    MAS             reduce using rule 22 (sc -> .)
    $end            reduce using rule 22 (sc -> .)
    R_LLAVE         reduce using rule 22 (sc -> .)

    sc                             shift and go to state 74

state 21

    (72) console_pro -> CONSOLE . PUNTO LOG L_PAREN expresion R_PAREN

    PUNTO           shift and go to state 75


state 22

    (109) i -> L_PAREN . a R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (77) b -> . b AND c
    (78) b -> . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    a                              shift and go to state 76
    b                              shift and go to state 36
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 23

    (48) declaration_instruction -> LET . declaracion_list
    (49) declaracion_list -> . declaracion_list COMA assignacion_instruction
    (50) declaracion_list -> . assignacion_instruction
    (51) assignacion_instruction -> . LITERAL COLON type IGUAL a
    (52) assignacion_instruction -> . LITERAL COLON type
    (53) assignacion_instruction -> . LITERAL IGUAL a
    (54) assignacion_instruction -> . LITERAL

    LITERAL         shift and go to state 82

    declaracion_list               shift and go to state 80
    assignacion_instruction        shift and go to state 81

state 24

    (61) assig_pro -> LITERAL . IGUAL a
    (123) array_assign_pro -> LITERAL . dimensions IGUAL a
    (29) call_function_pro -> LITERAL . L_PAREN values R_PAREN
    (30) call_function_pro -> LITERAL . L_PAREN R_PAREN
    (117) sumadores -> LITERAL . MAS MAS
    (118) sumadores -> LITERAL . MENOS MENOS
    (103) i -> LITERAL .
    (114) array_val_pro -> LITERAL . dimensions
    (115) dimensions -> . dimensions L_CORCHETE a R_CORCHETE
    (116) dimensions -> . L_CORCHETE a R_CORCHETE

  ! shift/reduce conflict for MAS resolved as shift
  ! shift/reduce conflict for MENOS resolved as shift
  ! shift/reduce conflict for L_PAREN resolved as shift
  ! shift/reduce conflict for L_CORCHETE resolved as shift
    IGUAL           shift and go to state 83
    L_PAREN         shift and go to state 85
    MAS             shift and go to state 86
    MENOS           shift and go to state 87
    PUNTO           reduce using rule 103 (i -> LITERAL .)
    POTENCIA        reduce using rule 103 (i -> LITERAL .)
    TIMES           reduce using rule 103 (i -> LITERAL .)
    DIVIDE          reduce using rule 103 (i -> LITERAL .)
    MOD             reduce using rule 103 (i -> LITERAL .)
    DISTINTO_QUE    reduce using rule 103 (i -> LITERAL .)
    MENOR_QUE       reduce using rule 103 (i -> LITERAL .)
    MENOR_IGUAL_QUE reduce using rule 103 (i -> LITERAL .)
    MAYOR_QUE       reduce using rule 103 (i -> LITERAL .)
    MAYOR_IGUAL_QUE reduce using rule 103 (i -> LITERAL .)
    TRIPLE_IGUAL    reduce using rule 103 (i -> LITERAL .)
    AND             reduce using rule 103 (i -> LITERAL .)
    OR              reduce using rule 103 (i -> LITERAL .)
    SEMI_COLON      reduce using rule 103 (i -> LITERAL .)
    CONSOLE         reduce using rule 103 (i -> LITERAL .)
    LET             reduce using rule 103 (i -> LITERAL .)
    LITERAL         reduce using rule 103 (i -> LITERAL .)
    IF              reduce using rule 103 (i -> LITERAL .)
    WHILE           reduce using rule 103 (i -> LITERAL .)
    FOR             reduce using rule 103 (i -> LITERAL .)
    INTERFACE       reduce using rule 103 (i -> LITERAL .)
    CONTINUE        reduce using rule 103 (i -> LITERAL .)
    BREAK           reduce using rule 103 (i -> LITERAL .)
    RETURN          reduce using rule 103 (i -> LITERAL .)
    FUNCTION        reduce using rule 103 (i -> LITERAL .)
    TOSTRING        reduce using rule 103 (i -> LITERAL .)
    ENTERO          reduce using rule 103 (i -> LITERAL .)
    DECIMAL         reduce using rule 103 (i -> LITERAL .)
    CADENA          reduce using rule 103 (i -> LITERAL .)
    TRUE            reduce using rule 103 (i -> LITERAL .)
    FALSE           reduce using rule 103 (i -> LITERAL .)
    L_LLAVE         reduce using rule 103 (i -> LITERAL .)
    NOT             reduce using rule 103 (i -> LITERAL .)
    $end            reduce using rule 103 (i -> LITERAL .)
    R_LLAVE         reduce using rule 103 (i -> LITERAL .)
    L_CORCHETE      shift and go to state 88

  ! MAS             [ reduce using rule 103 (i -> LITERAL .) ]
  ! MENOS           [ reduce using rule 103 (i -> LITERAL .) ]
  ! L_PAREN         [ reduce using rule 103 (i -> LITERAL .) ]
  ! L_CORCHETE      [ reduce using rule 103 (i -> LITERAL .) ]

    dimensions                     shift and go to state 84

state 25

    (47) interface_assign_pro -> i . PUNTO LITERAL IGUAL a
    (111) i -> i . PUNTO LITERAL
    (112) i -> i . PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> i . PUNTO nativeFun L_PAREN R_PAREN
    (99) h -> i .

    PUNTO           shift and go to state 89
    POTENCIA        reduce using rule 99 (h -> i .)
    TIMES           reduce using rule 99 (h -> i .)
    DIVIDE          reduce using rule 99 (h -> i .)
    MOD             reduce using rule 99 (h -> i .)
    MAS             reduce using rule 99 (h -> i .)
    MENOS           reduce using rule 99 (h -> i .)
    DISTINTO_QUE    reduce using rule 99 (h -> i .)
    MENOR_QUE       reduce using rule 99 (h -> i .)
    MENOR_IGUAL_QUE reduce using rule 99 (h -> i .)
    MAYOR_QUE       reduce using rule 99 (h -> i .)
    MAYOR_IGUAL_QUE reduce using rule 99 (h -> i .)
    TRIPLE_IGUAL    reduce using rule 99 (h -> i .)
    AND             reduce using rule 99 (h -> i .)
    OR              reduce using rule 99 (h -> i .)
    SEMI_COLON      reduce using rule 99 (h -> i .)
    CONSOLE         reduce using rule 99 (h -> i .)
    LET             reduce using rule 99 (h -> i .)
    LITERAL         reduce using rule 99 (h -> i .)
    IF              reduce using rule 99 (h -> i .)
    WHILE           reduce using rule 99 (h -> i .)
    FOR             reduce using rule 99 (h -> i .)
    INTERFACE       reduce using rule 99 (h -> i .)
    CONTINUE        reduce using rule 99 (h -> i .)
    BREAK           reduce using rule 99 (h -> i .)
    RETURN          reduce using rule 99 (h -> i .)
    FUNCTION        reduce using rule 99 (h -> i .)
    TOSTRING        reduce using rule 99 (h -> i .)
    ENTERO          reduce using rule 99 (h -> i .)
    DECIMAL         reduce using rule 99 (h -> i .)
    CADENA          reduce using rule 99 (h -> i .)
    TRUE            reduce using rule 99 (h -> i .)
    FALSE           reduce using rule 99 (h -> i .)
    L_PAREN         reduce using rule 99 (h -> i .)
    L_CORCHETE      reduce using rule 99 (h -> i .)
    L_LLAVE         reduce using rule 99 (h -> i .)
    NOT             reduce using rule 99 (h -> i .)
    $end            reduce using rule 99 (h -> i .)
    R_LLAVE         reduce using rule 99 (h -> i .)


state 26

    (62) if_pro -> IF . L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro

    L_PAREN         shift and go to state 90


state 27

    (119) interface_assi -> L_LLAVE . atributos_assi R_LLAVE
    (120) atributos_assi -> . atributos_assi COMA LITERAL COLON a
    (121) atributos_assi -> . LITERAL COLON a

    LITERAL         shift and go to state 92

    atributos_assi                 shift and go to state 91

state 28

    (66) while_pro -> WHILE . L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE

    L_PAREN         shift and go to state 93


state 29

    (67) for_pro -> FOR . L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> FOR . L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> FOR . L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE

    L_PAREN         shift and go to state 94


state 30

    (42) interface_pro -> INTERFACE . LITERAL L_LLAVE interface_atributos R_LLAVE

    LITERAL         shift and go to state 95


state 31

    (38) continue_pro -> CONTINUE .

    SEMI_COLON      reduce using rule 38 (continue_pro -> CONTINUE .)
    CONSOLE         reduce using rule 38 (continue_pro -> CONTINUE .)
    LET             reduce using rule 38 (continue_pro -> CONTINUE .)
    LITERAL         reduce using rule 38 (continue_pro -> CONTINUE .)
    IF              reduce using rule 38 (continue_pro -> CONTINUE .)
    WHILE           reduce using rule 38 (continue_pro -> CONTINUE .)
    FOR             reduce using rule 38 (continue_pro -> CONTINUE .)
    INTERFACE       reduce using rule 38 (continue_pro -> CONTINUE .)
    CONTINUE        reduce using rule 38 (continue_pro -> CONTINUE .)
    BREAK           reduce using rule 38 (continue_pro -> CONTINUE .)
    RETURN          reduce using rule 38 (continue_pro -> CONTINUE .)
    FUNCTION        reduce using rule 38 (continue_pro -> CONTINUE .)
    TOSTRING        reduce using rule 38 (continue_pro -> CONTINUE .)
    ENTERO          reduce using rule 38 (continue_pro -> CONTINUE .)
    DECIMAL         reduce using rule 38 (continue_pro -> CONTINUE .)
    CADENA          reduce using rule 38 (continue_pro -> CONTINUE .)
    TRUE            reduce using rule 38 (continue_pro -> CONTINUE .)
    FALSE           reduce using rule 38 (continue_pro -> CONTINUE .)
    L_PAREN         reduce using rule 38 (continue_pro -> CONTINUE .)
    L_CORCHETE      reduce using rule 38 (continue_pro -> CONTINUE .)
    L_LLAVE         reduce using rule 38 (continue_pro -> CONTINUE .)
    NOT             reduce using rule 38 (continue_pro -> CONTINUE .)
    MENOS           reduce using rule 38 (continue_pro -> CONTINUE .)
    MAS             reduce using rule 38 (continue_pro -> CONTINUE .)
    $end            reduce using rule 38 (continue_pro -> CONTINUE .)
    R_LLAVE         reduce using rule 38 (continue_pro -> CONTINUE .)


state 32

    (39) break_pro -> BREAK .

    SEMI_COLON      reduce using rule 39 (break_pro -> BREAK .)
    CONSOLE         reduce using rule 39 (break_pro -> BREAK .)
    LET             reduce using rule 39 (break_pro -> BREAK .)
    LITERAL         reduce using rule 39 (break_pro -> BREAK .)
    IF              reduce using rule 39 (break_pro -> BREAK .)
    WHILE           reduce using rule 39 (break_pro -> BREAK .)
    FOR             reduce using rule 39 (break_pro -> BREAK .)
    INTERFACE       reduce using rule 39 (break_pro -> BREAK .)
    CONTINUE        reduce using rule 39 (break_pro -> BREAK .)
    BREAK           reduce using rule 39 (break_pro -> BREAK .)
    RETURN          reduce using rule 39 (break_pro -> BREAK .)
    FUNCTION        reduce using rule 39 (break_pro -> BREAK .)
    TOSTRING        reduce using rule 39 (break_pro -> BREAK .)
    ENTERO          reduce using rule 39 (break_pro -> BREAK .)
    DECIMAL         reduce using rule 39 (break_pro -> BREAK .)
    CADENA          reduce using rule 39 (break_pro -> BREAK .)
    TRUE            reduce using rule 39 (break_pro -> BREAK .)
    FALSE           reduce using rule 39 (break_pro -> BREAK .)
    L_PAREN         reduce using rule 39 (break_pro -> BREAK .)
    L_CORCHETE      reduce using rule 39 (break_pro -> BREAK .)
    L_LLAVE         reduce using rule 39 (break_pro -> BREAK .)
    NOT             reduce using rule 39 (break_pro -> BREAK .)
    MENOS           reduce using rule 39 (break_pro -> BREAK .)
    MAS             reduce using rule 39 (break_pro -> BREAK .)
    $end            reduce using rule 39 (break_pro -> BREAK .)
    R_LLAVE         reduce using rule 39 (break_pro -> BREAK .)


state 33

    (40) return_pro -> RETURN .
    (41) return_pro -> RETURN . a
    (75) a -> . a OR b
    (76) a -> . b
    (77) b -> . b AND c
    (78) b -> . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MENOS resolved as shift
  ! shift/reduce conflict for MAS resolved as shift
  ! shift/reduce conflict for ENTERO resolved as shift
  ! shift/reduce conflict for DECIMAL resolved as shift
  ! shift/reduce conflict for CADENA resolved as shift
  ! shift/reduce conflict for LITERAL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for L_PAREN resolved as shift
  ! shift/reduce conflict for TOSTRING resolved as shift
  ! shift/reduce conflict for L_CORCHETE resolved as shift
  ! shift/reduce conflict for L_LLAVE resolved as shift
    SEMI_COLON      reduce using rule 40 (return_pro -> RETURN .)
    CONSOLE         reduce using rule 40 (return_pro -> RETURN .)
    LET             reduce using rule 40 (return_pro -> RETURN .)
    IF              reduce using rule 40 (return_pro -> RETURN .)
    WHILE           reduce using rule 40 (return_pro -> RETURN .)
    FOR             reduce using rule 40 (return_pro -> RETURN .)
    INTERFACE       reduce using rule 40 (return_pro -> RETURN .)
    CONTINUE        reduce using rule 40 (return_pro -> RETURN .)
    BREAK           reduce using rule 40 (return_pro -> RETURN .)
    RETURN          reduce using rule 40 (return_pro -> RETURN .)
    FUNCTION        reduce using rule 40 (return_pro -> RETURN .)
    $end            reduce using rule 40 (return_pro -> RETURN .)
    R_LLAVE         reduce using rule 40 (return_pro -> RETURN .)
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

  ! LITERAL         [ reduce using rule 40 (return_pro -> RETURN .) ]
  ! TOSTRING        [ reduce using rule 40 (return_pro -> RETURN .) ]
  ! ENTERO          [ reduce using rule 40 (return_pro -> RETURN .) ]
  ! DECIMAL         [ reduce using rule 40 (return_pro -> RETURN .) ]
  ! CADENA          [ reduce using rule 40 (return_pro -> RETURN .) ]
  ! TRUE            [ reduce using rule 40 (return_pro -> RETURN .) ]
  ! FALSE           [ reduce using rule 40 (return_pro -> RETURN .) ]
  ! L_PAREN         [ reduce using rule 40 (return_pro -> RETURN .) ]
  ! L_CORCHETE      [ reduce using rule 40 (return_pro -> RETURN .) ]
  ! L_LLAVE         [ reduce using rule 40 (return_pro -> RETURN .) ]
  ! NOT             [ reduce using rule 40 (return_pro -> RETURN .) ]
  ! MENOS           [ reduce using rule 40 (return_pro -> RETURN .) ]
  ! MAS             [ reduce using rule 40 (return_pro -> RETURN .) ]

    a                              shift and go to state 96
    b                              shift and go to state 36
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 34

    (23) function_pro -> FUNCTION . LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> FUNCTION . LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> FUNCTION . LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> FUNCTION . LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> FUNCTION . LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> FUNCTION . LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE

    LITERAL         shift and go to state 97


state 35

    (31) call_function_pro -> TOSTRING . L_PAREN values R_PAREN

    L_PAREN         shift and go to state 98


state 36

    (76) a -> b .
    (77) b -> b . AND c

    OR              reduce using rule 76 (a -> b .)
    SEMI_COLON      reduce using rule 76 (a -> b .)
    CONSOLE         reduce using rule 76 (a -> b .)
    LET             reduce using rule 76 (a -> b .)
    LITERAL         reduce using rule 76 (a -> b .)
    IF              reduce using rule 76 (a -> b .)
    WHILE           reduce using rule 76 (a -> b .)
    FOR             reduce using rule 76 (a -> b .)
    INTERFACE       reduce using rule 76 (a -> b .)
    CONTINUE        reduce using rule 76 (a -> b .)
    BREAK           reduce using rule 76 (a -> b .)
    RETURN          reduce using rule 76 (a -> b .)
    FUNCTION        reduce using rule 76 (a -> b .)
    TOSTRING        reduce using rule 76 (a -> b .)
    ENTERO          reduce using rule 76 (a -> b .)
    DECIMAL         reduce using rule 76 (a -> b .)
    CADENA          reduce using rule 76 (a -> b .)
    TRUE            reduce using rule 76 (a -> b .)
    FALSE           reduce using rule 76 (a -> b .)
    L_PAREN         reduce using rule 76 (a -> b .)
    L_CORCHETE      reduce using rule 76 (a -> b .)
    L_LLAVE         reduce using rule 76 (a -> b .)
    NOT             reduce using rule 76 (a -> b .)
    MENOS           reduce using rule 76 (a -> b .)
    MAS             reduce using rule 76 (a -> b .)
    $end            reduce using rule 76 (a -> b .)
    R_PAREN         reduce using rule 76 (a -> b .)
    R_LLAVE         reduce using rule 76 (a -> b .)
    R_CORCHETE      reduce using rule 76 (a -> b .)
    COMA            reduce using rule 76 (a -> b .)
    AND             shift and go to state 99


state 37

    (92) f -> MAS . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    g                              shift and go to state 100
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 38

    (91) f -> MENOS . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    g                              shift and go to state 101
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 39

    (100) i -> ENTERO .

    PUNTO           reduce using rule 100 (i -> ENTERO .)
    POTENCIA        reduce using rule 100 (i -> ENTERO .)
    TIMES           reduce using rule 100 (i -> ENTERO .)
    DIVIDE          reduce using rule 100 (i -> ENTERO .)
    MOD             reduce using rule 100 (i -> ENTERO .)
    MAS             reduce using rule 100 (i -> ENTERO .)
    MENOS           reduce using rule 100 (i -> ENTERO .)
    DISTINTO_QUE    reduce using rule 100 (i -> ENTERO .)
    MENOR_QUE       reduce using rule 100 (i -> ENTERO .)
    MENOR_IGUAL_QUE reduce using rule 100 (i -> ENTERO .)
    MAYOR_QUE       reduce using rule 100 (i -> ENTERO .)
    MAYOR_IGUAL_QUE reduce using rule 100 (i -> ENTERO .)
    TRIPLE_IGUAL    reduce using rule 100 (i -> ENTERO .)
    AND             reduce using rule 100 (i -> ENTERO .)
    OR              reduce using rule 100 (i -> ENTERO .)
    SEMI_COLON      reduce using rule 100 (i -> ENTERO .)
    CONSOLE         reduce using rule 100 (i -> ENTERO .)
    LET             reduce using rule 100 (i -> ENTERO .)
    LITERAL         reduce using rule 100 (i -> ENTERO .)
    IF              reduce using rule 100 (i -> ENTERO .)
    WHILE           reduce using rule 100 (i -> ENTERO .)
    FOR             reduce using rule 100 (i -> ENTERO .)
    INTERFACE       reduce using rule 100 (i -> ENTERO .)
    CONTINUE        reduce using rule 100 (i -> ENTERO .)
    BREAK           reduce using rule 100 (i -> ENTERO .)
    RETURN          reduce using rule 100 (i -> ENTERO .)
    FUNCTION        reduce using rule 100 (i -> ENTERO .)
    TOSTRING        reduce using rule 100 (i -> ENTERO .)
    ENTERO          reduce using rule 100 (i -> ENTERO .)
    DECIMAL         reduce using rule 100 (i -> ENTERO .)
    CADENA          reduce using rule 100 (i -> ENTERO .)
    TRUE            reduce using rule 100 (i -> ENTERO .)
    FALSE           reduce using rule 100 (i -> ENTERO .)
    L_PAREN         reduce using rule 100 (i -> ENTERO .)
    L_CORCHETE      reduce using rule 100 (i -> ENTERO .)
    L_LLAVE         reduce using rule 100 (i -> ENTERO .)
    NOT             reduce using rule 100 (i -> ENTERO .)
    $end            reduce using rule 100 (i -> ENTERO .)
    R_PAREN         reduce using rule 100 (i -> ENTERO .)
    R_LLAVE         reduce using rule 100 (i -> ENTERO .)
    R_CORCHETE      reduce using rule 100 (i -> ENTERO .)
    COMA            reduce using rule 100 (i -> ENTERO .)


state 40

    (101) i -> DECIMAL .

    PUNTO           reduce using rule 101 (i -> DECIMAL .)
    POTENCIA        reduce using rule 101 (i -> DECIMAL .)
    TIMES           reduce using rule 101 (i -> DECIMAL .)
    DIVIDE          reduce using rule 101 (i -> DECIMAL .)
    MOD             reduce using rule 101 (i -> DECIMAL .)
    MAS             reduce using rule 101 (i -> DECIMAL .)
    MENOS           reduce using rule 101 (i -> DECIMAL .)
    DISTINTO_QUE    reduce using rule 101 (i -> DECIMAL .)
    MENOR_QUE       reduce using rule 101 (i -> DECIMAL .)
    MENOR_IGUAL_QUE reduce using rule 101 (i -> DECIMAL .)
    MAYOR_QUE       reduce using rule 101 (i -> DECIMAL .)
    MAYOR_IGUAL_QUE reduce using rule 101 (i -> DECIMAL .)
    TRIPLE_IGUAL    reduce using rule 101 (i -> DECIMAL .)
    AND             reduce using rule 101 (i -> DECIMAL .)
    OR              reduce using rule 101 (i -> DECIMAL .)
    SEMI_COLON      reduce using rule 101 (i -> DECIMAL .)
    CONSOLE         reduce using rule 101 (i -> DECIMAL .)
    LET             reduce using rule 101 (i -> DECIMAL .)
    LITERAL         reduce using rule 101 (i -> DECIMAL .)
    IF              reduce using rule 101 (i -> DECIMAL .)
    WHILE           reduce using rule 101 (i -> DECIMAL .)
    FOR             reduce using rule 101 (i -> DECIMAL .)
    INTERFACE       reduce using rule 101 (i -> DECIMAL .)
    CONTINUE        reduce using rule 101 (i -> DECIMAL .)
    BREAK           reduce using rule 101 (i -> DECIMAL .)
    RETURN          reduce using rule 101 (i -> DECIMAL .)
    FUNCTION        reduce using rule 101 (i -> DECIMAL .)
    TOSTRING        reduce using rule 101 (i -> DECIMAL .)
    ENTERO          reduce using rule 101 (i -> DECIMAL .)
    DECIMAL         reduce using rule 101 (i -> DECIMAL .)
    CADENA          reduce using rule 101 (i -> DECIMAL .)
    TRUE            reduce using rule 101 (i -> DECIMAL .)
    FALSE           reduce using rule 101 (i -> DECIMAL .)
    L_PAREN         reduce using rule 101 (i -> DECIMAL .)
    L_CORCHETE      reduce using rule 101 (i -> DECIMAL .)
    L_LLAVE         reduce using rule 101 (i -> DECIMAL .)
    NOT             reduce using rule 101 (i -> DECIMAL .)
    $end            reduce using rule 101 (i -> DECIMAL .)
    R_PAREN         reduce using rule 101 (i -> DECIMAL .)
    R_LLAVE         reduce using rule 101 (i -> DECIMAL .)
    R_CORCHETE      reduce using rule 101 (i -> DECIMAL .)
    COMA            reduce using rule 101 (i -> DECIMAL .)


state 41

    (102) i -> CADENA .

    PUNTO           reduce using rule 102 (i -> CADENA .)
    POTENCIA        reduce using rule 102 (i -> CADENA .)
    TIMES           reduce using rule 102 (i -> CADENA .)
    DIVIDE          reduce using rule 102 (i -> CADENA .)
    MOD             reduce using rule 102 (i -> CADENA .)
    MAS             reduce using rule 102 (i -> CADENA .)
    MENOS           reduce using rule 102 (i -> CADENA .)
    DISTINTO_QUE    reduce using rule 102 (i -> CADENA .)
    MENOR_QUE       reduce using rule 102 (i -> CADENA .)
    MENOR_IGUAL_QUE reduce using rule 102 (i -> CADENA .)
    MAYOR_QUE       reduce using rule 102 (i -> CADENA .)
    MAYOR_IGUAL_QUE reduce using rule 102 (i -> CADENA .)
    TRIPLE_IGUAL    reduce using rule 102 (i -> CADENA .)
    AND             reduce using rule 102 (i -> CADENA .)
    OR              reduce using rule 102 (i -> CADENA .)
    SEMI_COLON      reduce using rule 102 (i -> CADENA .)
    CONSOLE         reduce using rule 102 (i -> CADENA .)
    LET             reduce using rule 102 (i -> CADENA .)
    LITERAL         reduce using rule 102 (i -> CADENA .)
    IF              reduce using rule 102 (i -> CADENA .)
    WHILE           reduce using rule 102 (i -> CADENA .)
    FOR             reduce using rule 102 (i -> CADENA .)
    INTERFACE       reduce using rule 102 (i -> CADENA .)
    CONTINUE        reduce using rule 102 (i -> CADENA .)
    BREAK           reduce using rule 102 (i -> CADENA .)
    RETURN          reduce using rule 102 (i -> CADENA .)
    FUNCTION        reduce using rule 102 (i -> CADENA .)
    TOSTRING        reduce using rule 102 (i -> CADENA .)
    ENTERO          reduce using rule 102 (i -> CADENA .)
    DECIMAL         reduce using rule 102 (i -> CADENA .)
    CADENA          reduce using rule 102 (i -> CADENA .)
    TRUE            reduce using rule 102 (i -> CADENA .)
    FALSE           reduce using rule 102 (i -> CADENA .)
    L_PAREN         reduce using rule 102 (i -> CADENA .)
    L_CORCHETE      reduce using rule 102 (i -> CADENA .)
    L_LLAVE         reduce using rule 102 (i -> CADENA .)
    NOT             reduce using rule 102 (i -> CADENA .)
    $end            reduce using rule 102 (i -> CADENA .)
    R_PAREN         reduce using rule 102 (i -> CADENA .)
    R_LLAVE         reduce using rule 102 (i -> CADENA .)
    R_CORCHETE      reduce using rule 102 (i -> CADENA .)
    COMA            reduce using rule 102 (i -> CADENA .)


state 42

    (104) i -> TRUE .

    PUNTO           reduce using rule 104 (i -> TRUE .)
    POTENCIA        reduce using rule 104 (i -> TRUE .)
    TIMES           reduce using rule 104 (i -> TRUE .)
    DIVIDE          reduce using rule 104 (i -> TRUE .)
    MOD             reduce using rule 104 (i -> TRUE .)
    MAS             reduce using rule 104 (i -> TRUE .)
    MENOS           reduce using rule 104 (i -> TRUE .)
    DISTINTO_QUE    reduce using rule 104 (i -> TRUE .)
    MENOR_QUE       reduce using rule 104 (i -> TRUE .)
    MENOR_IGUAL_QUE reduce using rule 104 (i -> TRUE .)
    MAYOR_QUE       reduce using rule 104 (i -> TRUE .)
    MAYOR_IGUAL_QUE reduce using rule 104 (i -> TRUE .)
    TRIPLE_IGUAL    reduce using rule 104 (i -> TRUE .)
    AND             reduce using rule 104 (i -> TRUE .)
    OR              reduce using rule 104 (i -> TRUE .)
    SEMI_COLON      reduce using rule 104 (i -> TRUE .)
    CONSOLE         reduce using rule 104 (i -> TRUE .)
    LET             reduce using rule 104 (i -> TRUE .)
    LITERAL         reduce using rule 104 (i -> TRUE .)
    IF              reduce using rule 104 (i -> TRUE .)
    WHILE           reduce using rule 104 (i -> TRUE .)
    FOR             reduce using rule 104 (i -> TRUE .)
    INTERFACE       reduce using rule 104 (i -> TRUE .)
    CONTINUE        reduce using rule 104 (i -> TRUE .)
    BREAK           reduce using rule 104 (i -> TRUE .)
    RETURN          reduce using rule 104 (i -> TRUE .)
    FUNCTION        reduce using rule 104 (i -> TRUE .)
    TOSTRING        reduce using rule 104 (i -> TRUE .)
    ENTERO          reduce using rule 104 (i -> TRUE .)
    DECIMAL         reduce using rule 104 (i -> TRUE .)
    CADENA          reduce using rule 104 (i -> TRUE .)
    TRUE            reduce using rule 104 (i -> TRUE .)
    FALSE           reduce using rule 104 (i -> TRUE .)
    L_PAREN         reduce using rule 104 (i -> TRUE .)
    L_CORCHETE      reduce using rule 104 (i -> TRUE .)
    L_LLAVE         reduce using rule 104 (i -> TRUE .)
    NOT             reduce using rule 104 (i -> TRUE .)
    $end            reduce using rule 104 (i -> TRUE .)
    R_PAREN         reduce using rule 104 (i -> TRUE .)
    R_LLAVE         reduce using rule 104 (i -> TRUE .)
    R_CORCHETE      reduce using rule 104 (i -> TRUE .)
    COMA            reduce using rule 104 (i -> TRUE .)


state 43

    (105) i -> FALSE .

    PUNTO           reduce using rule 105 (i -> FALSE .)
    POTENCIA        reduce using rule 105 (i -> FALSE .)
    TIMES           reduce using rule 105 (i -> FALSE .)
    DIVIDE          reduce using rule 105 (i -> FALSE .)
    MOD             reduce using rule 105 (i -> FALSE .)
    MAS             reduce using rule 105 (i -> FALSE .)
    MENOS           reduce using rule 105 (i -> FALSE .)
    DISTINTO_QUE    reduce using rule 105 (i -> FALSE .)
    MENOR_QUE       reduce using rule 105 (i -> FALSE .)
    MENOR_IGUAL_QUE reduce using rule 105 (i -> FALSE .)
    MAYOR_QUE       reduce using rule 105 (i -> FALSE .)
    MAYOR_IGUAL_QUE reduce using rule 105 (i -> FALSE .)
    TRIPLE_IGUAL    reduce using rule 105 (i -> FALSE .)
    AND             reduce using rule 105 (i -> FALSE .)
    OR              reduce using rule 105 (i -> FALSE .)
    SEMI_COLON      reduce using rule 105 (i -> FALSE .)
    CONSOLE         reduce using rule 105 (i -> FALSE .)
    LET             reduce using rule 105 (i -> FALSE .)
    LITERAL         reduce using rule 105 (i -> FALSE .)
    IF              reduce using rule 105 (i -> FALSE .)
    WHILE           reduce using rule 105 (i -> FALSE .)
    FOR             reduce using rule 105 (i -> FALSE .)
    INTERFACE       reduce using rule 105 (i -> FALSE .)
    CONTINUE        reduce using rule 105 (i -> FALSE .)
    BREAK           reduce using rule 105 (i -> FALSE .)
    RETURN          reduce using rule 105 (i -> FALSE .)
    FUNCTION        reduce using rule 105 (i -> FALSE .)
    TOSTRING        reduce using rule 105 (i -> FALSE .)
    ENTERO          reduce using rule 105 (i -> FALSE .)
    DECIMAL         reduce using rule 105 (i -> FALSE .)
    CADENA          reduce using rule 105 (i -> FALSE .)
    TRUE            reduce using rule 105 (i -> FALSE .)
    FALSE           reduce using rule 105 (i -> FALSE .)
    L_PAREN         reduce using rule 105 (i -> FALSE .)
    L_CORCHETE      reduce using rule 105 (i -> FALSE .)
    L_LLAVE         reduce using rule 105 (i -> FALSE .)
    NOT             reduce using rule 105 (i -> FALSE .)
    $end            reduce using rule 105 (i -> FALSE .)
    R_PAREN         reduce using rule 105 (i -> FALSE .)
    R_LLAVE         reduce using rule 105 (i -> FALSE .)
    R_CORCHETE      reduce using rule 105 (i -> FALSE .)
    COMA            reduce using rule 105 (i -> FALSE .)


state 44

    (107) i -> array_pro .

    PUNTO           reduce using rule 107 (i -> array_pro .)
    POTENCIA        reduce using rule 107 (i -> array_pro .)
    TIMES           reduce using rule 107 (i -> array_pro .)
    DIVIDE          reduce using rule 107 (i -> array_pro .)
    MOD             reduce using rule 107 (i -> array_pro .)
    MAS             reduce using rule 107 (i -> array_pro .)
    MENOS           reduce using rule 107 (i -> array_pro .)
    DISTINTO_QUE    reduce using rule 107 (i -> array_pro .)
    MENOR_QUE       reduce using rule 107 (i -> array_pro .)
    MENOR_IGUAL_QUE reduce using rule 107 (i -> array_pro .)
    MAYOR_QUE       reduce using rule 107 (i -> array_pro .)
    MAYOR_IGUAL_QUE reduce using rule 107 (i -> array_pro .)
    TRIPLE_IGUAL    reduce using rule 107 (i -> array_pro .)
    AND             reduce using rule 107 (i -> array_pro .)
    OR              reduce using rule 107 (i -> array_pro .)
    SEMI_COLON      reduce using rule 107 (i -> array_pro .)
    CONSOLE         reduce using rule 107 (i -> array_pro .)
    LET             reduce using rule 107 (i -> array_pro .)
    LITERAL         reduce using rule 107 (i -> array_pro .)
    IF              reduce using rule 107 (i -> array_pro .)
    WHILE           reduce using rule 107 (i -> array_pro .)
    FOR             reduce using rule 107 (i -> array_pro .)
    INTERFACE       reduce using rule 107 (i -> array_pro .)
    CONTINUE        reduce using rule 107 (i -> array_pro .)
    BREAK           reduce using rule 107 (i -> array_pro .)
    RETURN          reduce using rule 107 (i -> array_pro .)
    FUNCTION        reduce using rule 107 (i -> array_pro .)
    TOSTRING        reduce using rule 107 (i -> array_pro .)
    ENTERO          reduce using rule 107 (i -> array_pro .)
    DECIMAL         reduce using rule 107 (i -> array_pro .)
    CADENA          reduce using rule 107 (i -> array_pro .)
    TRUE            reduce using rule 107 (i -> array_pro .)
    FALSE           reduce using rule 107 (i -> array_pro .)
    L_PAREN         reduce using rule 107 (i -> array_pro .)
    L_CORCHETE      reduce using rule 107 (i -> array_pro .)
    L_LLAVE         reduce using rule 107 (i -> array_pro .)
    NOT             reduce using rule 107 (i -> array_pro .)
    $end            reduce using rule 107 (i -> array_pro .)
    R_PAREN         reduce using rule 107 (i -> array_pro .)
    R_LLAVE         reduce using rule 107 (i -> array_pro .)
    R_CORCHETE      reduce using rule 107 (i -> array_pro .)
    COMA            reduce using rule 107 (i -> array_pro .)


state 45

    (108) i -> interface_assi .

    PUNTO           reduce using rule 108 (i -> interface_assi .)
    POTENCIA        reduce using rule 108 (i -> interface_assi .)
    TIMES           reduce using rule 108 (i -> interface_assi .)
    DIVIDE          reduce using rule 108 (i -> interface_assi .)
    MOD             reduce using rule 108 (i -> interface_assi .)
    MAS             reduce using rule 108 (i -> interface_assi .)
    MENOS           reduce using rule 108 (i -> interface_assi .)
    DISTINTO_QUE    reduce using rule 108 (i -> interface_assi .)
    MENOR_QUE       reduce using rule 108 (i -> interface_assi .)
    MENOR_IGUAL_QUE reduce using rule 108 (i -> interface_assi .)
    MAYOR_QUE       reduce using rule 108 (i -> interface_assi .)
    MAYOR_IGUAL_QUE reduce using rule 108 (i -> interface_assi .)
    TRIPLE_IGUAL    reduce using rule 108 (i -> interface_assi .)
    AND             reduce using rule 108 (i -> interface_assi .)
    OR              reduce using rule 108 (i -> interface_assi .)
    SEMI_COLON      reduce using rule 108 (i -> interface_assi .)
    CONSOLE         reduce using rule 108 (i -> interface_assi .)
    LET             reduce using rule 108 (i -> interface_assi .)
    LITERAL         reduce using rule 108 (i -> interface_assi .)
    IF              reduce using rule 108 (i -> interface_assi .)
    WHILE           reduce using rule 108 (i -> interface_assi .)
    FOR             reduce using rule 108 (i -> interface_assi .)
    INTERFACE       reduce using rule 108 (i -> interface_assi .)
    CONTINUE        reduce using rule 108 (i -> interface_assi .)
    BREAK           reduce using rule 108 (i -> interface_assi .)
    RETURN          reduce using rule 108 (i -> interface_assi .)
    FUNCTION        reduce using rule 108 (i -> interface_assi .)
    TOSTRING        reduce using rule 108 (i -> interface_assi .)
    ENTERO          reduce using rule 108 (i -> interface_assi .)
    DECIMAL         reduce using rule 108 (i -> interface_assi .)
    CADENA          reduce using rule 108 (i -> interface_assi .)
    TRUE            reduce using rule 108 (i -> interface_assi .)
    FALSE           reduce using rule 108 (i -> interface_assi .)
    L_PAREN         reduce using rule 108 (i -> interface_assi .)
    L_CORCHETE      reduce using rule 108 (i -> interface_assi .)
    L_LLAVE         reduce using rule 108 (i -> interface_assi .)
    NOT             reduce using rule 108 (i -> interface_assi .)
    $end            reduce using rule 108 (i -> interface_assi .)
    R_PAREN         reduce using rule 108 (i -> interface_assi .)
    R_LLAVE         reduce using rule 108 (i -> interface_assi .)
    R_CORCHETE      reduce using rule 108 (i -> interface_assi .)
    COMA            reduce using rule 108 (i -> interface_assi .)


state 46

    (110) i -> array_val_pro .

    PUNTO           reduce using rule 110 (i -> array_val_pro .)
    POTENCIA        reduce using rule 110 (i -> array_val_pro .)
    TIMES           reduce using rule 110 (i -> array_val_pro .)
    DIVIDE          reduce using rule 110 (i -> array_val_pro .)
    MOD             reduce using rule 110 (i -> array_val_pro .)
    MAS             reduce using rule 110 (i -> array_val_pro .)
    MENOS           reduce using rule 110 (i -> array_val_pro .)
    DISTINTO_QUE    reduce using rule 110 (i -> array_val_pro .)
    MENOR_QUE       reduce using rule 110 (i -> array_val_pro .)
    MENOR_IGUAL_QUE reduce using rule 110 (i -> array_val_pro .)
    MAYOR_QUE       reduce using rule 110 (i -> array_val_pro .)
    MAYOR_IGUAL_QUE reduce using rule 110 (i -> array_val_pro .)
    TRIPLE_IGUAL    reduce using rule 110 (i -> array_val_pro .)
    AND             reduce using rule 110 (i -> array_val_pro .)
    OR              reduce using rule 110 (i -> array_val_pro .)
    SEMI_COLON      reduce using rule 110 (i -> array_val_pro .)
    CONSOLE         reduce using rule 110 (i -> array_val_pro .)
    LET             reduce using rule 110 (i -> array_val_pro .)
    LITERAL         reduce using rule 110 (i -> array_val_pro .)
    IF              reduce using rule 110 (i -> array_val_pro .)
    WHILE           reduce using rule 110 (i -> array_val_pro .)
    FOR             reduce using rule 110 (i -> array_val_pro .)
    INTERFACE       reduce using rule 110 (i -> array_val_pro .)
    CONTINUE        reduce using rule 110 (i -> array_val_pro .)
    BREAK           reduce using rule 110 (i -> array_val_pro .)
    RETURN          reduce using rule 110 (i -> array_val_pro .)
    FUNCTION        reduce using rule 110 (i -> array_val_pro .)
    TOSTRING        reduce using rule 110 (i -> array_val_pro .)
    ENTERO          reduce using rule 110 (i -> array_val_pro .)
    DECIMAL         reduce using rule 110 (i -> array_val_pro .)
    CADENA          reduce using rule 110 (i -> array_val_pro .)
    TRUE            reduce using rule 110 (i -> array_val_pro .)
    FALSE           reduce using rule 110 (i -> array_val_pro .)
    L_PAREN         reduce using rule 110 (i -> array_val_pro .)
    L_CORCHETE      reduce using rule 110 (i -> array_val_pro .)
    L_LLAVE         reduce using rule 110 (i -> array_val_pro .)
    NOT             reduce using rule 110 (i -> array_val_pro .)
    $end            reduce using rule 110 (i -> array_val_pro .)
    R_PAREN         reduce using rule 110 (i -> array_val_pro .)
    R_LLAVE         reduce using rule 110 (i -> array_val_pro .)
    R_CORCHETE      reduce using rule 110 (i -> array_val_pro .)
    COMA            reduce using rule 110 (i -> array_val_pro .)


state 47

    (78) b -> c .

    AND             reduce using rule 78 (b -> c .)
    OR              reduce using rule 78 (b -> c .)
    SEMI_COLON      reduce using rule 78 (b -> c .)
    CONSOLE         reduce using rule 78 (b -> c .)
    LET             reduce using rule 78 (b -> c .)
    LITERAL         reduce using rule 78 (b -> c .)
    IF              reduce using rule 78 (b -> c .)
    WHILE           reduce using rule 78 (b -> c .)
    FOR             reduce using rule 78 (b -> c .)
    INTERFACE       reduce using rule 78 (b -> c .)
    CONTINUE        reduce using rule 78 (b -> c .)
    BREAK           reduce using rule 78 (b -> c .)
    RETURN          reduce using rule 78 (b -> c .)
    FUNCTION        reduce using rule 78 (b -> c .)
    TOSTRING        reduce using rule 78 (b -> c .)
    ENTERO          reduce using rule 78 (b -> c .)
    DECIMAL         reduce using rule 78 (b -> c .)
    CADENA          reduce using rule 78 (b -> c .)
    TRUE            reduce using rule 78 (b -> c .)
    FALSE           reduce using rule 78 (b -> c .)
    L_PAREN         reduce using rule 78 (b -> c .)
    L_CORCHETE      reduce using rule 78 (b -> c .)
    L_LLAVE         reduce using rule 78 (b -> c .)
    NOT             reduce using rule 78 (b -> c .)
    MENOS           reduce using rule 78 (b -> c .)
    MAS             reduce using rule 78 (b -> c .)
    $end            reduce using rule 78 (b -> c .)
    R_PAREN         reduce using rule 78 (b -> c .)
    R_LLAVE         reduce using rule 78 (b -> c .)
    R_CORCHETE      reduce using rule 78 (b -> c .)
    COMA            reduce using rule 78 (b -> c .)


state 48

    (122) array_pro -> L_CORCHETE . values R_CORCHETE
    (32) values -> . values COMA a
    (33) values -> . a
    (75) a -> . a OR b
    (76) a -> . b
    (77) b -> . b AND c
    (78) b -> . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    values                         shift and go to state 102
    a                              shift and go to state 103
    b                              shift and go to state 36
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 49

    (79) c -> NOT . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    d                              shift and go to state 104
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 50

    (80) c -> d .
    (81) d -> d . DISTINTO_QUE e
    (82) d -> d . MENOR_QUE e
    (83) d -> d . MENOR_IGUAL_QUE e
    (84) d -> d . MAYOR_QUE e
    (85) d -> d . MAYOR_IGUAL_QUE e
    (86) d -> d . TRIPLE_IGUAL e

    AND             reduce using rule 80 (c -> d .)
    OR              reduce using rule 80 (c -> d .)
    SEMI_COLON      reduce using rule 80 (c -> d .)
    CONSOLE         reduce using rule 80 (c -> d .)
    LET             reduce using rule 80 (c -> d .)
    LITERAL         reduce using rule 80 (c -> d .)
    IF              reduce using rule 80 (c -> d .)
    WHILE           reduce using rule 80 (c -> d .)
    FOR             reduce using rule 80 (c -> d .)
    INTERFACE       reduce using rule 80 (c -> d .)
    CONTINUE        reduce using rule 80 (c -> d .)
    BREAK           reduce using rule 80 (c -> d .)
    RETURN          reduce using rule 80 (c -> d .)
    FUNCTION        reduce using rule 80 (c -> d .)
    TOSTRING        reduce using rule 80 (c -> d .)
    ENTERO          reduce using rule 80 (c -> d .)
    DECIMAL         reduce using rule 80 (c -> d .)
    CADENA          reduce using rule 80 (c -> d .)
    TRUE            reduce using rule 80 (c -> d .)
    FALSE           reduce using rule 80 (c -> d .)
    L_PAREN         reduce using rule 80 (c -> d .)
    L_CORCHETE      reduce using rule 80 (c -> d .)
    L_LLAVE         reduce using rule 80 (c -> d .)
    NOT             reduce using rule 80 (c -> d .)
    MENOS           reduce using rule 80 (c -> d .)
    MAS             reduce using rule 80 (c -> d .)
    $end            reduce using rule 80 (c -> d .)
    R_PAREN         reduce using rule 80 (c -> d .)
    R_LLAVE         reduce using rule 80 (c -> d .)
    R_CORCHETE      reduce using rule 80 (c -> d .)
    COMA            reduce using rule 80 (c -> d .)
    DISTINTO_QUE    shift and go to state 105
    MENOR_QUE       shift and go to state 106
    MENOR_IGUAL_QUE shift and go to state 107
    MAYOR_QUE       shift and go to state 108
    MAYOR_IGUAL_QUE shift and go to state 109
    TRIPLE_IGUAL    shift and go to state 110


state 51

    (87) d -> e .
    (88) e -> e . MAS f
    (89) e -> e . MENOS f

  ! shift/reduce conflict for MAS resolved as shift
  ! shift/reduce conflict for MENOS resolved as shift
    DISTINTO_QUE    reduce using rule 87 (d -> e .)
    MENOR_QUE       reduce using rule 87 (d -> e .)
    MENOR_IGUAL_QUE reduce using rule 87 (d -> e .)
    MAYOR_QUE       reduce using rule 87 (d -> e .)
    MAYOR_IGUAL_QUE reduce using rule 87 (d -> e .)
    TRIPLE_IGUAL    reduce using rule 87 (d -> e .)
    AND             reduce using rule 87 (d -> e .)
    OR              reduce using rule 87 (d -> e .)
    SEMI_COLON      reduce using rule 87 (d -> e .)
    CONSOLE         reduce using rule 87 (d -> e .)
    LET             reduce using rule 87 (d -> e .)
    LITERAL         reduce using rule 87 (d -> e .)
    IF              reduce using rule 87 (d -> e .)
    WHILE           reduce using rule 87 (d -> e .)
    FOR             reduce using rule 87 (d -> e .)
    INTERFACE       reduce using rule 87 (d -> e .)
    CONTINUE        reduce using rule 87 (d -> e .)
    BREAK           reduce using rule 87 (d -> e .)
    RETURN          reduce using rule 87 (d -> e .)
    FUNCTION        reduce using rule 87 (d -> e .)
    TOSTRING        reduce using rule 87 (d -> e .)
    ENTERO          reduce using rule 87 (d -> e .)
    DECIMAL         reduce using rule 87 (d -> e .)
    CADENA          reduce using rule 87 (d -> e .)
    TRUE            reduce using rule 87 (d -> e .)
    FALSE           reduce using rule 87 (d -> e .)
    L_PAREN         reduce using rule 87 (d -> e .)
    L_CORCHETE      reduce using rule 87 (d -> e .)
    L_LLAVE         reduce using rule 87 (d -> e .)
    NOT             reduce using rule 87 (d -> e .)
    $end            reduce using rule 87 (d -> e .)
    R_PAREN         reduce using rule 87 (d -> e .)
    R_LLAVE         reduce using rule 87 (d -> e .)
    R_CORCHETE      reduce using rule 87 (d -> e .)
    COMA            reduce using rule 87 (d -> e .)
    MAS             shift and go to state 111
    MENOS           shift and go to state 112

  ! MENOS           [ reduce using rule 87 (d -> e .) ]
  ! MAS             [ reduce using rule 87 (d -> e .) ]


state 52

    (90) e -> f .

    MAS             reduce using rule 90 (e -> f .)
    MENOS           reduce using rule 90 (e -> f .)
    DISTINTO_QUE    reduce using rule 90 (e -> f .)
    MENOR_QUE       reduce using rule 90 (e -> f .)
    MENOR_IGUAL_QUE reduce using rule 90 (e -> f .)
    MAYOR_QUE       reduce using rule 90 (e -> f .)
    MAYOR_IGUAL_QUE reduce using rule 90 (e -> f .)
    TRIPLE_IGUAL    reduce using rule 90 (e -> f .)
    AND             reduce using rule 90 (e -> f .)
    OR              reduce using rule 90 (e -> f .)
    SEMI_COLON      reduce using rule 90 (e -> f .)
    CONSOLE         reduce using rule 90 (e -> f .)
    LET             reduce using rule 90 (e -> f .)
    LITERAL         reduce using rule 90 (e -> f .)
    IF              reduce using rule 90 (e -> f .)
    WHILE           reduce using rule 90 (e -> f .)
    FOR             reduce using rule 90 (e -> f .)
    INTERFACE       reduce using rule 90 (e -> f .)
    CONTINUE        reduce using rule 90 (e -> f .)
    BREAK           reduce using rule 90 (e -> f .)
    RETURN          reduce using rule 90 (e -> f .)
    FUNCTION        reduce using rule 90 (e -> f .)
    TOSTRING        reduce using rule 90 (e -> f .)
    ENTERO          reduce using rule 90 (e -> f .)
    DECIMAL         reduce using rule 90 (e -> f .)
    CADENA          reduce using rule 90 (e -> f .)
    TRUE            reduce using rule 90 (e -> f .)
    FALSE           reduce using rule 90 (e -> f .)
    L_PAREN         reduce using rule 90 (e -> f .)
    L_CORCHETE      reduce using rule 90 (e -> f .)
    L_LLAVE         reduce using rule 90 (e -> f .)
    NOT             reduce using rule 90 (e -> f .)
    $end            reduce using rule 90 (e -> f .)
    R_PAREN         reduce using rule 90 (e -> f .)
    R_LLAVE         reduce using rule 90 (e -> f .)
    R_CORCHETE      reduce using rule 90 (e -> f .)
    COMA            reduce using rule 90 (e -> f .)


state 53

    (93) f -> g .
    (94) g -> g . TIMES h
    (95) g -> g . DIVIDE h
    (96) g -> g . MOD h

    MAS             reduce using rule 93 (f -> g .)
    MENOS           reduce using rule 93 (f -> g .)
    DISTINTO_QUE    reduce using rule 93 (f -> g .)
    MENOR_QUE       reduce using rule 93 (f -> g .)
    MENOR_IGUAL_QUE reduce using rule 93 (f -> g .)
    MAYOR_QUE       reduce using rule 93 (f -> g .)
    MAYOR_IGUAL_QUE reduce using rule 93 (f -> g .)
    TRIPLE_IGUAL    reduce using rule 93 (f -> g .)
    AND             reduce using rule 93 (f -> g .)
    OR              reduce using rule 93 (f -> g .)
    SEMI_COLON      reduce using rule 93 (f -> g .)
    CONSOLE         reduce using rule 93 (f -> g .)
    LET             reduce using rule 93 (f -> g .)
    LITERAL         reduce using rule 93 (f -> g .)
    IF              reduce using rule 93 (f -> g .)
    WHILE           reduce using rule 93 (f -> g .)
    FOR             reduce using rule 93 (f -> g .)
    INTERFACE       reduce using rule 93 (f -> g .)
    CONTINUE        reduce using rule 93 (f -> g .)
    BREAK           reduce using rule 93 (f -> g .)
    RETURN          reduce using rule 93 (f -> g .)
    FUNCTION        reduce using rule 93 (f -> g .)
    TOSTRING        reduce using rule 93 (f -> g .)
    ENTERO          reduce using rule 93 (f -> g .)
    DECIMAL         reduce using rule 93 (f -> g .)
    CADENA          reduce using rule 93 (f -> g .)
    TRUE            reduce using rule 93 (f -> g .)
    FALSE           reduce using rule 93 (f -> g .)
    L_PAREN         reduce using rule 93 (f -> g .)
    L_CORCHETE      reduce using rule 93 (f -> g .)
    L_LLAVE         reduce using rule 93 (f -> g .)
    NOT             reduce using rule 93 (f -> g .)
    $end            reduce using rule 93 (f -> g .)
    R_PAREN         reduce using rule 93 (f -> g .)
    R_LLAVE         reduce using rule 93 (f -> g .)
    R_CORCHETE      reduce using rule 93 (f -> g .)
    COMA            reduce using rule 93 (f -> g .)
    TIMES           shift and go to state 113
    DIVIDE          shift and go to state 114
    MOD             shift and go to state 115


state 54

    (97) g -> h .
    (98) h -> h . POTENCIA i

    TIMES           reduce using rule 97 (g -> h .)
    DIVIDE          reduce using rule 97 (g -> h .)
    MOD             reduce using rule 97 (g -> h .)
    MAS             reduce using rule 97 (g -> h .)
    MENOS           reduce using rule 97 (g -> h .)
    DISTINTO_QUE    reduce using rule 97 (g -> h .)
    MENOR_QUE       reduce using rule 97 (g -> h .)
    MENOR_IGUAL_QUE reduce using rule 97 (g -> h .)
    MAYOR_QUE       reduce using rule 97 (g -> h .)
    MAYOR_IGUAL_QUE reduce using rule 97 (g -> h .)
    TRIPLE_IGUAL    reduce using rule 97 (g -> h .)
    AND             reduce using rule 97 (g -> h .)
    OR              reduce using rule 97 (g -> h .)
    SEMI_COLON      reduce using rule 97 (g -> h .)
    CONSOLE         reduce using rule 97 (g -> h .)
    LET             reduce using rule 97 (g -> h .)
    LITERAL         reduce using rule 97 (g -> h .)
    IF              reduce using rule 97 (g -> h .)
    WHILE           reduce using rule 97 (g -> h .)
    FOR             reduce using rule 97 (g -> h .)
    INTERFACE       reduce using rule 97 (g -> h .)
    CONTINUE        reduce using rule 97 (g -> h .)
    BREAK           reduce using rule 97 (g -> h .)
    RETURN          reduce using rule 97 (g -> h .)
    FUNCTION        reduce using rule 97 (g -> h .)
    TOSTRING        reduce using rule 97 (g -> h .)
    ENTERO          reduce using rule 97 (g -> h .)
    DECIMAL         reduce using rule 97 (g -> h .)
    CADENA          reduce using rule 97 (g -> h .)
    TRUE            reduce using rule 97 (g -> h .)
    FALSE           reduce using rule 97 (g -> h .)
    L_PAREN         reduce using rule 97 (g -> h .)
    L_CORCHETE      reduce using rule 97 (g -> h .)
    L_LLAVE         reduce using rule 97 (g -> h .)
    NOT             reduce using rule 97 (g -> h .)
    $end            reduce using rule 97 (g -> h .)
    R_PAREN         reduce using rule 97 (g -> h .)
    R_LLAVE         reduce using rule 97 (g -> h .)
    R_CORCHETE      reduce using rule 97 (g -> h .)
    COMA            reduce using rule 97 (g -> h .)
    POTENCIA        shift and go to state 116


state 55

    (2) instrucciones -> instrucciones instruccion .

    CONSOLE         reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    LET             reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    LITERAL         reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    IF              reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    WHILE           reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    FOR             reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    INTERFACE       reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    CONTINUE        reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    BREAK           reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    RETURN          reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    FUNCTION        reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    TOSTRING        reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    ENTERO          reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    DECIMAL         reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    CADENA          reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    TRUE            reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    FALSE           reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    L_PAREN         reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    L_CORCHETE      reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    L_LLAVE         reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    NOT             reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    MENOS           reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    MAS             reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    $end            reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    R_LLAVE         reduce using rule 2 (instrucciones -> instrucciones instruccion .)


state 56

    (4) instruccion -> console_pro sc .

    CONSOLE         reduce using rule 4 (instruccion -> console_pro sc .)
    LET             reduce using rule 4 (instruccion -> console_pro sc .)
    LITERAL         reduce using rule 4 (instruccion -> console_pro sc .)
    IF              reduce using rule 4 (instruccion -> console_pro sc .)
    WHILE           reduce using rule 4 (instruccion -> console_pro sc .)
    FOR             reduce using rule 4 (instruccion -> console_pro sc .)
    INTERFACE       reduce using rule 4 (instruccion -> console_pro sc .)
    CONTINUE        reduce using rule 4 (instruccion -> console_pro sc .)
    BREAK           reduce using rule 4 (instruccion -> console_pro sc .)
    RETURN          reduce using rule 4 (instruccion -> console_pro sc .)
    FUNCTION        reduce using rule 4 (instruccion -> console_pro sc .)
    TOSTRING        reduce using rule 4 (instruccion -> console_pro sc .)
    ENTERO          reduce using rule 4 (instruccion -> console_pro sc .)
    DECIMAL         reduce using rule 4 (instruccion -> console_pro sc .)
    CADENA          reduce using rule 4 (instruccion -> console_pro sc .)
    TRUE            reduce using rule 4 (instruccion -> console_pro sc .)
    FALSE           reduce using rule 4 (instruccion -> console_pro sc .)
    L_PAREN         reduce using rule 4 (instruccion -> console_pro sc .)
    L_CORCHETE      reduce using rule 4 (instruccion -> console_pro sc .)
    L_LLAVE         reduce using rule 4 (instruccion -> console_pro sc .)
    NOT             reduce using rule 4 (instruccion -> console_pro sc .)
    MENOS           reduce using rule 4 (instruccion -> console_pro sc .)
    MAS             reduce using rule 4 (instruccion -> console_pro sc .)
    $end            reduce using rule 4 (instruccion -> console_pro sc .)
    R_LLAVE         reduce using rule 4 (instruccion -> console_pro sc .)


state 57

    (21) sc -> SEMI_COLON .

    CONSOLE         reduce using rule 21 (sc -> SEMI_COLON .)
    LET             reduce using rule 21 (sc -> SEMI_COLON .)
    LITERAL         reduce using rule 21 (sc -> SEMI_COLON .)
    IF              reduce using rule 21 (sc -> SEMI_COLON .)
    WHILE           reduce using rule 21 (sc -> SEMI_COLON .)
    FOR             reduce using rule 21 (sc -> SEMI_COLON .)
    INTERFACE       reduce using rule 21 (sc -> SEMI_COLON .)
    CONTINUE        reduce using rule 21 (sc -> SEMI_COLON .)
    BREAK           reduce using rule 21 (sc -> SEMI_COLON .)
    RETURN          reduce using rule 21 (sc -> SEMI_COLON .)
    FUNCTION        reduce using rule 21 (sc -> SEMI_COLON .)
    TOSTRING        reduce using rule 21 (sc -> SEMI_COLON .)
    ENTERO          reduce using rule 21 (sc -> SEMI_COLON .)
    DECIMAL         reduce using rule 21 (sc -> SEMI_COLON .)
    CADENA          reduce using rule 21 (sc -> SEMI_COLON .)
    TRUE            reduce using rule 21 (sc -> SEMI_COLON .)
    FALSE           reduce using rule 21 (sc -> SEMI_COLON .)
    L_PAREN         reduce using rule 21 (sc -> SEMI_COLON .)
    L_CORCHETE      reduce using rule 21 (sc -> SEMI_COLON .)
    L_LLAVE         reduce using rule 21 (sc -> SEMI_COLON .)
    NOT             reduce using rule 21 (sc -> SEMI_COLON .)
    MENOS           reduce using rule 21 (sc -> SEMI_COLON .)
    MAS             reduce using rule 21 (sc -> SEMI_COLON .)
    $end            reduce using rule 21 (sc -> SEMI_COLON .)
    R_LLAVE         reduce using rule 21 (sc -> SEMI_COLON .)


state 58

    (5) instruccion -> declaration_instruction sc .

    CONSOLE         reduce using rule 5 (instruccion -> declaration_instruction sc .)
    LET             reduce using rule 5 (instruccion -> declaration_instruction sc .)
    LITERAL         reduce using rule 5 (instruccion -> declaration_instruction sc .)
    IF              reduce using rule 5 (instruccion -> declaration_instruction sc .)
    WHILE           reduce using rule 5 (instruccion -> declaration_instruction sc .)
    FOR             reduce using rule 5 (instruccion -> declaration_instruction sc .)
    INTERFACE       reduce using rule 5 (instruccion -> declaration_instruction sc .)
    CONTINUE        reduce using rule 5 (instruccion -> declaration_instruction sc .)
    BREAK           reduce using rule 5 (instruccion -> declaration_instruction sc .)
    RETURN          reduce using rule 5 (instruccion -> declaration_instruction sc .)
    FUNCTION        reduce using rule 5 (instruccion -> declaration_instruction sc .)
    TOSTRING        reduce using rule 5 (instruccion -> declaration_instruction sc .)
    ENTERO          reduce using rule 5 (instruccion -> declaration_instruction sc .)
    DECIMAL         reduce using rule 5 (instruccion -> declaration_instruction sc .)
    CADENA          reduce using rule 5 (instruccion -> declaration_instruction sc .)
    TRUE            reduce using rule 5 (instruccion -> declaration_instruction sc .)
    FALSE           reduce using rule 5 (instruccion -> declaration_instruction sc .)
    L_PAREN         reduce using rule 5 (instruccion -> declaration_instruction sc .)
    L_CORCHETE      reduce using rule 5 (instruccion -> declaration_instruction sc .)
    L_LLAVE         reduce using rule 5 (instruccion -> declaration_instruction sc .)
    NOT             reduce using rule 5 (instruccion -> declaration_instruction sc .)
    MENOS           reduce using rule 5 (instruccion -> declaration_instruction sc .)
    MAS             reduce using rule 5 (instruccion -> declaration_instruction sc .)
    $end            reduce using rule 5 (instruccion -> declaration_instruction sc .)
    R_LLAVE         reduce using rule 5 (instruccion -> declaration_instruction sc .)


state 59

    (6) instruccion -> assig_pro sc .

    CONSOLE         reduce using rule 6 (instruccion -> assig_pro sc .)
    LET             reduce using rule 6 (instruccion -> assig_pro sc .)
    LITERAL         reduce using rule 6 (instruccion -> assig_pro sc .)
    IF              reduce using rule 6 (instruccion -> assig_pro sc .)
    WHILE           reduce using rule 6 (instruccion -> assig_pro sc .)
    FOR             reduce using rule 6 (instruccion -> assig_pro sc .)
    INTERFACE       reduce using rule 6 (instruccion -> assig_pro sc .)
    CONTINUE        reduce using rule 6 (instruccion -> assig_pro sc .)
    BREAK           reduce using rule 6 (instruccion -> assig_pro sc .)
    RETURN          reduce using rule 6 (instruccion -> assig_pro sc .)
    FUNCTION        reduce using rule 6 (instruccion -> assig_pro sc .)
    TOSTRING        reduce using rule 6 (instruccion -> assig_pro sc .)
    ENTERO          reduce using rule 6 (instruccion -> assig_pro sc .)
    DECIMAL         reduce using rule 6 (instruccion -> assig_pro sc .)
    CADENA          reduce using rule 6 (instruccion -> assig_pro sc .)
    TRUE            reduce using rule 6 (instruccion -> assig_pro sc .)
    FALSE           reduce using rule 6 (instruccion -> assig_pro sc .)
    L_PAREN         reduce using rule 6 (instruccion -> assig_pro sc .)
    L_CORCHETE      reduce using rule 6 (instruccion -> assig_pro sc .)
    L_LLAVE         reduce using rule 6 (instruccion -> assig_pro sc .)
    NOT             reduce using rule 6 (instruccion -> assig_pro sc .)
    MENOS           reduce using rule 6 (instruccion -> assig_pro sc .)
    MAS             reduce using rule 6 (instruccion -> assig_pro sc .)
    $end            reduce using rule 6 (instruccion -> assig_pro sc .)
    R_LLAVE         reduce using rule 6 (instruccion -> assig_pro sc .)


state 60

    (7) instruccion -> interface_assign_pro sc .

    CONSOLE         reduce using rule 7 (instruccion -> interface_assign_pro sc .)
    LET             reduce using rule 7 (instruccion -> interface_assign_pro sc .)
    LITERAL         reduce using rule 7 (instruccion -> interface_assign_pro sc .)
    IF              reduce using rule 7 (instruccion -> interface_assign_pro sc .)
    WHILE           reduce using rule 7 (instruccion -> interface_assign_pro sc .)
    FOR             reduce using rule 7 (instruccion -> interface_assign_pro sc .)
    INTERFACE       reduce using rule 7 (instruccion -> interface_assign_pro sc .)
    CONTINUE        reduce using rule 7 (instruccion -> interface_assign_pro sc .)
    BREAK           reduce using rule 7 (instruccion -> interface_assign_pro sc .)
    RETURN          reduce using rule 7 (instruccion -> interface_assign_pro sc .)
    FUNCTION        reduce using rule 7 (instruccion -> interface_assign_pro sc .)
    TOSTRING        reduce using rule 7 (instruccion -> interface_assign_pro sc .)
    ENTERO          reduce using rule 7 (instruccion -> interface_assign_pro sc .)
    DECIMAL         reduce using rule 7 (instruccion -> interface_assign_pro sc .)
    CADENA          reduce using rule 7 (instruccion -> interface_assign_pro sc .)
    TRUE            reduce using rule 7 (instruccion -> interface_assign_pro sc .)
    FALSE           reduce using rule 7 (instruccion -> interface_assign_pro sc .)
    L_PAREN         reduce using rule 7 (instruccion -> interface_assign_pro sc .)
    L_CORCHETE      reduce using rule 7 (instruccion -> interface_assign_pro sc .)
    L_LLAVE         reduce using rule 7 (instruccion -> interface_assign_pro sc .)
    NOT             reduce using rule 7 (instruccion -> interface_assign_pro sc .)
    MENOS           reduce using rule 7 (instruccion -> interface_assign_pro sc .)
    MAS             reduce using rule 7 (instruccion -> interface_assign_pro sc .)
    $end            reduce using rule 7 (instruccion -> interface_assign_pro sc .)
    R_LLAVE         reduce using rule 7 (instruccion -> interface_assign_pro sc .)


state 61

    (8) instruccion -> array_assign_pro sc .

    CONSOLE         reduce using rule 8 (instruccion -> array_assign_pro sc .)
    LET             reduce using rule 8 (instruccion -> array_assign_pro sc .)
    LITERAL         reduce using rule 8 (instruccion -> array_assign_pro sc .)
    IF              reduce using rule 8 (instruccion -> array_assign_pro sc .)
    WHILE           reduce using rule 8 (instruccion -> array_assign_pro sc .)
    FOR             reduce using rule 8 (instruccion -> array_assign_pro sc .)
    INTERFACE       reduce using rule 8 (instruccion -> array_assign_pro sc .)
    CONTINUE        reduce using rule 8 (instruccion -> array_assign_pro sc .)
    BREAK           reduce using rule 8 (instruccion -> array_assign_pro sc .)
    RETURN          reduce using rule 8 (instruccion -> array_assign_pro sc .)
    FUNCTION        reduce using rule 8 (instruccion -> array_assign_pro sc .)
    TOSTRING        reduce using rule 8 (instruccion -> array_assign_pro sc .)
    ENTERO          reduce using rule 8 (instruccion -> array_assign_pro sc .)
    DECIMAL         reduce using rule 8 (instruccion -> array_assign_pro sc .)
    CADENA          reduce using rule 8 (instruccion -> array_assign_pro sc .)
    TRUE            reduce using rule 8 (instruccion -> array_assign_pro sc .)
    FALSE           reduce using rule 8 (instruccion -> array_assign_pro sc .)
    L_PAREN         reduce using rule 8 (instruccion -> array_assign_pro sc .)
    L_CORCHETE      reduce using rule 8 (instruccion -> array_assign_pro sc .)
    L_LLAVE         reduce using rule 8 (instruccion -> array_assign_pro sc .)
    NOT             reduce using rule 8 (instruccion -> array_assign_pro sc .)
    MENOS           reduce using rule 8 (instruccion -> array_assign_pro sc .)
    MAS             reduce using rule 8 (instruccion -> array_assign_pro sc .)
    $end            reduce using rule 8 (instruccion -> array_assign_pro sc .)
    R_LLAVE         reduce using rule 8 (instruccion -> array_assign_pro sc .)


state 62

    (9) instruccion -> if_pro sc .

    CONSOLE         reduce using rule 9 (instruccion -> if_pro sc .)
    LET             reduce using rule 9 (instruccion -> if_pro sc .)
    LITERAL         reduce using rule 9 (instruccion -> if_pro sc .)
    IF              reduce using rule 9 (instruccion -> if_pro sc .)
    WHILE           reduce using rule 9 (instruccion -> if_pro sc .)
    FOR             reduce using rule 9 (instruccion -> if_pro sc .)
    INTERFACE       reduce using rule 9 (instruccion -> if_pro sc .)
    CONTINUE        reduce using rule 9 (instruccion -> if_pro sc .)
    BREAK           reduce using rule 9 (instruccion -> if_pro sc .)
    RETURN          reduce using rule 9 (instruccion -> if_pro sc .)
    FUNCTION        reduce using rule 9 (instruccion -> if_pro sc .)
    TOSTRING        reduce using rule 9 (instruccion -> if_pro sc .)
    ENTERO          reduce using rule 9 (instruccion -> if_pro sc .)
    DECIMAL         reduce using rule 9 (instruccion -> if_pro sc .)
    CADENA          reduce using rule 9 (instruccion -> if_pro sc .)
    TRUE            reduce using rule 9 (instruccion -> if_pro sc .)
    FALSE           reduce using rule 9 (instruccion -> if_pro sc .)
    L_PAREN         reduce using rule 9 (instruccion -> if_pro sc .)
    L_CORCHETE      reduce using rule 9 (instruccion -> if_pro sc .)
    L_LLAVE         reduce using rule 9 (instruccion -> if_pro sc .)
    NOT             reduce using rule 9 (instruccion -> if_pro sc .)
    MENOS           reduce using rule 9 (instruccion -> if_pro sc .)
    MAS             reduce using rule 9 (instruccion -> if_pro sc .)
    $end            reduce using rule 9 (instruccion -> if_pro sc .)
    R_LLAVE         reduce using rule 9 (instruccion -> if_pro sc .)


state 63

    (10) instruccion -> while_pro sc .

    CONSOLE         reduce using rule 10 (instruccion -> while_pro sc .)
    LET             reduce using rule 10 (instruccion -> while_pro sc .)
    LITERAL         reduce using rule 10 (instruccion -> while_pro sc .)
    IF              reduce using rule 10 (instruccion -> while_pro sc .)
    WHILE           reduce using rule 10 (instruccion -> while_pro sc .)
    FOR             reduce using rule 10 (instruccion -> while_pro sc .)
    INTERFACE       reduce using rule 10 (instruccion -> while_pro sc .)
    CONTINUE        reduce using rule 10 (instruccion -> while_pro sc .)
    BREAK           reduce using rule 10 (instruccion -> while_pro sc .)
    RETURN          reduce using rule 10 (instruccion -> while_pro sc .)
    FUNCTION        reduce using rule 10 (instruccion -> while_pro sc .)
    TOSTRING        reduce using rule 10 (instruccion -> while_pro sc .)
    ENTERO          reduce using rule 10 (instruccion -> while_pro sc .)
    DECIMAL         reduce using rule 10 (instruccion -> while_pro sc .)
    CADENA          reduce using rule 10 (instruccion -> while_pro sc .)
    TRUE            reduce using rule 10 (instruccion -> while_pro sc .)
    FALSE           reduce using rule 10 (instruccion -> while_pro sc .)
    L_PAREN         reduce using rule 10 (instruccion -> while_pro sc .)
    L_CORCHETE      reduce using rule 10 (instruccion -> while_pro sc .)
    L_LLAVE         reduce using rule 10 (instruccion -> while_pro sc .)
    NOT             reduce using rule 10 (instruccion -> while_pro sc .)
    MENOS           reduce using rule 10 (instruccion -> while_pro sc .)
    MAS             reduce using rule 10 (instruccion -> while_pro sc .)
    $end            reduce using rule 10 (instruccion -> while_pro sc .)
    R_LLAVE         reduce using rule 10 (instruccion -> while_pro sc .)


state 64

    (11) instruccion -> for_pro sc .

    CONSOLE         reduce using rule 11 (instruccion -> for_pro sc .)
    LET             reduce using rule 11 (instruccion -> for_pro sc .)
    LITERAL         reduce using rule 11 (instruccion -> for_pro sc .)
    IF              reduce using rule 11 (instruccion -> for_pro sc .)
    WHILE           reduce using rule 11 (instruccion -> for_pro sc .)
    FOR             reduce using rule 11 (instruccion -> for_pro sc .)
    INTERFACE       reduce using rule 11 (instruccion -> for_pro sc .)
    CONTINUE        reduce using rule 11 (instruccion -> for_pro sc .)
    BREAK           reduce using rule 11 (instruccion -> for_pro sc .)
    RETURN          reduce using rule 11 (instruccion -> for_pro sc .)
    FUNCTION        reduce using rule 11 (instruccion -> for_pro sc .)
    TOSTRING        reduce using rule 11 (instruccion -> for_pro sc .)
    ENTERO          reduce using rule 11 (instruccion -> for_pro sc .)
    DECIMAL         reduce using rule 11 (instruccion -> for_pro sc .)
    CADENA          reduce using rule 11 (instruccion -> for_pro sc .)
    TRUE            reduce using rule 11 (instruccion -> for_pro sc .)
    FALSE           reduce using rule 11 (instruccion -> for_pro sc .)
    L_PAREN         reduce using rule 11 (instruccion -> for_pro sc .)
    L_CORCHETE      reduce using rule 11 (instruccion -> for_pro sc .)
    L_LLAVE         reduce using rule 11 (instruccion -> for_pro sc .)
    NOT             reduce using rule 11 (instruccion -> for_pro sc .)
    MENOS           reduce using rule 11 (instruccion -> for_pro sc .)
    MAS             reduce using rule 11 (instruccion -> for_pro sc .)
    $end            reduce using rule 11 (instruccion -> for_pro sc .)
    R_LLAVE         reduce using rule 11 (instruccion -> for_pro sc .)


state 65

    (12) instruccion -> for_each_pro sc .

    CONSOLE         reduce using rule 12 (instruccion -> for_each_pro sc .)
    LET             reduce using rule 12 (instruccion -> for_each_pro sc .)
    LITERAL         reduce using rule 12 (instruccion -> for_each_pro sc .)
    IF              reduce using rule 12 (instruccion -> for_each_pro sc .)
    WHILE           reduce using rule 12 (instruccion -> for_each_pro sc .)
    FOR             reduce using rule 12 (instruccion -> for_each_pro sc .)
    INTERFACE       reduce using rule 12 (instruccion -> for_each_pro sc .)
    CONTINUE        reduce using rule 12 (instruccion -> for_each_pro sc .)
    BREAK           reduce using rule 12 (instruccion -> for_each_pro sc .)
    RETURN          reduce using rule 12 (instruccion -> for_each_pro sc .)
    FUNCTION        reduce using rule 12 (instruccion -> for_each_pro sc .)
    TOSTRING        reduce using rule 12 (instruccion -> for_each_pro sc .)
    ENTERO          reduce using rule 12 (instruccion -> for_each_pro sc .)
    DECIMAL         reduce using rule 12 (instruccion -> for_each_pro sc .)
    CADENA          reduce using rule 12 (instruccion -> for_each_pro sc .)
    TRUE            reduce using rule 12 (instruccion -> for_each_pro sc .)
    FALSE           reduce using rule 12 (instruccion -> for_each_pro sc .)
    L_PAREN         reduce using rule 12 (instruccion -> for_each_pro sc .)
    L_CORCHETE      reduce using rule 12 (instruccion -> for_each_pro sc .)
    L_LLAVE         reduce using rule 12 (instruccion -> for_each_pro sc .)
    NOT             reduce using rule 12 (instruccion -> for_each_pro sc .)
    MENOS           reduce using rule 12 (instruccion -> for_each_pro sc .)
    MAS             reduce using rule 12 (instruccion -> for_each_pro sc .)
    $end            reduce using rule 12 (instruccion -> for_each_pro sc .)
    R_LLAVE         reduce using rule 12 (instruccion -> for_each_pro sc .)


state 66

    (13) instruccion -> interface_pro sc .

    CONSOLE         reduce using rule 13 (instruccion -> interface_pro sc .)
    LET             reduce using rule 13 (instruccion -> interface_pro sc .)
    LITERAL         reduce using rule 13 (instruccion -> interface_pro sc .)
    IF              reduce using rule 13 (instruccion -> interface_pro sc .)
    WHILE           reduce using rule 13 (instruccion -> interface_pro sc .)
    FOR             reduce using rule 13 (instruccion -> interface_pro sc .)
    INTERFACE       reduce using rule 13 (instruccion -> interface_pro sc .)
    CONTINUE        reduce using rule 13 (instruccion -> interface_pro sc .)
    BREAK           reduce using rule 13 (instruccion -> interface_pro sc .)
    RETURN          reduce using rule 13 (instruccion -> interface_pro sc .)
    FUNCTION        reduce using rule 13 (instruccion -> interface_pro sc .)
    TOSTRING        reduce using rule 13 (instruccion -> interface_pro sc .)
    ENTERO          reduce using rule 13 (instruccion -> interface_pro sc .)
    DECIMAL         reduce using rule 13 (instruccion -> interface_pro sc .)
    CADENA          reduce using rule 13 (instruccion -> interface_pro sc .)
    TRUE            reduce using rule 13 (instruccion -> interface_pro sc .)
    FALSE           reduce using rule 13 (instruccion -> interface_pro sc .)
    L_PAREN         reduce using rule 13 (instruccion -> interface_pro sc .)
    L_CORCHETE      reduce using rule 13 (instruccion -> interface_pro sc .)
    L_LLAVE         reduce using rule 13 (instruccion -> interface_pro sc .)
    NOT             reduce using rule 13 (instruccion -> interface_pro sc .)
    MENOS           reduce using rule 13 (instruccion -> interface_pro sc .)
    MAS             reduce using rule 13 (instruccion -> interface_pro sc .)
    $end            reduce using rule 13 (instruccion -> interface_pro sc .)
    R_LLAVE         reduce using rule 13 (instruccion -> interface_pro sc .)


state 67

    (14) instruccion -> continue_pro sc .

    CONSOLE         reduce using rule 14 (instruccion -> continue_pro sc .)
    LET             reduce using rule 14 (instruccion -> continue_pro sc .)
    LITERAL         reduce using rule 14 (instruccion -> continue_pro sc .)
    IF              reduce using rule 14 (instruccion -> continue_pro sc .)
    WHILE           reduce using rule 14 (instruccion -> continue_pro sc .)
    FOR             reduce using rule 14 (instruccion -> continue_pro sc .)
    INTERFACE       reduce using rule 14 (instruccion -> continue_pro sc .)
    CONTINUE        reduce using rule 14 (instruccion -> continue_pro sc .)
    BREAK           reduce using rule 14 (instruccion -> continue_pro sc .)
    RETURN          reduce using rule 14 (instruccion -> continue_pro sc .)
    FUNCTION        reduce using rule 14 (instruccion -> continue_pro sc .)
    TOSTRING        reduce using rule 14 (instruccion -> continue_pro sc .)
    ENTERO          reduce using rule 14 (instruccion -> continue_pro sc .)
    DECIMAL         reduce using rule 14 (instruccion -> continue_pro sc .)
    CADENA          reduce using rule 14 (instruccion -> continue_pro sc .)
    TRUE            reduce using rule 14 (instruccion -> continue_pro sc .)
    FALSE           reduce using rule 14 (instruccion -> continue_pro sc .)
    L_PAREN         reduce using rule 14 (instruccion -> continue_pro sc .)
    L_CORCHETE      reduce using rule 14 (instruccion -> continue_pro sc .)
    L_LLAVE         reduce using rule 14 (instruccion -> continue_pro sc .)
    NOT             reduce using rule 14 (instruccion -> continue_pro sc .)
    MENOS           reduce using rule 14 (instruccion -> continue_pro sc .)
    MAS             reduce using rule 14 (instruccion -> continue_pro sc .)
    $end            reduce using rule 14 (instruccion -> continue_pro sc .)
    R_LLAVE         reduce using rule 14 (instruccion -> continue_pro sc .)


state 68

    (15) instruccion -> break_pro sc .

    CONSOLE         reduce using rule 15 (instruccion -> break_pro sc .)
    LET             reduce using rule 15 (instruccion -> break_pro sc .)
    LITERAL         reduce using rule 15 (instruccion -> break_pro sc .)
    IF              reduce using rule 15 (instruccion -> break_pro sc .)
    WHILE           reduce using rule 15 (instruccion -> break_pro sc .)
    FOR             reduce using rule 15 (instruccion -> break_pro sc .)
    INTERFACE       reduce using rule 15 (instruccion -> break_pro sc .)
    CONTINUE        reduce using rule 15 (instruccion -> break_pro sc .)
    BREAK           reduce using rule 15 (instruccion -> break_pro sc .)
    RETURN          reduce using rule 15 (instruccion -> break_pro sc .)
    FUNCTION        reduce using rule 15 (instruccion -> break_pro sc .)
    TOSTRING        reduce using rule 15 (instruccion -> break_pro sc .)
    ENTERO          reduce using rule 15 (instruccion -> break_pro sc .)
    DECIMAL         reduce using rule 15 (instruccion -> break_pro sc .)
    CADENA          reduce using rule 15 (instruccion -> break_pro sc .)
    TRUE            reduce using rule 15 (instruccion -> break_pro sc .)
    FALSE           reduce using rule 15 (instruccion -> break_pro sc .)
    L_PAREN         reduce using rule 15 (instruccion -> break_pro sc .)
    L_CORCHETE      reduce using rule 15 (instruccion -> break_pro sc .)
    L_LLAVE         reduce using rule 15 (instruccion -> break_pro sc .)
    NOT             reduce using rule 15 (instruccion -> break_pro sc .)
    MENOS           reduce using rule 15 (instruccion -> break_pro sc .)
    MAS             reduce using rule 15 (instruccion -> break_pro sc .)
    $end            reduce using rule 15 (instruccion -> break_pro sc .)
    R_LLAVE         reduce using rule 15 (instruccion -> break_pro sc .)


state 69

    (16) instruccion -> return_pro sc .

    CONSOLE         reduce using rule 16 (instruccion -> return_pro sc .)
    LET             reduce using rule 16 (instruccion -> return_pro sc .)
    LITERAL         reduce using rule 16 (instruccion -> return_pro sc .)
    IF              reduce using rule 16 (instruccion -> return_pro sc .)
    WHILE           reduce using rule 16 (instruccion -> return_pro sc .)
    FOR             reduce using rule 16 (instruccion -> return_pro sc .)
    INTERFACE       reduce using rule 16 (instruccion -> return_pro sc .)
    CONTINUE        reduce using rule 16 (instruccion -> return_pro sc .)
    BREAK           reduce using rule 16 (instruccion -> return_pro sc .)
    RETURN          reduce using rule 16 (instruccion -> return_pro sc .)
    FUNCTION        reduce using rule 16 (instruccion -> return_pro sc .)
    TOSTRING        reduce using rule 16 (instruccion -> return_pro sc .)
    ENTERO          reduce using rule 16 (instruccion -> return_pro sc .)
    DECIMAL         reduce using rule 16 (instruccion -> return_pro sc .)
    CADENA          reduce using rule 16 (instruccion -> return_pro sc .)
    TRUE            reduce using rule 16 (instruccion -> return_pro sc .)
    FALSE           reduce using rule 16 (instruccion -> return_pro sc .)
    L_PAREN         reduce using rule 16 (instruccion -> return_pro sc .)
    L_CORCHETE      reduce using rule 16 (instruccion -> return_pro sc .)
    L_LLAVE         reduce using rule 16 (instruccion -> return_pro sc .)
    NOT             reduce using rule 16 (instruccion -> return_pro sc .)
    MENOS           reduce using rule 16 (instruccion -> return_pro sc .)
    MAS             reduce using rule 16 (instruccion -> return_pro sc .)
    $end            reduce using rule 16 (instruccion -> return_pro sc .)
    R_LLAVE         reduce using rule 16 (instruccion -> return_pro sc .)


state 70

    (17) instruccion -> function_pro sc .

    CONSOLE         reduce using rule 17 (instruccion -> function_pro sc .)
    LET             reduce using rule 17 (instruccion -> function_pro sc .)
    LITERAL         reduce using rule 17 (instruccion -> function_pro sc .)
    IF              reduce using rule 17 (instruccion -> function_pro sc .)
    WHILE           reduce using rule 17 (instruccion -> function_pro sc .)
    FOR             reduce using rule 17 (instruccion -> function_pro sc .)
    INTERFACE       reduce using rule 17 (instruccion -> function_pro sc .)
    CONTINUE        reduce using rule 17 (instruccion -> function_pro sc .)
    BREAK           reduce using rule 17 (instruccion -> function_pro sc .)
    RETURN          reduce using rule 17 (instruccion -> function_pro sc .)
    FUNCTION        reduce using rule 17 (instruccion -> function_pro sc .)
    TOSTRING        reduce using rule 17 (instruccion -> function_pro sc .)
    ENTERO          reduce using rule 17 (instruccion -> function_pro sc .)
    DECIMAL         reduce using rule 17 (instruccion -> function_pro sc .)
    CADENA          reduce using rule 17 (instruccion -> function_pro sc .)
    TRUE            reduce using rule 17 (instruccion -> function_pro sc .)
    FALSE           reduce using rule 17 (instruccion -> function_pro sc .)
    L_PAREN         reduce using rule 17 (instruccion -> function_pro sc .)
    L_CORCHETE      reduce using rule 17 (instruccion -> function_pro sc .)
    L_LLAVE         reduce using rule 17 (instruccion -> function_pro sc .)
    NOT             reduce using rule 17 (instruccion -> function_pro sc .)
    MENOS           reduce using rule 17 (instruccion -> function_pro sc .)
    MAS             reduce using rule 17 (instruccion -> function_pro sc .)
    $end            reduce using rule 17 (instruccion -> function_pro sc .)
    R_LLAVE         reduce using rule 17 (instruccion -> function_pro sc .)


state 71

    (18) instruccion -> call_function_pro sc .

    CONSOLE         reduce using rule 18 (instruccion -> call_function_pro sc .)
    LET             reduce using rule 18 (instruccion -> call_function_pro sc .)
    LITERAL         reduce using rule 18 (instruccion -> call_function_pro sc .)
    IF              reduce using rule 18 (instruccion -> call_function_pro sc .)
    WHILE           reduce using rule 18 (instruccion -> call_function_pro sc .)
    FOR             reduce using rule 18 (instruccion -> call_function_pro sc .)
    INTERFACE       reduce using rule 18 (instruccion -> call_function_pro sc .)
    CONTINUE        reduce using rule 18 (instruccion -> call_function_pro sc .)
    BREAK           reduce using rule 18 (instruccion -> call_function_pro sc .)
    RETURN          reduce using rule 18 (instruccion -> call_function_pro sc .)
    FUNCTION        reduce using rule 18 (instruccion -> call_function_pro sc .)
    TOSTRING        reduce using rule 18 (instruccion -> call_function_pro sc .)
    ENTERO          reduce using rule 18 (instruccion -> call_function_pro sc .)
    DECIMAL         reduce using rule 18 (instruccion -> call_function_pro sc .)
    CADENA          reduce using rule 18 (instruccion -> call_function_pro sc .)
    TRUE            reduce using rule 18 (instruccion -> call_function_pro sc .)
    FALSE           reduce using rule 18 (instruccion -> call_function_pro sc .)
    L_PAREN         reduce using rule 18 (instruccion -> call_function_pro sc .)
    L_CORCHETE      reduce using rule 18 (instruccion -> call_function_pro sc .)
    L_LLAVE         reduce using rule 18 (instruccion -> call_function_pro sc .)
    NOT             reduce using rule 18 (instruccion -> call_function_pro sc .)
    MENOS           reduce using rule 18 (instruccion -> call_function_pro sc .)
    MAS             reduce using rule 18 (instruccion -> call_function_pro sc .)
    $end            reduce using rule 18 (instruccion -> call_function_pro sc .)
    R_LLAVE         reduce using rule 18 (instruccion -> call_function_pro sc .)


state 72

    (19) instruccion -> a sc .

    CONSOLE         reduce using rule 19 (instruccion -> a sc .)
    LET             reduce using rule 19 (instruccion -> a sc .)
    LITERAL         reduce using rule 19 (instruccion -> a sc .)
    IF              reduce using rule 19 (instruccion -> a sc .)
    WHILE           reduce using rule 19 (instruccion -> a sc .)
    FOR             reduce using rule 19 (instruccion -> a sc .)
    INTERFACE       reduce using rule 19 (instruccion -> a sc .)
    CONTINUE        reduce using rule 19 (instruccion -> a sc .)
    BREAK           reduce using rule 19 (instruccion -> a sc .)
    RETURN          reduce using rule 19 (instruccion -> a sc .)
    FUNCTION        reduce using rule 19 (instruccion -> a sc .)
    TOSTRING        reduce using rule 19 (instruccion -> a sc .)
    ENTERO          reduce using rule 19 (instruccion -> a sc .)
    DECIMAL         reduce using rule 19 (instruccion -> a sc .)
    CADENA          reduce using rule 19 (instruccion -> a sc .)
    TRUE            reduce using rule 19 (instruccion -> a sc .)
    FALSE           reduce using rule 19 (instruccion -> a sc .)
    L_PAREN         reduce using rule 19 (instruccion -> a sc .)
    L_CORCHETE      reduce using rule 19 (instruccion -> a sc .)
    L_LLAVE         reduce using rule 19 (instruccion -> a sc .)
    NOT             reduce using rule 19 (instruccion -> a sc .)
    MENOS           reduce using rule 19 (instruccion -> a sc .)
    MAS             reduce using rule 19 (instruccion -> a sc .)
    $end            reduce using rule 19 (instruccion -> a sc .)
    R_LLAVE         reduce using rule 19 (instruccion -> a sc .)


state 73

    (75) a -> a OR . b
    (77) b -> . b AND c
    (78) b -> . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    b                              shift and go to state 117
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 74

    (20) instruccion -> sumadores sc .

    CONSOLE         reduce using rule 20 (instruccion -> sumadores sc .)
    LET             reduce using rule 20 (instruccion -> sumadores sc .)
    LITERAL         reduce using rule 20 (instruccion -> sumadores sc .)
    IF              reduce using rule 20 (instruccion -> sumadores sc .)
    WHILE           reduce using rule 20 (instruccion -> sumadores sc .)
    FOR             reduce using rule 20 (instruccion -> sumadores sc .)
    INTERFACE       reduce using rule 20 (instruccion -> sumadores sc .)
    CONTINUE        reduce using rule 20 (instruccion -> sumadores sc .)
    BREAK           reduce using rule 20 (instruccion -> sumadores sc .)
    RETURN          reduce using rule 20 (instruccion -> sumadores sc .)
    FUNCTION        reduce using rule 20 (instruccion -> sumadores sc .)
    TOSTRING        reduce using rule 20 (instruccion -> sumadores sc .)
    ENTERO          reduce using rule 20 (instruccion -> sumadores sc .)
    DECIMAL         reduce using rule 20 (instruccion -> sumadores sc .)
    CADENA          reduce using rule 20 (instruccion -> sumadores sc .)
    TRUE            reduce using rule 20 (instruccion -> sumadores sc .)
    FALSE           reduce using rule 20 (instruccion -> sumadores sc .)
    L_PAREN         reduce using rule 20 (instruccion -> sumadores sc .)
    L_CORCHETE      reduce using rule 20 (instruccion -> sumadores sc .)
    L_LLAVE         reduce using rule 20 (instruccion -> sumadores sc .)
    NOT             reduce using rule 20 (instruccion -> sumadores sc .)
    MENOS           reduce using rule 20 (instruccion -> sumadores sc .)
    MAS             reduce using rule 20 (instruccion -> sumadores sc .)
    $end            reduce using rule 20 (instruccion -> sumadores sc .)
    R_LLAVE         reduce using rule 20 (instruccion -> sumadores sc .)


state 75

    (72) console_pro -> CONSOLE PUNTO . LOG L_PAREN expresion R_PAREN

    LOG             shift and go to state 118


state 76

    (109) i -> L_PAREN a . R_PAREN
    (75) a -> a . OR b

    R_PAREN         shift and go to state 119
    OR              shift and go to state 73


state 77

    (99) h -> i .
    (111) i -> i . PUNTO LITERAL
    (112) i -> i . PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> i . PUNTO nativeFun L_PAREN R_PAREN

    POTENCIA        reduce using rule 99 (h -> i .)
    TIMES           reduce using rule 99 (h -> i .)
    DIVIDE          reduce using rule 99 (h -> i .)
    MOD             reduce using rule 99 (h -> i .)
    MAS             reduce using rule 99 (h -> i .)
    MENOS           reduce using rule 99 (h -> i .)
    DISTINTO_QUE    reduce using rule 99 (h -> i .)
    MENOR_QUE       reduce using rule 99 (h -> i .)
    MENOR_IGUAL_QUE reduce using rule 99 (h -> i .)
    MAYOR_QUE       reduce using rule 99 (h -> i .)
    MAYOR_IGUAL_QUE reduce using rule 99 (h -> i .)
    TRIPLE_IGUAL    reduce using rule 99 (h -> i .)
    AND             reduce using rule 99 (h -> i .)
    R_PAREN         reduce using rule 99 (h -> i .)
    OR              reduce using rule 99 (h -> i .)
    SEMI_COLON      reduce using rule 99 (h -> i .)
    CONSOLE         reduce using rule 99 (h -> i .)
    LET             reduce using rule 99 (h -> i .)
    LITERAL         reduce using rule 99 (h -> i .)
    IF              reduce using rule 99 (h -> i .)
    WHILE           reduce using rule 99 (h -> i .)
    FOR             reduce using rule 99 (h -> i .)
    INTERFACE       reduce using rule 99 (h -> i .)
    CONTINUE        reduce using rule 99 (h -> i .)
    BREAK           reduce using rule 99 (h -> i .)
    RETURN          reduce using rule 99 (h -> i .)
    FUNCTION        reduce using rule 99 (h -> i .)
    TOSTRING        reduce using rule 99 (h -> i .)
    ENTERO          reduce using rule 99 (h -> i .)
    DECIMAL         reduce using rule 99 (h -> i .)
    CADENA          reduce using rule 99 (h -> i .)
    TRUE            reduce using rule 99 (h -> i .)
    FALSE           reduce using rule 99 (h -> i .)
    L_PAREN         reduce using rule 99 (h -> i .)
    L_CORCHETE      reduce using rule 99 (h -> i .)
    L_LLAVE         reduce using rule 99 (h -> i .)
    NOT             reduce using rule 99 (h -> i .)
    $end            reduce using rule 99 (h -> i .)
    R_LLAVE         reduce using rule 99 (h -> i .)
    R_CORCHETE      reduce using rule 99 (h -> i .)
    COMA            reduce using rule 99 (h -> i .)
    PUNTO           shift and go to state 120


state 78

    (103) i -> LITERAL .
    (29) call_function_pro -> LITERAL . L_PAREN values R_PAREN
    (30) call_function_pro -> LITERAL . L_PAREN R_PAREN
    (114) array_val_pro -> LITERAL . dimensions
    (115) dimensions -> . dimensions L_CORCHETE a R_CORCHETE
    (116) dimensions -> . L_CORCHETE a R_CORCHETE

  ! shift/reduce conflict for L_PAREN resolved as shift
  ! shift/reduce conflict for L_CORCHETE resolved as shift
    PUNTO           reduce using rule 103 (i -> LITERAL .)
    POTENCIA        reduce using rule 103 (i -> LITERAL .)
    TIMES           reduce using rule 103 (i -> LITERAL .)
    DIVIDE          reduce using rule 103 (i -> LITERAL .)
    MOD             reduce using rule 103 (i -> LITERAL .)
    MAS             reduce using rule 103 (i -> LITERAL .)
    MENOS           reduce using rule 103 (i -> LITERAL .)
    DISTINTO_QUE    reduce using rule 103 (i -> LITERAL .)
    MENOR_QUE       reduce using rule 103 (i -> LITERAL .)
    MENOR_IGUAL_QUE reduce using rule 103 (i -> LITERAL .)
    MAYOR_QUE       reduce using rule 103 (i -> LITERAL .)
    MAYOR_IGUAL_QUE reduce using rule 103 (i -> LITERAL .)
    TRIPLE_IGUAL    reduce using rule 103 (i -> LITERAL .)
    AND             reduce using rule 103 (i -> LITERAL .)
    R_PAREN         reduce using rule 103 (i -> LITERAL .)
    OR              reduce using rule 103 (i -> LITERAL .)
    SEMI_COLON      reduce using rule 103 (i -> LITERAL .)
    CONSOLE         reduce using rule 103 (i -> LITERAL .)
    LET             reduce using rule 103 (i -> LITERAL .)
    LITERAL         reduce using rule 103 (i -> LITERAL .)
    IF              reduce using rule 103 (i -> LITERAL .)
    WHILE           reduce using rule 103 (i -> LITERAL .)
    FOR             reduce using rule 103 (i -> LITERAL .)
    INTERFACE       reduce using rule 103 (i -> LITERAL .)
    CONTINUE        reduce using rule 103 (i -> LITERAL .)
    BREAK           reduce using rule 103 (i -> LITERAL .)
    RETURN          reduce using rule 103 (i -> LITERAL .)
    FUNCTION        reduce using rule 103 (i -> LITERAL .)
    TOSTRING        reduce using rule 103 (i -> LITERAL .)
    ENTERO          reduce using rule 103 (i -> LITERAL .)
    DECIMAL         reduce using rule 103 (i -> LITERAL .)
    CADENA          reduce using rule 103 (i -> LITERAL .)
    TRUE            reduce using rule 103 (i -> LITERAL .)
    FALSE           reduce using rule 103 (i -> LITERAL .)
    L_LLAVE         reduce using rule 103 (i -> LITERAL .)
    NOT             reduce using rule 103 (i -> LITERAL .)
    $end            reduce using rule 103 (i -> LITERAL .)
    R_LLAVE         reduce using rule 103 (i -> LITERAL .)
    R_CORCHETE      reduce using rule 103 (i -> LITERAL .)
    COMA            reduce using rule 103 (i -> LITERAL .)
    L_PAREN         shift and go to state 85
    L_CORCHETE      shift and go to state 88

  ! L_PAREN         [ reduce using rule 103 (i -> LITERAL .) ]
  ! L_CORCHETE      [ reduce using rule 103 (i -> LITERAL .) ]

    dimensions                     shift and go to state 121

state 79

    (106) i -> call_function_pro .

    PUNTO           reduce using rule 106 (i -> call_function_pro .)
    POTENCIA        reduce using rule 106 (i -> call_function_pro .)
    TIMES           reduce using rule 106 (i -> call_function_pro .)
    DIVIDE          reduce using rule 106 (i -> call_function_pro .)
    MOD             reduce using rule 106 (i -> call_function_pro .)
    MAS             reduce using rule 106 (i -> call_function_pro .)
    MENOS           reduce using rule 106 (i -> call_function_pro .)
    DISTINTO_QUE    reduce using rule 106 (i -> call_function_pro .)
    MENOR_QUE       reduce using rule 106 (i -> call_function_pro .)
    MENOR_IGUAL_QUE reduce using rule 106 (i -> call_function_pro .)
    MAYOR_QUE       reduce using rule 106 (i -> call_function_pro .)
    MAYOR_IGUAL_QUE reduce using rule 106 (i -> call_function_pro .)
    TRIPLE_IGUAL    reduce using rule 106 (i -> call_function_pro .)
    AND             reduce using rule 106 (i -> call_function_pro .)
    R_PAREN         reduce using rule 106 (i -> call_function_pro .)
    OR              reduce using rule 106 (i -> call_function_pro .)
    SEMI_COLON      reduce using rule 106 (i -> call_function_pro .)
    CONSOLE         reduce using rule 106 (i -> call_function_pro .)
    LET             reduce using rule 106 (i -> call_function_pro .)
    LITERAL         reduce using rule 106 (i -> call_function_pro .)
    IF              reduce using rule 106 (i -> call_function_pro .)
    WHILE           reduce using rule 106 (i -> call_function_pro .)
    FOR             reduce using rule 106 (i -> call_function_pro .)
    INTERFACE       reduce using rule 106 (i -> call_function_pro .)
    CONTINUE        reduce using rule 106 (i -> call_function_pro .)
    BREAK           reduce using rule 106 (i -> call_function_pro .)
    RETURN          reduce using rule 106 (i -> call_function_pro .)
    FUNCTION        reduce using rule 106 (i -> call_function_pro .)
    TOSTRING        reduce using rule 106 (i -> call_function_pro .)
    ENTERO          reduce using rule 106 (i -> call_function_pro .)
    DECIMAL         reduce using rule 106 (i -> call_function_pro .)
    CADENA          reduce using rule 106 (i -> call_function_pro .)
    TRUE            reduce using rule 106 (i -> call_function_pro .)
    FALSE           reduce using rule 106 (i -> call_function_pro .)
    L_PAREN         reduce using rule 106 (i -> call_function_pro .)
    L_CORCHETE      reduce using rule 106 (i -> call_function_pro .)
    L_LLAVE         reduce using rule 106 (i -> call_function_pro .)
    NOT             reduce using rule 106 (i -> call_function_pro .)
    $end            reduce using rule 106 (i -> call_function_pro .)
    R_LLAVE         reduce using rule 106 (i -> call_function_pro .)
    R_CORCHETE      reduce using rule 106 (i -> call_function_pro .)
    COMA            reduce using rule 106 (i -> call_function_pro .)


state 80

    (48) declaration_instruction -> LET declaracion_list .
    (49) declaracion_list -> declaracion_list . COMA assignacion_instruction

    SEMI_COLON      reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    CONSOLE         reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    LET             reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    LITERAL         reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    IF              reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    WHILE           reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    FOR             reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    INTERFACE       reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    CONTINUE        reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    BREAK           reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    RETURN          reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    FUNCTION        reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    TOSTRING        reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    ENTERO          reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    DECIMAL         reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    CADENA          reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    TRUE            reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    FALSE           reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    L_PAREN         reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    L_CORCHETE      reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    L_LLAVE         reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    NOT             reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    MENOS           reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    MAS             reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    $end            reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    R_LLAVE         reduce using rule 48 (declaration_instruction -> LET declaracion_list .)
    COMA            shift and go to state 122


state 81

    (50) declaracion_list -> assignacion_instruction .

    COMA            reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    SEMI_COLON      reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    CONSOLE         reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    LET             reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    LITERAL         reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    IF              reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    WHILE           reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    FOR             reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    INTERFACE       reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    CONTINUE        reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    BREAK           reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    RETURN          reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    FUNCTION        reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    TOSTRING        reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    ENTERO          reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    DECIMAL         reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    CADENA          reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    TRUE            reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    FALSE           reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    L_PAREN         reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    L_CORCHETE      reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    L_LLAVE         reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    NOT             reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    MENOS           reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    MAS             reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    $end            reduce using rule 50 (declaracion_list -> assignacion_instruction .)
    R_LLAVE         reduce using rule 50 (declaracion_list -> assignacion_instruction .)


state 82

    (51) assignacion_instruction -> LITERAL . COLON type IGUAL a
    (52) assignacion_instruction -> LITERAL . COLON type
    (53) assignacion_instruction -> LITERAL . IGUAL a
    (54) assignacion_instruction -> LITERAL .

    COLON           shift and go to state 123
    IGUAL           shift and go to state 124
    COMA            reduce using rule 54 (assignacion_instruction -> LITERAL .)
    SEMI_COLON      reduce using rule 54 (assignacion_instruction -> LITERAL .)
    CONSOLE         reduce using rule 54 (assignacion_instruction -> LITERAL .)
    LET             reduce using rule 54 (assignacion_instruction -> LITERAL .)
    LITERAL         reduce using rule 54 (assignacion_instruction -> LITERAL .)
    IF              reduce using rule 54 (assignacion_instruction -> LITERAL .)
    WHILE           reduce using rule 54 (assignacion_instruction -> LITERAL .)
    FOR             reduce using rule 54 (assignacion_instruction -> LITERAL .)
    INTERFACE       reduce using rule 54 (assignacion_instruction -> LITERAL .)
    CONTINUE        reduce using rule 54 (assignacion_instruction -> LITERAL .)
    BREAK           reduce using rule 54 (assignacion_instruction -> LITERAL .)
    RETURN          reduce using rule 54 (assignacion_instruction -> LITERAL .)
    FUNCTION        reduce using rule 54 (assignacion_instruction -> LITERAL .)
    TOSTRING        reduce using rule 54 (assignacion_instruction -> LITERAL .)
    ENTERO          reduce using rule 54 (assignacion_instruction -> LITERAL .)
    DECIMAL         reduce using rule 54 (assignacion_instruction -> LITERAL .)
    CADENA          reduce using rule 54 (assignacion_instruction -> LITERAL .)
    TRUE            reduce using rule 54 (assignacion_instruction -> LITERAL .)
    FALSE           reduce using rule 54 (assignacion_instruction -> LITERAL .)
    L_PAREN         reduce using rule 54 (assignacion_instruction -> LITERAL .)
    L_CORCHETE      reduce using rule 54 (assignacion_instruction -> LITERAL .)
    L_LLAVE         reduce using rule 54 (assignacion_instruction -> LITERAL .)
    NOT             reduce using rule 54 (assignacion_instruction -> LITERAL .)
    MENOS           reduce using rule 54 (assignacion_instruction -> LITERAL .)
    MAS             reduce using rule 54 (assignacion_instruction -> LITERAL .)
    $end            reduce using rule 54 (assignacion_instruction -> LITERAL .)
    R_LLAVE         reduce using rule 54 (assignacion_instruction -> LITERAL .)


state 83

    (61) assig_pro -> LITERAL IGUAL . a
    (75) a -> . a OR b
    (76) a -> . b
    (77) b -> . b AND c
    (78) b -> . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    a                              shift and go to state 125
    b                              shift and go to state 36
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 84

    (123) array_assign_pro -> LITERAL dimensions . IGUAL a
    (114) array_val_pro -> LITERAL dimensions .
    (115) dimensions -> dimensions . L_CORCHETE a R_CORCHETE

  ! shift/reduce conflict for L_CORCHETE resolved as shift
    IGUAL           shift and go to state 126
    PUNTO           reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    POTENCIA        reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    TIMES           reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    DIVIDE          reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    MOD             reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    MAS             reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    MENOS           reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    DISTINTO_QUE    reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    MENOR_QUE       reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    MENOR_IGUAL_QUE reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    MAYOR_QUE       reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    MAYOR_IGUAL_QUE reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    TRIPLE_IGUAL    reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    AND             reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    OR              reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    SEMI_COLON      reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    CONSOLE         reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    LET             reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    LITERAL         reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    IF              reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    WHILE           reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    FOR             reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    INTERFACE       reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    CONTINUE        reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    BREAK           reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    RETURN          reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    FUNCTION        reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    TOSTRING        reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    ENTERO          reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    DECIMAL         reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    CADENA          reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    TRUE            reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    FALSE           reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    L_PAREN         reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    L_LLAVE         reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    NOT             reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    $end            reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    R_LLAVE         reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    L_CORCHETE      shift and go to state 127

  ! L_CORCHETE      [ reduce using rule 114 (array_val_pro -> LITERAL dimensions .) ]


state 85

    (29) call_function_pro -> LITERAL L_PAREN . values R_PAREN
    (30) call_function_pro -> LITERAL L_PAREN . R_PAREN
    (32) values -> . values COMA a
    (33) values -> . a
    (75) a -> . a OR b
    (76) a -> . b
    (77) b -> . b AND c
    (78) b -> . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    R_PAREN         shift and go to state 129
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    values                         shift and go to state 128
    a                              shift and go to state 103
    b                              shift and go to state 36
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 86

    (117) sumadores -> LITERAL MAS . MAS

    MAS             shift and go to state 130


state 87

    (118) sumadores -> LITERAL MENOS . MENOS

    MENOS           shift and go to state 131


state 88

    (116) dimensions -> L_CORCHETE . a R_CORCHETE
    (75) a -> . a OR b
    (76) a -> . b
    (77) b -> . b AND c
    (78) b -> . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    a                              shift and go to state 132
    b                              shift and go to state 36
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 89

    (47) interface_assign_pro -> i PUNTO . LITERAL IGUAL a
    (111) i -> i PUNTO . LITERAL
    (112) i -> i PUNTO . nativeFun L_PAREN expresion R_PAREN
    (113) i -> i PUNTO . nativeFun L_PAREN R_PAREN
    (124) nativeFun -> . TOSTRING
    (125) nativeFun -> . TOFIXED
    (126) nativeFun -> . TOEXPONENTIAL
    (127) nativeFun -> . TOLOWERCASE
    (128) nativeFun -> . TOUPPERCASE
    (129) nativeFun -> . SPLIT
    (130) nativeFun -> . CONCAT
    (131) nativeFun -> . LENGTH
    (132) nativeFun -> . PUSH

    LITERAL         shift and go to state 133
    TOSTRING        shift and go to state 135
    TOFIXED         shift and go to state 136
    TOEXPONENTIAL   shift and go to state 137
    TOLOWERCASE     shift and go to state 138
    TOUPPERCASE     shift and go to state 139
    SPLIT           shift and go to state 140
    CONCAT          shift and go to state 141
    LENGTH          shift and go to state 142
    PUSH            shift and go to state 143

    nativeFun                      shift and go to state 134

state 90

    (62) if_pro -> IF L_PAREN . a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (75) a -> . a OR b
    (76) a -> . b
    (77) b -> . b AND c
    (78) b -> . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    a                              shift and go to state 144
    b                              shift and go to state 36
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 91

    (119) interface_assi -> L_LLAVE atributos_assi . R_LLAVE
    (120) atributos_assi -> atributos_assi . COMA LITERAL COLON a

    R_LLAVE         shift and go to state 145
    COMA            shift and go to state 146


state 92

    (121) atributos_assi -> LITERAL . COLON a

    COLON           shift and go to state 147


state 93

    (66) while_pro -> WHILE L_PAREN . a R_PAREN L_LLAVE instrucciones R_LLAVE
    (75) a -> . a OR b
    (76) a -> . b
    (77) b -> . b AND c
    (78) b -> . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    a                              shift and go to state 148
    b                              shift and go to state 36
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 94

    (67) for_pro -> FOR L_PAREN . declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> FOR L_PAREN . assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> FOR L_PAREN . LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a

    LET             shift and go to state 151
    LITERAL         shift and go to state 152

    declaration_instruction        shift and go to state 149
    assig_pro                      shift and go to state 150

state 95

    (42) interface_pro -> INTERFACE LITERAL . L_LLAVE interface_atributos R_LLAVE

    L_LLAVE         shift and go to state 153


state 96

    (41) return_pro -> RETURN a .
    (75) a -> a . OR b

    SEMI_COLON      reduce using rule 41 (return_pro -> RETURN a .)
    CONSOLE         reduce using rule 41 (return_pro -> RETURN a .)
    LET             reduce using rule 41 (return_pro -> RETURN a .)
    LITERAL         reduce using rule 41 (return_pro -> RETURN a .)
    IF              reduce using rule 41 (return_pro -> RETURN a .)
    WHILE           reduce using rule 41 (return_pro -> RETURN a .)
    FOR             reduce using rule 41 (return_pro -> RETURN a .)
    INTERFACE       reduce using rule 41 (return_pro -> RETURN a .)
    CONTINUE        reduce using rule 41 (return_pro -> RETURN a .)
    BREAK           reduce using rule 41 (return_pro -> RETURN a .)
    RETURN          reduce using rule 41 (return_pro -> RETURN a .)
    FUNCTION        reduce using rule 41 (return_pro -> RETURN a .)
    TOSTRING        reduce using rule 41 (return_pro -> RETURN a .)
    ENTERO          reduce using rule 41 (return_pro -> RETURN a .)
    DECIMAL         reduce using rule 41 (return_pro -> RETURN a .)
    CADENA          reduce using rule 41 (return_pro -> RETURN a .)
    TRUE            reduce using rule 41 (return_pro -> RETURN a .)
    FALSE           reduce using rule 41 (return_pro -> RETURN a .)
    L_PAREN         reduce using rule 41 (return_pro -> RETURN a .)
    L_CORCHETE      reduce using rule 41 (return_pro -> RETURN a .)
    L_LLAVE         reduce using rule 41 (return_pro -> RETURN a .)
    NOT             reduce using rule 41 (return_pro -> RETURN a .)
    MENOS           reduce using rule 41 (return_pro -> RETURN a .)
    MAS             reduce using rule 41 (return_pro -> RETURN a .)
    $end            reduce using rule 41 (return_pro -> RETURN a .)
    R_LLAVE         reduce using rule 41 (return_pro -> RETURN a .)
    OR              shift and go to state 73


state 97

    (23) function_pro -> FUNCTION LITERAL . L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> FUNCTION LITERAL . L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> FUNCTION LITERAL . L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> FUNCTION LITERAL . L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> FUNCTION LITERAL . L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> FUNCTION LITERAL . L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE

    L_PAREN         shift and go to state 154


state 98

    (31) call_function_pro -> TOSTRING L_PAREN . values R_PAREN
    (32) values -> . values COMA a
    (33) values -> . a
    (75) a -> . a OR b
    (76) a -> . b
    (77) b -> . b AND c
    (78) b -> . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    values                         shift and go to state 155
    a                              shift and go to state 103
    b                              shift and go to state 36
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 99

    (77) b -> b AND . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    c                              shift and go to state 156
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 100

    (92) f -> MAS g .
    (94) g -> g . TIMES h
    (95) g -> g . DIVIDE h
    (96) g -> g . MOD h

    MAS             reduce using rule 92 (f -> MAS g .)
    MENOS           reduce using rule 92 (f -> MAS g .)
    DISTINTO_QUE    reduce using rule 92 (f -> MAS g .)
    MENOR_QUE       reduce using rule 92 (f -> MAS g .)
    MENOR_IGUAL_QUE reduce using rule 92 (f -> MAS g .)
    MAYOR_QUE       reduce using rule 92 (f -> MAS g .)
    MAYOR_IGUAL_QUE reduce using rule 92 (f -> MAS g .)
    TRIPLE_IGUAL    reduce using rule 92 (f -> MAS g .)
    AND             reduce using rule 92 (f -> MAS g .)
    OR              reduce using rule 92 (f -> MAS g .)
    SEMI_COLON      reduce using rule 92 (f -> MAS g .)
    CONSOLE         reduce using rule 92 (f -> MAS g .)
    LET             reduce using rule 92 (f -> MAS g .)
    LITERAL         reduce using rule 92 (f -> MAS g .)
    IF              reduce using rule 92 (f -> MAS g .)
    WHILE           reduce using rule 92 (f -> MAS g .)
    FOR             reduce using rule 92 (f -> MAS g .)
    INTERFACE       reduce using rule 92 (f -> MAS g .)
    CONTINUE        reduce using rule 92 (f -> MAS g .)
    BREAK           reduce using rule 92 (f -> MAS g .)
    RETURN          reduce using rule 92 (f -> MAS g .)
    FUNCTION        reduce using rule 92 (f -> MAS g .)
    TOSTRING        reduce using rule 92 (f -> MAS g .)
    ENTERO          reduce using rule 92 (f -> MAS g .)
    DECIMAL         reduce using rule 92 (f -> MAS g .)
    CADENA          reduce using rule 92 (f -> MAS g .)
    TRUE            reduce using rule 92 (f -> MAS g .)
    FALSE           reduce using rule 92 (f -> MAS g .)
    L_PAREN         reduce using rule 92 (f -> MAS g .)
    L_CORCHETE      reduce using rule 92 (f -> MAS g .)
    L_LLAVE         reduce using rule 92 (f -> MAS g .)
    NOT             reduce using rule 92 (f -> MAS g .)
    $end            reduce using rule 92 (f -> MAS g .)
    R_PAREN         reduce using rule 92 (f -> MAS g .)
    R_LLAVE         reduce using rule 92 (f -> MAS g .)
    R_CORCHETE      reduce using rule 92 (f -> MAS g .)
    COMA            reduce using rule 92 (f -> MAS g .)
    TIMES           shift and go to state 113
    DIVIDE          shift and go to state 114
    MOD             shift and go to state 115


state 101

    (91) f -> MENOS g .
    (94) g -> g . TIMES h
    (95) g -> g . DIVIDE h
    (96) g -> g . MOD h

    MAS             reduce using rule 91 (f -> MENOS g .)
    MENOS           reduce using rule 91 (f -> MENOS g .)
    DISTINTO_QUE    reduce using rule 91 (f -> MENOS g .)
    MENOR_QUE       reduce using rule 91 (f -> MENOS g .)
    MENOR_IGUAL_QUE reduce using rule 91 (f -> MENOS g .)
    MAYOR_QUE       reduce using rule 91 (f -> MENOS g .)
    MAYOR_IGUAL_QUE reduce using rule 91 (f -> MENOS g .)
    TRIPLE_IGUAL    reduce using rule 91 (f -> MENOS g .)
    AND             reduce using rule 91 (f -> MENOS g .)
    OR              reduce using rule 91 (f -> MENOS g .)
    SEMI_COLON      reduce using rule 91 (f -> MENOS g .)
    CONSOLE         reduce using rule 91 (f -> MENOS g .)
    LET             reduce using rule 91 (f -> MENOS g .)
    LITERAL         reduce using rule 91 (f -> MENOS g .)
    IF              reduce using rule 91 (f -> MENOS g .)
    WHILE           reduce using rule 91 (f -> MENOS g .)
    FOR             reduce using rule 91 (f -> MENOS g .)
    INTERFACE       reduce using rule 91 (f -> MENOS g .)
    CONTINUE        reduce using rule 91 (f -> MENOS g .)
    BREAK           reduce using rule 91 (f -> MENOS g .)
    RETURN          reduce using rule 91 (f -> MENOS g .)
    FUNCTION        reduce using rule 91 (f -> MENOS g .)
    TOSTRING        reduce using rule 91 (f -> MENOS g .)
    ENTERO          reduce using rule 91 (f -> MENOS g .)
    DECIMAL         reduce using rule 91 (f -> MENOS g .)
    CADENA          reduce using rule 91 (f -> MENOS g .)
    TRUE            reduce using rule 91 (f -> MENOS g .)
    FALSE           reduce using rule 91 (f -> MENOS g .)
    L_PAREN         reduce using rule 91 (f -> MENOS g .)
    L_CORCHETE      reduce using rule 91 (f -> MENOS g .)
    L_LLAVE         reduce using rule 91 (f -> MENOS g .)
    NOT             reduce using rule 91 (f -> MENOS g .)
    $end            reduce using rule 91 (f -> MENOS g .)
    R_PAREN         reduce using rule 91 (f -> MENOS g .)
    R_LLAVE         reduce using rule 91 (f -> MENOS g .)
    R_CORCHETE      reduce using rule 91 (f -> MENOS g .)
    COMA            reduce using rule 91 (f -> MENOS g .)
    TIMES           shift and go to state 113
    DIVIDE          shift and go to state 114
    MOD             shift and go to state 115


state 102

    (122) array_pro -> L_CORCHETE values . R_CORCHETE
    (32) values -> values . COMA a

    R_CORCHETE      shift and go to state 157
    COMA            shift and go to state 158


state 103

    (33) values -> a .
    (75) a -> a . OR b

    R_CORCHETE      reduce using rule 33 (values -> a .)
    COMA            reduce using rule 33 (values -> a .)
    R_PAREN         reduce using rule 33 (values -> a .)
    OR              shift and go to state 73


state 104

    (79) c -> NOT d .
    (81) d -> d . DISTINTO_QUE e
    (82) d -> d . MENOR_QUE e
    (83) d -> d . MENOR_IGUAL_QUE e
    (84) d -> d . MAYOR_QUE e
    (85) d -> d . MAYOR_IGUAL_QUE e
    (86) d -> d . TRIPLE_IGUAL e

    AND             reduce using rule 79 (c -> NOT d .)
    OR              reduce using rule 79 (c -> NOT d .)
    SEMI_COLON      reduce using rule 79 (c -> NOT d .)
    CONSOLE         reduce using rule 79 (c -> NOT d .)
    LET             reduce using rule 79 (c -> NOT d .)
    LITERAL         reduce using rule 79 (c -> NOT d .)
    IF              reduce using rule 79 (c -> NOT d .)
    WHILE           reduce using rule 79 (c -> NOT d .)
    FOR             reduce using rule 79 (c -> NOT d .)
    INTERFACE       reduce using rule 79 (c -> NOT d .)
    CONTINUE        reduce using rule 79 (c -> NOT d .)
    BREAK           reduce using rule 79 (c -> NOT d .)
    RETURN          reduce using rule 79 (c -> NOT d .)
    FUNCTION        reduce using rule 79 (c -> NOT d .)
    TOSTRING        reduce using rule 79 (c -> NOT d .)
    ENTERO          reduce using rule 79 (c -> NOT d .)
    DECIMAL         reduce using rule 79 (c -> NOT d .)
    CADENA          reduce using rule 79 (c -> NOT d .)
    TRUE            reduce using rule 79 (c -> NOT d .)
    FALSE           reduce using rule 79 (c -> NOT d .)
    L_PAREN         reduce using rule 79 (c -> NOT d .)
    L_CORCHETE      reduce using rule 79 (c -> NOT d .)
    L_LLAVE         reduce using rule 79 (c -> NOT d .)
    NOT             reduce using rule 79 (c -> NOT d .)
    MENOS           reduce using rule 79 (c -> NOT d .)
    MAS             reduce using rule 79 (c -> NOT d .)
    $end            reduce using rule 79 (c -> NOT d .)
    R_PAREN         reduce using rule 79 (c -> NOT d .)
    R_LLAVE         reduce using rule 79 (c -> NOT d .)
    R_CORCHETE      reduce using rule 79 (c -> NOT d .)
    COMA            reduce using rule 79 (c -> NOT d .)
    DISTINTO_QUE    shift and go to state 105
    MENOR_QUE       shift and go to state 106
    MENOR_IGUAL_QUE shift and go to state 107
    MAYOR_QUE       shift and go to state 108
    MAYOR_IGUAL_QUE shift and go to state 109
    TRIPLE_IGUAL    shift and go to state 110


state 105

    (81) d -> d DISTINTO_QUE . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    e                              shift and go to state 159
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 106

    (82) d -> d MENOR_QUE . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    e                              shift and go to state 160
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 107

    (83) d -> d MENOR_IGUAL_QUE . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    e                              shift and go to state 161
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 108

    (84) d -> d MAYOR_QUE . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    e                              shift and go to state 162
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 109

    (85) d -> d MAYOR_IGUAL_QUE . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    e                              shift and go to state 163
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 110

    (86) d -> d TRIPLE_IGUAL . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    e                              shift and go to state 164
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 111

    (88) e -> e MAS . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    f                              shift and go to state 165
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 112

    (89) e -> e MENOS . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    f                              shift and go to state 166
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 113

    (94) g -> g TIMES . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    h                              shift and go to state 167
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 114

    (95) g -> g DIVIDE . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    h                              shift and go to state 168
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 115

    (96) g -> g MOD . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    h                              shift and go to state 169
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 116

    (98) h -> h POTENCIA . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    i                              shift and go to state 170
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 117

    (75) a -> a OR b .
    (77) b -> b . AND c

    OR              reduce using rule 75 (a -> a OR b .)
    SEMI_COLON      reduce using rule 75 (a -> a OR b .)
    CONSOLE         reduce using rule 75 (a -> a OR b .)
    LET             reduce using rule 75 (a -> a OR b .)
    LITERAL         reduce using rule 75 (a -> a OR b .)
    IF              reduce using rule 75 (a -> a OR b .)
    WHILE           reduce using rule 75 (a -> a OR b .)
    FOR             reduce using rule 75 (a -> a OR b .)
    INTERFACE       reduce using rule 75 (a -> a OR b .)
    CONTINUE        reduce using rule 75 (a -> a OR b .)
    BREAK           reduce using rule 75 (a -> a OR b .)
    RETURN          reduce using rule 75 (a -> a OR b .)
    FUNCTION        reduce using rule 75 (a -> a OR b .)
    TOSTRING        reduce using rule 75 (a -> a OR b .)
    ENTERO          reduce using rule 75 (a -> a OR b .)
    DECIMAL         reduce using rule 75 (a -> a OR b .)
    CADENA          reduce using rule 75 (a -> a OR b .)
    TRUE            reduce using rule 75 (a -> a OR b .)
    FALSE           reduce using rule 75 (a -> a OR b .)
    L_PAREN         reduce using rule 75 (a -> a OR b .)
    L_CORCHETE      reduce using rule 75 (a -> a OR b .)
    L_LLAVE         reduce using rule 75 (a -> a OR b .)
    NOT             reduce using rule 75 (a -> a OR b .)
    MENOS           reduce using rule 75 (a -> a OR b .)
    MAS             reduce using rule 75 (a -> a OR b .)
    $end            reduce using rule 75 (a -> a OR b .)
    R_PAREN         reduce using rule 75 (a -> a OR b .)
    R_LLAVE         reduce using rule 75 (a -> a OR b .)
    R_CORCHETE      reduce using rule 75 (a -> a OR b .)
    COMA            reduce using rule 75 (a -> a OR b .)
    AND             shift and go to state 99


state 118

    (72) console_pro -> CONSOLE PUNTO LOG . L_PAREN expresion R_PAREN

    L_PAREN         shift and go to state 171


state 119

    (109) i -> L_PAREN a R_PAREN .

    PUNTO           reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    POTENCIA        reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    TIMES           reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    DIVIDE          reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    MOD             reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    MAS             reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    MENOS           reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    DISTINTO_QUE    reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    MENOR_QUE       reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    MENOR_IGUAL_QUE reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    MAYOR_QUE       reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    MAYOR_IGUAL_QUE reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    TRIPLE_IGUAL    reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    AND             reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    OR              reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    SEMI_COLON      reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    CONSOLE         reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    LET             reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    LITERAL         reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    IF              reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    WHILE           reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    FOR             reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    INTERFACE       reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    CONTINUE        reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    BREAK           reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    RETURN          reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    FUNCTION        reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    TOSTRING        reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    ENTERO          reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    DECIMAL         reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    CADENA          reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    TRUE            reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    FALSE           reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    L_PAREN         reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    L_CORCHETE      reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    L_LLAVE         reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    NOT             reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    $end            reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    R_PAREN         reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    R_LLAVE         reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    R_CORCHETE      reduce using rule 109 (i -> L_PAREN a R_PAREN .)
    COMA            reduce using rule 109 (i -> L_PAREN a R_PAREN .)


state 120

    (111) i -> i PUNTO . LITERAL
    (112) i -> i PUNTO . nativeFun L_PAREN expresion R_PAREN
    (113) i -> i PUNTO . nativeFun L_PAREN R_PAREN
    (124) nativeFun -> . TOSTRING
    (125) nativeFun -> . TOFIXED
    (126) nativeFun -> . TOEXPONENTIAL
    (127) nativeFun -> . TOLOWERCASE
    (128) nativeFun -> . TOUPPERCASE
    (129) nativeFun -> . SPLIT
    (130) nativeFun -> . CONCAT
    (131) nativeFun -> . LENGTH
    (132) nativeFun -> . PUSH

    LITERAL         shift and go to state 172
    TOSTRING        shift and go to state 135
    TOFIXED         shift and go to state 136
    TOEXPONENTIAL   shift and go to state 137
    TOLOWERCASE     shift and go to state 138
    TOUPPERCASE     shift and go to state 139
    SPLIT           shift and go to state 140
    CONCAT          shift and go to state 141
    LENGTH          shift and go to state 142
    PUSH            shift and go to state 143

    nativeFun                      shift and go to state 134

state 121

    (114) array_val_pro -> LITERAL dimensions .
    (115) dimensions -> dimensions . L_CORCHETE a R_CORCHETE

  ! shift/reduce conflict for L_CORCHETE resolved as shift
    PUNTO           reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    POTENCIA        reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    TIMES           reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    DIVIDE          reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    MOD             reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    MAS             reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    MENOS           reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    DISTINTO_QUE    reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    MENOR_QUE       reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    MENOR_IGUAL_QUE reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    MAYOR_QUE       reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    MAYOR_IGUAL_QUE reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    TRIPLE_IGUAL    reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    AND             reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    R_PAREN         reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    OR              reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    SEMI_COLON      reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    CONSOLE         reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    LET             reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    LITERAL         reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    IF              reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    WHILE           reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    FOR             reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    INTERFACE       reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    CONTINUE        reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    BREAK           reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    RETURN          reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    FUNCTION        reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    TOSTRING        reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    ENTERO          reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    DECIMAL         reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    CADENA          reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    TRUE            reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    FALSE           reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    L_PAREN         reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    L_LLAVE         reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    NOT             reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    $end            reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    R_LLAVE         reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    R_CORCHETE      reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    COMA            reduce using rule 114 (array_val_pro -> LITERAL dimensions .)
    L_CORCHETE      shift and go to state 127

  ! L_CORCHETE      [ reduce using rule 114 (array_val_pro -> LITERAL dimensions .) ]


state 122

    (49) declaracion_list -> declaracion_list COMA . assignacion_instruction
    (51) assignacion_instruction -> . LITERAL COLON type IGUAL a
    (52) assignacion_instruction -> . LITERAL COLON type
    (53) assignacion_instruction -> . LITERAL IGUAL a
    (54) assignacion_instruction -> . LITERAL

    LITERAL         shift and go to state 82

    assignacion_instruction        shift and go to state 173

state 123

    (51) assignacion_instruction -> LITERAL COLON . type IGUAL a
    (52) assignacion_instruction -> LITERAL COLON . type
    (55) type -> . NUMBER
    (56) type -> . STRING
    (57) type -> . BOOLEAN
    (58) type -> . ANY
    (59) type -> . LITERAL
    (60) type -> . NULL

    NUMBER          shift and go to state 176
    STRING          shift and go to state 177
    BOOLEAN         shift and go to state 178
    ANY             shift and go to state 179
    LITERAL         shift and go to state 174
    NULL            shift and go to state 180

    type                           shift and go to state 175

state 124

    (53) assignacion_instruction -> LITERAL IGUAL . a
    (75) a -> . a OR b
    (76) a -> . b
    (77) b -> . b AND c
    (78) b -> . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    a                              shift and go to state 181
    b                              shift and go to state 36
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 125

    (61) assig_pro -> LITERAL IGUAL a .
    (75) a -> a . OR b

    SEMI_COLON      reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    CONSOLE         reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    LET             reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    LITERAL         reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    IF              reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    WHILE           reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    FOR             reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    INTERFACE       reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    CONTINUE        reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    BREAK           reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    RETURN          reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    FUNCTION        reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    TOSTRING        reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    ENTERO          reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    DECIMAL         reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    CADENA          reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    TRUE            reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    FALSE           reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    L_PAREN         reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    L_CORCHETE      reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    L_LLAVE         reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    NOT             reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    MENOS           reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    MAS             reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    $end            reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    R_LLAVE         reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    R_PAREN         reduce using rule 61 (assig_pro -> LITERAL IGUAL a .)
    OR              shift and go to state 73


state 126

    (123) array_assign_pro -> LITERAL dimensions IGUAL . a
    (75) a -> . a OR b
    (76) a -> . b
    (77) b -> . b AND c
    (78) b -> . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    a                              shift and go to state 182
    b                              shift and go to state 36
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 127

    (115) dimensions -> dimensions L_CORCHETE . a R_CORCHETE
    (75) a -> . a OR b
    (76) a -> . b
    (77) b -> . b AND c
    (78) b -> . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    a                              shift and go to state 183
    b                              shift and go to state 36
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 128

    (29) call_function_pro -> LITERAL L_PAREN values . R_PAREN
    (32) values -> values . COMA a

    R_PAREN         shift and go to state 184
    COMA            shift and go to state 158


state 129

    (30) call_function_pro -> LITERAL L_PAREN R_PAREN .

    SEMI_COLON      reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    CONSOLE         reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    LET             reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    LITERAL         reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    IF              reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    WHILE           reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    FOR             reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    INTERFACE       reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    CONTINUE        reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    BREAK           reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    RETURN          reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    FUNCTION        reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    TOSTRING        reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    ENTERO          reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    DECIMAL         reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    CADENA          reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    TRUE            reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    FALSE           reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    L_PAREN         reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    L_CORCHETE      reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    L_LLAVE         reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    NOT             reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    MENOS           reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    MAS             reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    $end            reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    PUNTO           reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    POTENCIA        reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    TIMES           reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    DIVIDE          reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    MOD             reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    DISTINTO_QUE    reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    MENOR_QUE       reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    MENOR_IGUAL_QUE reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    MAYOR_QUE       reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    MAYOR_IGUAL_QUE reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    TRIPLE_IGUAL    reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    AND             reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    OR              reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    R_PAREN         reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    R_LLAVE         reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    R_CORCHETE      reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)
    COMA            reduce using rule 30 (call_function_pro -> LITERAL L_PAREN R_PAREN .)


state 130

    (117) sumadores -> LITERAL MAS MAS .

    SEMI_COLON      reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    CONSOLE         reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    LET             reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    LITERAL         reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    IF              reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    WHILE           reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    FOR             reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    INTERFACE       reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    CONTINUE        reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    BREAK           reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    RETURN          reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    FUNCTION        reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    TOSTRING        reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    ENTERO          reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    DECIMAL         reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    CADENA          reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    TRUE            reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    FALSE           reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    L_PAREN         reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    L_CORCHETE      reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    L_LLAVE         reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    NOT             reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    MENOS           reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    MAS             reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    $end            reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    R_LLAVE         reduce using rule 117 (sumadores -> LITERAL MAS MAS .)
    R_PAREN         reduce using rule 117 (sumadores -> LITERAL MAS MAS .)


state 131

    (118) sumadores -> LITERAL MENOS MENOS .

    SEMI_COLON      reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    CONSOLE         reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    LET             reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    LITERAL         reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    IF              reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    WHILE           reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    FOR             reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    INTERFACE       reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    CONTINUE        reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    BREAK           reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    RETURN          reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    FUNCTION        reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    TOSTRING        reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    ENTERO          reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    DECIMAL         reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    CADENA          reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    TRUE            reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    FALSE           reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    L_PAREN         reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    L_CORCHETE      reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    L_LLAVE         reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    NOT             reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    MENOS           reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    MAS             reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    $end            reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    R_LLAVE         reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)
    R_PAREN         reduce using rule 118 (sumadores -> LITERAL MENOS MENOS .)


state 132

    (116) dimensions -> L_CORCHETE a . R_CORCHETE
    (75) a -> a . OR b

    R_CORCHETE      shift and go to state 185
    OR              shift and go to state 73


state 133

    (47) interface_assign_pro -> i PUNTO LITERAL . IGUAL a
    (111) i -> i PUNTO LITERAL .

    IGUAL           shift and go to state 186
    PUNTO           reduce using rule 111 (i -> i PUNTO LITERAL .)
    POTENCIA        reduce using rule 111 (i -> i PUNTO LITERAL .)
    TIMES           reduce using rule 111 (i -> i PUNTO LITERAL .)
    DIVIDE          reduce using rule 111 (i -> i PUNTO LITERAL .)
    MOD             reduce using rule 111 (i -> i PUNTO LITERAL .)
    MAS             reduce using rule 111 (i -> i PUNTO LITERAL .)
    MENOS           reduce using rule 111 (i -> i PUNTO LITERAL .)
    DISTINTO_QUE    reduce using rule 111 (i -> i PUNTO LITERAL .)
    MENOR_QUE       reduce using rule 111 (i -> i PUNTO LITERAL .)
    MENOR_IGUAL_QUE reduce using rule 111 (i -> i PUNTO LITERAL .)
    MAYOR_QUE       reduce using rule 111 (i -> i PUNTO LITERAL .)
    MAYOR_IGUAL_QUE reduce using rule 111 (i -> i PUNTO LITERAL .)
    TRIPLE_IGUAL    reduce using rule 111 (i -> i PUNTO LITERAL .)
    AND             reduce using rule 111 (i -> i PUNTO LITERAL .)
    OR              reduce using rule 111 (i -> i PUNTO LITERAL .)
    SEMI_COLON      reduce using rule 111 (i -> i PUNTO LITERAL .)
    CONSOLE         reduce using rule 111 (i -> i PUNTO LITERAL .)
    LET             reduce using rule 111 (i -> i PUNTO LITERAL .)
    LITERAL         reduce using rule 111 (i -> i PUNTO LITERAL .)
    IF              reduce using rule 111 (i -> i PUNTO LITERAL .)
    WHILE           reduce using rule 111 (i -> i PUNTO LITERAL .)
    FOR             reduce using rule 111 (i -> i PUNTO LITERAL .)
    INTERFACE       reduce using rule 111 (i -> i PUNTO LITERAL .)
    CONTINUE        reduce using rule 111 (i -> i PUNTO LITERAL .)
    BREAK           reduce using rule 111 (i -> i PUNTO LITERAL .)
    RETURN          reduce using rule 111 (i -> i PUNTO LITERAL .)
    FUNCTION        reduce using rule 111 (i -> i PUNTO LITERAL .)
    TOSTRING        reduce using rule 111 (i -> i PUNTO LITERAL .)
    ENTERO          reduce using rule 111 (i -> i PUNTO LITERAL .)
    DECIMAL         reduce using rule 111 (i -> i PUNTO LITERAL .)
    CADENA          reduce using rule 111 (i -> i PUNTO LITERAL .)
    TRUE            reduce using rule 111 (i -> i PUNTO LITERAL .)
    FALSE           reduce using rule 111 (i -> i PUNTO LITERAL .)
    L_PAREN         reduce using rule 111 (i -> i PUNTO LITERAL .)
    L_CORCHETE      reduce using rule 111 (i -> i PUNTO LITERAL .)
    L_LLAVE         reduce using rule 111 (i -> i PUNTO LITERAL .)
    NOT             reduce using rule 111 (i -> i PUNTO LITERAL .)
    $end            reduce using rule 111 (i -> i PUNTO LITERAL .)
    R_LLAVE         reduce using rule 111 (i -> i PUNTO LITERAL .)


state 134

    (112) i -> i PUNTO nativeFun . L_PAREN expresion R_PAREN
    (113) i -> i PUNTO nativeFun . L_PAREN R_PAREN

    L_PAREN         shift and go to state 187


state 135

    (124) nativeFun -> TOSTRING .

    L_PAREN         reduce using rule 124 (nativeFun -> TOSTRING .)


state 136

    (125) nativeFun -> TOFIXED .

    L_PAREN         reduce using rule 125 (nativeFun -> TOFIXED .)


state 137

    (126) nativeFun -> TOEXPONENTIAL .

    L_PAREN         reduce using rule 126 (nativeFun -> TOEXPONENTIAL .)


state 138

    (127) nativeFun -> TOLOWERCASE .

    L_PAREN         reduce using rule 127 (nativeFun -> TOLOWERCASE .)


state 139

    (128) nativeFun -> TOUPPERCASE .

    L_PAREN         reduce using rule 128 (nativeFun -> TOUPPERCASE .)


state 140

    (129) nativeFun -> SPLIT .

    L_PAREN         reduce using rule 129 (nativeFun -> SPLIT .)


state 141

    (130) nativeFun -> CONCAT .

    L_PAREN         reduce using rule 130 (nativeFun -> CONCAT .)


state 142

    (131) nativeFun -> LENGTH .

    L_PAREN         reduce using rule 131 (nativeFun -> LENGTH .)


state 143

    (132) nativeFun -> PUSH .

    L_PAREN         reduce using rule 132 (nativeFun -> PUSH .)


state 144

    (62) if_pro -> IF L_PAREN a . R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (75) a -> a . OR b

    R_PAREN         shift and go to state 188
    OR              shift and go to state 73


state 145

    (119) interface_assi -> L_LLAVE atributos_assi R_LLAVE .

    PUNTO           reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    POTENCIA        reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    TIMES           reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    DIVIDE          reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MOD             reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MAS             reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MENOS           reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    DISTINTO_QUE    reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MENOR_QUE       reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MENOR_IGUAL_QUE reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MAYOR_QUE       reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    MAYOR_IGUAL_QUE reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    TRIPLE_IGUAL    reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    AND             reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    OR              reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    SEMI_COLON      reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    CONSOLE         reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    LET             reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    LITERAL         reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    IF              reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    WHILE           reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    FOR             reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    INTERFACE       reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    CONTINUE        reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    BREAK           reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    RETURN          reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    FUNCTION        reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    TOSTRING        reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    ENTERO          reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    DECIMAL         reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    CADENA          reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    TRUE            reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    FALSE           reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    L_PAREN         reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    L_CORCHETE      reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    L_LLAVE         reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    NOT             reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    $end            reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    R_PAREN         reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    R_LLAVE         reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    R_CORCHETE      reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)
    COMA            reduce using rule 119 (interface_assi -> L_LLAVE atributos_assi R_LLAVE .)


state 146

    (120) atributos_assi -> atributos_assi COMA . LITERAL COLON a

    LITERAL         shift and go to state 189


state 147

    (121) atributos_assi -> LITERAL COLON . a
    (75) a -> . a OR b
    (76) a -> . b
    (77) b -> . b AND c
    (78) b -> . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    a                              shift and go to state 190
    b                              shift and go to state 36
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 148

    (66) while_pro -> WHILE L_PAREN a . R_PAREN L_LLAVE instrucciones R_LLAVE
    (75) a -> a . OR b

    R_PAREN         shift and go to state 191
    OR              shift and go to state 73


state 149

    (67) for_pro -> FOR L_PAREN declaration_instruction . SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE

    SEMI_COLON      shift and go to state 192


state 150

    (68) for_pro -> FOR L_PAREN assig_pro . SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE

    SEMI_COLON      shift and go to state 193


state 151

    (71) for_each_pro -> FOR L_PAREN LET . LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (48) declaration_instruction -> LET . declaracion_list
    (49) declaracion_list -> . declaracion_list COMA assignacion_instruction
    (50) declaracion_list -> . assignacion_instruction
    (51) assignacion_instruction -> . LITERAL COLON type IGUAL a
    (52) assignacion_instruction -> . LITERAL COLON type
    (53) assignacion_instruction -> . LITERAL IGUAL a
    (54) assignacion_instruction -> . LITERAL

    LITERAL         shift and go to state 194

    declaracion_list               shift and go to state 80
    assignacion_instruction        shift and go to state 81

state 152

    (61) assig_pro -> LITERAL . IGUAL a

    IGUAL           shift and go to state 83


state 153

    (42) interface_pro -> INTERFACE LITERAL L_LLAVE . interface_atributos R_LLAVE
    (43) interface_atributos -> . interface_atributos interface_atributo sc
    (44) interface_atributos -> .

    R_LLAVE         reduce using rule 44 (interface_atributos -> .)
    LITERAL         reduce using rule 44 (interface_atributos -> .)

    interface_atributos            shift and go to state 195

state 154

    (23) function_pro -> FUNCTION LITERAL L_PAREN . parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> FUNCTION LITERAL L_PAREN . R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> FUNCTION LITERAL L_PAREN . parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> FUNCTION LITERAL L_PAREN . parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> FUNCTION LITERAL L_PAREN . R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> FUNCTION LITERAL L_PAREN . R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (34) parameters_pro -> . parameters_pro COMA parameter_pro
    (35) parameters_pro -> . parameter_pro
    (36) parameter_pro -> . LITERAL COLON type
    (37) parameter_pro -> . LITERAL

    R_PAREN         shift and go to state 198
    LITERAL         shift and go to state 196

    parameters_pro                 shift and go to state 197
    parameter_pro                  shift and go to state 199

state 155

    (31) call_function_pro -> TOSTRING L_PAREN values . R_PAREN
    (32) values -> values . COMA a

    R_PAREN         shift and go to state 200
    COMA            shift and go to state 158


state 156

    (77) b -> b AND c .

    AND             reduce using rule 77 (b -> b AND c .)
    OR              reduce using rule 77 (b -> b AND c .)
    SEMI_COLON      reduce using rule 77 (b -> b AND c .)
    CONSOLE         reduce using rule 77 (b -> b AND c .)
    LET             reduce using rule 77 (b -> b AND c .)
    LITERAL         reduce using rule 77 (b -> b AND c .)
    IF              reduce using rule 77 (b -> b AND c .)
    WHILE           reduce using rule 77 (b -> b AND c .)
    FOR             reduce using rule 77 (b -> b AND c .)
    INTERFACE       reduce using rule 77 (b -> b AND c .)
    CONTINUE        reduce using rule 77 (b -> b AND c .)
    BREAK           reduce using rule 77 (b -> b AND c .)
    RETURN          reduce using rule 77 (b -> b AND c .)
    FUNCTION        reduce using rule 77 (b -> b AND c .)
    TOSTRING        reduce using rule 77 (b -> b AND c .)
    ENTERO          reduce using rule 77 (b -> b AND c .)
    DECIMAL         reduce using rule 77 (b -> b AND c .)
    CADENA          reduce using rule 77 (b -> b AND c .)
    TRUE            reduce using rule 77 (b -> b AND c .)
    FALSE           reduce using rule 77 (b -> b AND c .)
    L_PAREN         reduce using rule 77 (b -> b AND c .)
    L_CORCHETE      reduce using rule 77 (b -> b AND c .)
    L_LLAVE         reduce using rule 77 (b -> b AND c .)
    NOT             reduce using rule 77 (b -> b AND c .)
    MENOS           reduce using rule 77 (b -> b AND c .)
    MAS             reduce using rule 77 (b -> b AND c .)
    $end            reduce using rule 77 (b -> b AND c .)
    R_PAREN         reduce using rule 77 (b -> b AND c .)
    R_LLAVE         reduce using rule 77 (b -> b AND c .)
    R_CORCHETE      reduce using rule 77 (b -> b AND c .)
    COMA            reduce using rule 77 (b -> b AND c .)


state 157

    (122) array_pro -> L_CORCHETE values R_CORCHETE .

    PUNTO           reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    POTENCIA        reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    TIMES           reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    DIVIDE          reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    MOD             reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    MAS             reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    MENOS           reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    DISTINTO_QUE    reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    MENOR_QUE       reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    MENOR_IGUAL_QUE reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    MAYOR_QUE       reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    MAYOR_IGUAL_QUE reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    TRIPLE_IGUAL    reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    AND             reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    OR              reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    SEMI_COLON      reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    CONSOLE         reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    LET             reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    LITERAL         reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    IF              reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    WHILE           reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    FOR             reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    INTERFACE       reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    CONTINUE        reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    BREAK           reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    RETURN          reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    FUNCTION        reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    TOSTRING        reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    ENTERO          reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    DECIMAL         reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    CADENA          reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    TRUE            reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    FALSE           reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    L_PAREN         reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    L_CORCHETE      reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    L_LLAVE         reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    NOT             reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    $end            reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    R_PAREN         reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    R_LLAVE         reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    R_CORCHETE      reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)
    COMA            reduce using rule 122 (array_pro -> L_CORCHETE values R_CORCHETE .)


state 158

    (32) values -> values COMA . a
    (75) a -> . a OR b
    (76) a -> . b
    (77) b -> . b AND c
    (78) b -> . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    a                              shift and go to state 201
    b                              shift and go to state 36
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 159

    (81) d -> d DISTINTO_QUE e .
    (88) e -> e . MAS f
    (89) e -> e . MENOS f

  ! shift/reduce conflict for MAS resolved as shift
  ! shift/reduce conflict for MENOS resolved as shift
    DISTINTO_QUE    reduce using rule 81 (d -> d DISTINTO_QUE e .)
    MENOR_QUE       reduce using rule 81 (d -> d DISTINTO_QUE e .)
    MENOR_IGUAL_QUE reduce using rule 81 (d -> d DISTINTO_QUE e .)
    MAYOR_QUE       reduce using rule 81 (d -> d DISTINTO_QUE e .)
    MAYOR_IGUAL_QUE reduce using rule 81 (d -> d DISTINTO_QUE e .)
    TRIPLE_IGUAL    reduce using rule 81 (d -> d DISTINTO_QUE e .)
    AND             reduce using rule 81 (d -> d DISTINTO_QUE e .)
    OR              reduce using rule 81 (d -> d DISTINTO_QUE e .)
    SEMI_COLON      reduce using rule 81 (d -> d DISTINTO_QUE e .)
    CONSOLE         reduce using rule 81 (d -> d DISTINTO_QUE e .)
    LET             reduce using rule 81 (d -> d DISTINTO_QUE e .)
    LITERAL         reduce using rule 81 (d -> d DISTINTO_QUE e .)
    IF              reduce using rule 81 (d -> d DISTINTO_QUE e .)
    WHILE           reduce using rule 81 (d -> d DISTINTO_QUE e .)
    FOR             reduce using rule 81 (d -> d DISTINTO_QUE e .)
    INTERFACE       reduce using rule 81 (d -> d DISTINTO_QUE e .)
    CONTINUE        reduce using rule 81 (d -> d DISTINTO_QUE e .)
    BREAK           reduce using rule 81 (d -> d DISTINTO_QUE e .)
    RETURN          reduce using rule 81 (d -> d DISTINTO_QUE e .)
    FUNCTION        reduce using rule 81 (d -> d DISTINTO_QUE e .)
    TOSTRING        reduce using rule 81 (d -> d DISTINTO_QUE e .)
    ENTERO          reduce using rule 81 (d -> d DISTINTO_QUE e .)
    DECIMAL         reduce using rule 81 (d -> d DISTINTO_QUE e .)
    CADENA          reduce using rule 81 (d -> d DISTINTO_QUE e .)
    TRUE            reduce using rule 81 (d -> d DISTINTO_QUE e .)
    FALSE           reduce using rule 81 (d -> d DISTINTO_QUE e .)
    L_PAREN         reduce using rule 81 (d -> d DISTINTO_QUE e .)
    L_CORCHETE      reduce using rule 81 (d -> d DISTINTO_QUE e .)
    L_LLAVE         reduce using rule 81 (d -> d DISTINTO_QUE e .)
    NOT             reduce using rule 81 (d -> d DISTINTO_QUE e .)
    $end            reduce using rule 81 (d -> d DISTINTO_QUE e .)
    R_PAREN         reduce using rule 81 (d -> d DISTINTO_QUE e .)
    R_LLAVE         reduce using rule 81 (d -> d DISTINTO_QUE e .)
    R_CORCHETE      reduce using rule 81 (d -> d DISTINTO_QUE e .)
    COMA            reduce using rule 81 (d -> d DISTINTO_QUE e .)
    MAS             shift and go to state 111
    MENOS           shift and go to state 112

  ! MENOS           [ reduce using rule 81 (d -> d DISTINTO_QUE e .) ]
  ! MAS             [ reduce using rule 81 (d -> d DISTINTO_QUE e .) ]


state 160

    (82) d -> d MENOR_QUE e .
    (88) e -> e . MAS f
    (89) e -> e . MENOS f

  ! shift/reduce conflict for MAS resolved as shift
  ! shift/reduce conflict for MENOS resolved as shift
    DISTINTO_QUE    reduce using rule 82 (d -> d MENOR_QUE e .)
    MENOR_QUE       reduce using rule 82 (d -> d MENOR_QUE e .)
    MENOR_IGUAL_QUE reduce using rule 82 (d -> d MENOR_QUE e .)
    MAYOR_QUE       reduce using rule 82 (d -> d MENOR_QUE e .)
    MAYOR_IGUAL_QUE reduce using rule 82 (d -> d MENOR_QUE e .)
    TRIPLE_IGUAL    reduce using rule 82 (d -> d MENOR_QUE e .)
    AND             reduce using rule 82 (d -> d MENOR_QUE e .)
    OR              reduce using rule 82 (d -> d MENOR_QUE e .)
    SEMI_COLON      reduce using rule 82 (d -> d MENOR_QUE e .)
    CONSOLE         reduce using rule 82 (d -> d MENOR_QUE e .)
    LET             reduce using rule 82 (d -> d MENOR_QUE e .)
    LITERAL         reduce using rule 82 (d -> d MENOR_QUE e .)
    IF              reduce using rule 82 (d -> d MENOR_QUE e .)
    WHILE           reduce using rule 82 (d -> d MENOR_QUE e .)
    FOR             reduce using rule 82 (d -> d MENOR_QUE e .)
    INTERFACE       reduce using rule 82 (d -> d MENOR_QUE e .)
    CONTINUE        reduce using rule 82 (d -> d MENOR_QUE e .)
    BREAK           reduce using rule 82 (d -> d MENOR_QUE e .)
    RETURN          reduce using rule 82 (d -> d MENOR_QUE e .)
    FUNCTION        reduce using rule 82 (d -> d MENOR_QUE e .)
    TOSTRING        reduce using rule 82 (d -> d MENOR_QUE e .)
    ENTERO          reduce using rule 82 (d -> d MENOR_QUE e .)
    DECIMAL         reduce using rule 82 (d -> d MENOR_QUE e .)
    CADENA          reduce using rule 82 (d -> d MENOR_QUE e .)
    TRUE            reduce using rule 82 (d -> d MENOR_QUE e .)
    FALSE           reduce using rule 82 (d -> d MENOR_QUE e .)
    L_PAREN         reduce using rule 82 (d -> d MENOR_QUE e .)
    L_CORCHETE      reduce using rule 82 (d -> d MENOR_QUE e .)
    L_LLAVE         reduce using rule 82 (d -> d MENOR_QUE e .)
    NOT             reduce using rule 82 (d -> d MENOR_QUE e .)
    $end            reduce using rule 82 (d -> d MENOR_QUE e .)
    R_PAREN         reduce using rule 82 (d -> d MENOR_QUE e .)
    R_LLAVE         reduce using rule 82 (d -> d MENOR_QUE e .)
    R_CORCHETE      reduce using rule 82 (d -> d MENOR_QUE e .)
    COMA            reduce using rule 82 (d -> d MENOR_QUE e .)
    MAS             shift and go to state 111
    MENOS           shift and go to state 112

  ! MENOS           [ reduce using rule 82 (d -> d MENOR_QUE e .) ]
  ! MAS             [ reduce using rule 82 (d -> d MENOR_QUE e .) ]


state 161

    (83) d -> d MENOR_IGUAL_QUE e .
    (88) e -> e . MAS f
    (89) e -> e . MENOS f

  ! shift/reduce conflict for MAS resolved as shift
  ! shift/reduce conflict for MENOS resolved as shift
    DISTINTO_QUE    reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    MENOR_QUE       reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    MENOR_IGUAL_QUE reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    MAYOR_QUE       reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    MAYOR_IGUAL_QUE reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    TRIPLE_IGUAL    reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    AND             reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    OR              reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    SEMI_COLON      reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    CONSOLE         reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    LET             reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    LITERAL         reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    IF              reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    WHILE           reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    FOR             reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    INTERFACE       reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    CONTINUE        reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    BREAK           reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    RETURN          reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    FUNCTION        reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    TOSTRING        reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    ENTERO          reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    DECIMAL         reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    CADENA          reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    TRUE            reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    FALSE           reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    L_PAREN         reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    L_CORCHETE      reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    L_LLAVE         reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    NOT             reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    $end            reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    R_PAREN         reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    R_LLAVE         reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    R_CORCHETE      reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    COMA            reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .)
    MAS             shift and go to state 111
    MENOS           shift and go to state 112

  ! MENOS           [ reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .) ]
  ! MAS             [ reduce using rule 83 (d -> d MENOR_IGUAL_QUE e .) ]


state 162

    (84) d -> d MAYOR_QUE e .
    (88) e -> e . MAS f
    (89) e -> e . MENOS f

  ! shift/reduce conflict for MAS resolved as shift
  ! shift/reduce conflict for MENOS resolved as shift
    DISTINTO_QUE    reduce using rule 84 (d -> d MAYOR_QUE e .)
    MENOR_QUE       reduce using rule 84 (d -> d MAYOR_QUE e .)
    MENOR_IGUAL_QUE reduce using rule 84 (d -> d MAYOR_QUE e .)
    MAYOR_QUE       reduce using rule 84 (d -> d MAYOR_QUE e .)
    MAYOR_IGUAL_QUE reduce using rule 84 (d -> d MAYOR_QUE e .)
    TRIPLE_IGUAL    reduce using rule 84 (d -> d MAYOR_QUE e .)
    AND             reduce using rule 84 (d -> d MAYOR_QUE e .)
    OR              reduce using rule 84 (d -> d MAYOR_QUE e .)
    SEMI_COLON      reduce using rule 84 (d -> d MAYOR_QUE e .)
    CONSOLE         reduce using rule 84 (d -> d MAYOR_QUE e .)
    LET             reduce using rule 84 (d -> d MAYOR_QUE e .)
    LITERAL         reduce using rule 84 (d -> d MAYOR_QUE e .)
    IF              reduce using rule 84 (d -> d MAYOR_QUE e .)
    WHILE           reduce using rule 84 (d -> d MAYOR_QUE e .)
    FOR             reduce using rule 84 (d -> d MAYOR_QUE e .)
    INTERFACE       reduce using rule 84 (d -> d MAYOR_QUE e .)
    CONTINUE        reduce using rule 84 (d -> d MAYOR_QUE e .)
    BREAK           reduce using rule 84 (d -> d MAYOR_QUE e .)
    RETURN          reduce using rule 84 (d -> d MAYOR_QUE e .)
    FUNCTION        reduce using rule 84 (d -> d MAYOR_QUE e .)
    TOSTRING        reduce using rule 84 (d -> d MAYOR_QUE e .)
    ENTERO          reduce using rule 84 (d -> d MAYOR_QUE e .)
    DECIMAL         reduce using rule 84 (d -> d MAYOR_QUE e .)
    CADENA          reduce using rule 84 (d -> d MAYOR_QUE e .)
    TRUE            reduce using rule 84 (d -> d MAYOR_QUE e .)
    FALSE           reduce using rule 84 (d -> d MAYOR_QUE e .)
    L_PAREN         reduce using rule 84 (d -> d MAYOR_QUE e .)
    L_CORCHETE      reduce using rule 84 (d -> d MAYOR_QUE e .)
    L_LLAVE         reduce using rule 84 (d -> d MAYOR_QUE e .)
    NOT             reduce using rule 84 (d -> d MAYOR_QUE e .)
    $end            reduce using rule 84 (d -> d MAYOR_QUE e .)
    R_PAREN         reduce using rule 84 (d -> d MAYOR_QUE e .)
    R_LLAVE         reduce using rule 84 (d -> d MAYOR_QUE e .)
    R_CORCHETE      reduce using rule 84 (d -> d MAYOR_QUE e .)
    COMA            reduce using rule 84 (d -> d MAYOR_QUE e .)
    MAS             shift and go to state 111
    MENOS           shift and go to state 112

  ! MENOS           [ reduce using rule 84 (d -> d MAYOR_QUE e .) ]
  ! MAS             [ reduce using rule 84 (d -> d MAYOR_QUE e .) ]


state 163

    (85) d -> d MAYOR_IGUAL_QUE e .
    (88) e -> e . MAS f
    (89) e -> e . MENOS f

  ! shift/reduce conflict for MAS resolved as shift
  ! shift/reduce conflict for MENOS resolved as shift
    DISTINTO_QUE    reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    MENOR_QUE       reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    MENOR_IGUAL_QUE reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    MAYOR_QUE       reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    MAYOR_IGUAL_QUE reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    TRIPLE_IGUAL    reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    AND             reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    OR              reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    SEMI_COLON      reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    CONSOLE         reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    LET             reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    LITERAL         reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    IF              reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    WHILE           reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    FOR             reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    INTERFACE       reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    CONTINUE        reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    BREAK           reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    RETURN          reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    FUNCTION        reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    TOSTRING        reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    ENTERO          reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    DECIMAL         reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    CADENA          reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    TRUE            reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    FALSE           reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    L_PAREN         reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    L_CORCHETE      reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    L_LLAVE         reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    NOT             reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    $end            reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    R_PAREN         reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    R_LLAVE         reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    R_CORCHETE      reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    COMA            reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .)
    MAS             shift and go to state 111
    MENOS           shift and go to state 112

  ! MENOS           [ reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .) ]
  ! MAS             [ reduce using rule 85 (d -> d MAYOR_IGUAL_QUE e .) ]


state 164

    (86) d -> d TRIPLE_IGUAL e .
    (88) e -> e . MAS f
    (89) e -> e . MENOS f

  ! shift/reduce conflict for MAS resolved as shift
  ! shift/reduce conflict for MENOS resolved as shift
    DISTINTO_QUE    reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    MENOR_QUE       reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    MENOR_IGUAL_QUE reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    MAYOR_QUE       reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    MAYOR_IGUAL_QUE reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    TRIPLE_IGUAL    reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    AND             reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    OR              reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    SEMI_COLON      reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    CONSOLE         reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    LET             reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    LITERAL         reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    IF              reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    WHILE           reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    FOR             reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    INTERFACE       reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    CONTINUE        reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    BREAK           reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    RETURN          reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    FUNCTION        reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    TOSTRING        reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    ENTERO          reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    DECIMAL         reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    CADENA          reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    TRUE            reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    FALSE           reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    L_PAREN         reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    L_CORCHETE      reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    L_LLAVE         reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    NOT             reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    $end            reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    R_PAREN         reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    R_LLAVE         reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    R_CORCHETE      reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    COMA            reduce using rule 86 (d -> d TRIPLE_IGUAL e .)
    MAS             shift and go to state 111
    MENOS           shift and go to state 112

  ! MENOS           [ reduce using rule 86 (d -> d TRIPLE_IGUAL e .) ]
  ! MAS             [ reduce using rule 86 (d -> d TRIPLE_IGUAL e .) ]


state 165

    (88) e -> e MAS f .

    MAS             reduce using rule 88 (e -> e MAS f .)
    MENOS           reduce using rule 88 (e -> e MAS f .)
    DISTINTO_QUE    reduce using rule 88 (e -> e MAS f .)
    MENOR_QUE       reduce using rule 88 (e -> e MAS f .)
    MENOR_IGUAL_QUE reduce using rule 88 (e -> e MAS f .)
    MAYOR_QUE       reduce using rule 88 (e -> e MAS f .)
    MAYOR_IGUAL_QUE reduce using rule 88 (e -> e MAS f .)
    TRIPLE_IGUAL    reduce using rule 88 (e -> e MAS f .)
    AND             reduce using rule 88 (e -> e MAS f .)
    OR              reduce using rule 88 (e -> e MAS f .)
    SEMI_COLON      reduce using rule 88 (e -> e MAS f .)
    CONSOLE         reduce using rule 88 (e -> e MAS f .)
    LET             reduce using rule 88 (e -> e MAS f .)
    LITERAL         reduce using rule 88 (e -> e MAS f .)
    IF              reduce using rule 88 (e -> e MAS f .)
    WHILE           reduce using rule 88 (e -> e MAS f .)
    FOR             reduce using rule 88 (e -> e MAS f .)
    INTERFACE       reduce using rule 88 (e -> e MAS f .)
    CONTINUE        reduce using rule 88 (e -> e MAS f .)
    BREAK           reduce using rule 88 (e -> e MAS f .)
    RETURN          reduce using rule 88 (e -> e MAS f .)
    FUNCTION        reduce using rule 88 (e -> e MAS f .)
    TOSTRING        reduce using rule 88 (e -> e MAS f .)
    ENTERO          reduce using rule 88 (e -> e MAS f .)
    DECIMAL         reduce using rule 88 (e -> e MAS f .)
    CADENA          reduce using rule 88 (e -> e MAS f .)
    TRUE            reduce using rule 88 (e -> e MAS f .)
    FALSE           reduce using rule 88 (e -> e MAS f .)
    L_PAREN         reduce using rule 88 (e -> e MAS f .)
    L_CORCHETE      reduce using rule 88 (e -> e MAS f .)
    L_LLAVE         reduce using rule 88 (e -> e MAS f .)
    NOT             reduce using rule 88 (e -> e MAS f .)
    $end            reduce using rule 88 (e -> e MAS f .)
    R_PAREN         reduce using rule 88 (e -> e MAS f .)
    R_LLAVE         reduce using rule 88 (e -> e MAS f .)
    R_CORCHETE      reduce using rule 88 (e -> e MAS f .)
    COMA            reduce using rule 88 (e -> e MAS f .)


state 166

    (89) e -> e MENOS f .

    MAS             reduce using rule 89 (e -> e MENOS f .)
    MENOS           reduce using rule 89 (e -> e MENOS f .)
    DISTINTO_QUE    reduce using rule 89 (e -> e MENOS f .)
    MENOR_QUE       reduce using rule 89 (e -> e MENOS f .)
    MENOR_IGUAL_QUE reduce using rule 89 (e -> e MENOS f .)
    MAYOR_QUE       reduce using rule 89 (e -> e MENOS f .)
    MAYOR_IGUAL_QUE reduce using rule 89 (e -> e MENOS f .)
    TRIPLE_IGUAL    reduce using rule 89 (e -> e MENOS f .)
    AND             reduce using rule 89 (e -> e MENOS f .)
    OR              reduce using rule 89 (e -> e MENOS f .)
    SEMI_COLON      reduce using rule 89 (e -> e MENOS f .)
    CONSOLE         reduce using rule 89 (e -> e MENOS f .)
    LET             reduce using rule 89 (e -> e MENOS f .)
    LITERAL         reduce using rule 89 (e -> e MENOS f .)
    IF              reduce using rule 89 (e -> e MENOS f .)
    WHILE           reduce using rule 89 (e -> e MENOS f .)
    FOR             reduce using rule 89 (e -> e MENOS f .)
    INTERFACE       reduce using rule 89 (e -> e MENOS f .)
    CONTINUE        reduce using rule 89 (e -> e MENOS f .)
    BREAK           reduce using rule 89 (e -> e MENOS f .)
    RETURN          reduce using rule 89 (e -> e MENOS f .)
    FUNCTION        reduce using rule 89 (e -> e MENOS f .)
    TOSTRING        reduce using rule 89 (e -> e MENOS f .)
    ENTERO          reduce using rule 89 (e -> e MENOS f .)
    DECIMAL         reduce using rule 89 (e -> e MENOS f .)
    CADENA          reduce using rule 89 (e -> e MENOS f .)
    TRUE            reduce using rule 89 (e -> e MENOS f .)
    FALSE           reduce using rule 89 (e -> e MENOS f .)
    L_PAREN         reduce using rule 89 (e -> e MENOS f .)
    L_CORCHETE      reduce using rule 89 (e -> e MENOS f .)
    L_LLAVE         reduce using rule 89 (e -> e MENOS f .)
    NOT             reduce using rule 89 (e -> e MENOS f .)
    $end            reduce using rule 89 (e -> e MENOS f .)
    R_PAREN         reduce using rule 89 (e -> e MENOS f .)
    R_LLAVE         reduce using rule 89 (e -> e MENOS f .)
    R_CORCHETE      reduce using rule 89 (e -> e MENOS f .)
    COMA            reduce using rule 89 (e -> e MENOS f .)


state 167

    (94) g -> g TIMES h .
    (98) h -> h . POTENCIA i

    TIMES           reduce using rule 94 (g -> g TIMES h .)
    DIVIDE          reduce using rule 94 (g -> g TIMES h .)
    MOD             reduce using rule 94 (g -> g TIMES h .)
    MAS             reduce using rule 94 (g -> g TIMES h .)
    MENOS           reduce using rule 94 (g -> g TIMES h .)
    DISTINTO_QUE    reduce using rule 94 (g -> g TIMES h .)
    MENOR_QUE       reduce using rule 94 (g -> g TIMES h .)
    MENOR_IGUAL_QUE reduce using rule 94 (g -> g TIMES h .)
    MAYOR_QUE       reduce using rule 94 (g -> g TIMES h .)
    MAYOR_IGUAL_QUE reduce using rule 94 (g -> g TIMES h .)
    TRIPLE_IGUAL    reduce using rule 94 (g -> g TIMES h .)
    AND             reduce using rule 94 (g -> g TIMES h .)
    OR              reduce using rule 94 (g -> g TIMES h .)
    SEMI_COLON      reduce using rule 94 (g -> g TIMES h .)
    CONSOLE         reduce using rule 94 (g -> g TIMES h .)
    LET             reduce using rule 94 (g -> g TIMES h .)
    LITERAL         reduce using rule 94 (g -> g TIMES h .)
    IF              reduce using rule 94 (g -> g TIMES h .)
    WHILE           reduce using rule 94 (g -> g TIMES h .)
    FOR             reduce using rule 94 (g -> g TIMES h .)
    INTERFACE       reduce using rule 94 (g -> g TIMES h .)
    CONTINUE        reduce using rule 94 (g -> g TIMES h .)
    BREAK           reduce using rule 94 (g -> g TIMES h .)
    RETURN          reduce using rule 94 (g -> g TIMES h .)
    FUNCTION        reduce using rule 94 (g -> g TIMES h .)
    TOSTRING        reduce using rule 94 (g -> g TIMES h .)
    ENTERO          reduce using rule 94 (g -> g TIMES h .)
    DECIMAL         reduce using rule 94 (g -> g TIMES h .)
    CADENA          reduce using rule 94 (g -> g TIMES h .)
    TRUE            reduce using rule 94 (g -> g TIMES h .)
    FALSE           reduce using rule 94 (g -> g TIMES h .)
    L_PAREN         reduce using rule 94 (g -> g TIMES h .)
    L_CORCHETE      reduce using rule 94 (g -> g TIMES h .)
    L_LLAVE         reduce using rule 94 (g -> g TIMES h .)
    NOT             reduce using rule 94 (g -> g TIMES h .)
    $end            reduce using rule 94 (g -> g TIMES h .)
    R_PAREN         reduce using rule 94 (g -> g TIMES h .)
    R_LLAVE         reduce using rule 94 (g -> g TIMES h .)
    R_CORCHETE      reduce using rule 94 (g -> g TIMES h .)
    COMA            reduce using rule 94 (g -> g TIMES h .)
    POTENCIA        shift and go to state 116


state 168

    (95) g -> g DIVIDE h .
    (98) h -> h . POTENCIA i

    TIMES           reduce using rule 95 (g -> g DIVIDE h .)
    DIVIDE          reduce using rule 95 (g -> g DIVIDE h .)
    MOD             reduce using rule 95 (g -> g DIVIDE h .)
    MAS             reduce using rule 95 (g -> g DIVIDE h .)
    MENOS           reduce using rule 95 (g -> g DIVIDE h .)
    DISTINTO_QUE    reduce using rule 95 (g -> g DIVIDE h .)
    MENOR_QUE       reduce using rule 95 (g -> g DIVIDE h .)
    MENOR_IGUAL_QUE reduce using rule 95 (g -> g DIVIDE h .)
    MAYOR_QUE       reduce using rule 95 (g -> g DIVIDE h .)
    MAYOR_IGUAL_QUE reduce using rule 95 (g -> g DIVIDE h .)
    TRIPLE_IGUAL    reduce using rule 95 (g -> g DIVIDE h .)
    AND             reduce using rule 95 (g -> g DIVIDE h .)
    OR              reduce using rule 95 (g -> g DIVIDE h .)
    SEMI_COLON      reduce using rule 95 (g -> g DIVIDE h .)
    CONSOLE         reduce using rule 95 (g -> g DIVIDE h .)
    LET             reduce using rule 95 (g -> g DIVIDE h .)
    LITERAL         reduce using rule 95 (g -> g DIVIDE h .)
    IF              reduce using rule 95 (g -> g DIVIDE h .)
    WHILE           reduce using rule 95 (g -> g DIVIDE h .)
    FOR             reduce using rule 95 (g -> g DIVIDE h .)
    INTERFACE       reduce using rule 95 (g -> g DIVIDE h .)
    CONTINUE        reduce using rule 95 (g -> g DIVIDE h .)
    BREAK           reduce using rule 95 (g -> g DIVIDE h .)
    RETURN          reduce using rule 95 (g -> g DIVIDE h .)
    FUNCTION        reduce using rule 95 (g -> g DIVIDE h .)
    TOSTRING        reduce using rule 95 (g -> g DIVIDE h .)
    ENTERO          reduce using rule 95 (g -> g DIVIDE h .)
    DECIMAL         reduce using rule 95 (g -> g DIVIDE h .)
    CADENA          reduce using rule 95 (g -> g DIVIDE h .)
    TRUE            reduce using rule 95 (g -> g DIVIDE h .)
    FALSE           reduce using rule 95 (g -> g DIVIDE h .)
    L_PAREN         reduce using rule 95 (g -> g DIVIDE h .)
    L_CORCHETE      reduce using rule 95 (g -> g DIVIDE h .)
    L_LLAVE         reduce using rule 95 (g -> g DIVIDE h .)
    NOT             reduce using rule 95 (g -> g DIVIDE h .)
    $end            reduce using rule 95 (g -> g DIVIDE h .)
    R_PAREN         reduce using rule 95 (g -> g DIVIDE h .)
    R_LLAVE         reduce using rule 95 (g -> g DIVIDE h .)
    R_CORCHETE      reduce using rule 95 (g -> g DIVIDE h .)
    COMA            reduce using rule 95 (g -> g DIVIDE h .)
    POTENCIA        shift and go to state 116


state 169

    (96) g -> g MOD h .
    (98) h -> h . POTENCIA i

    TIMES           reduce using rule 96 (g -> g MOD h .)
    DIVIDE          reduce using rule 96 (g -> g MOD h .)
    MOD             reduce using rule 96 (g -> g MOD h .)
    MAS             reduce using rule 96 (g -> g MOD h .)
    MENOS           reduce using rule 96 (g -> g MOD h .)
    DISTINTO_QUE    reduce using rule 96 (g -> g MOD h .)
    MENOR_QUE       reduce using rule 96 (g -> g MOD h .)
    MENOR_IGUAL_QUE reduce using rule 96 (g -> g MOD h .)
    MAYOR_QUE       reduce using rule 96 (g -> g MOD h .)
    MAYOR_IGUAL_QUE reduce using rule 96 (g -> g MOD h .)
    TRIPLE_IGUAL    reduce using rule 96 (g -> g MOD h .)
    AND             reduce using rule 96 (g -> g MOD h .)
    OR              reduce using rule 96 (g -> g MOD h .)
    SEMI_COLON      reduce using rule 96 (g -> g MOD h .)
    CONSOLE         reduce using rule 96 (g -> g MOD h .)
    LET             reduce using rule 96 (g -> g MOD h .)
    LITERAL         reduce using rule 96 (g -> g MOD h .)
    IF              reduce using rule 96 (g -> g MOD h .)
    WHILE           reduce using rule 96 (g -> g MOD h .)
    FOR             reduce using rule 96 (g -> g MOD h .)
    INTERFACE       reduce using rule 96 (g -> g MOD h .)
    CONTINUE        reduce using rule 96 (g -> g MOD h .)
    BREAK           reduce using rule 96 (g -> g MOD h .)
    RETURN          reduce using rule 96 (g -> g MOD h .)
    FUNCTION        reduce using rule 96 (g -> g MOD h .)
    TOSTRING        reduce using rule 96 (g -> g MOD h .)
    ENTERO          reduce using rule 96 (g -> g MOD h .)
    DECIMAL         reduce using rule 96 (g -> g MOD h .)
    CADENA          reduce using rule 96 (g -> g MOD h .)
    TRUE            reduce using rule 96 (g -> g MOD h .)
    FALSE           reduce using rule 96 (g -> g MOD h .)
    L_PAREN         reduce using rule 96 (g -> g MOD h .)
    L_CORCHETE      reduce using rule 96 (g -> g MOD h .)
    L_LLAVE         reduce using rule 96 (g -> g MOD h .)
    NOT             reduce using rule 96 (g -> g MOD h .)
    $end            reduce using rule 96 (g -> g MOD h .)
    R_PAREN         reduce using rule 96 (g -> g MOD h .)
    R_LLAVE         reduce using rule 96 (g -> g MOD h .)
    R_CORCHETE      reduce using rule 96 (g -> g MOD h .)
    COMA            reduce using rule 96 (g -> g MOD h .)
    POTENCIA        shift and go to state 116


state 170

    (98) h -> h POTENCIA i .
    (111) i -> i . PUNTO LITERAL
    (112) i -> i . PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> i . PUNTO nativeFun L_PAREN R_PAREN

    POTENCIA        reduce using rule 98 (h -> h POTENCIA i .)
    TIMES           reduce using rule 98 (h -> h POTENCIA i .)
    DIVIDE          reduce using rule 98 (h -> h POTENCIA i .)
    MOD             reduce using rule 98 (h -> h POTENCIA i .)
    MAS             reduce using rule 98 (h -> h POTENCIA i .)
    MENOS           reduce using rule 98 (h -> h POTENCIA i .)
    DISTINTO_QUE    reduce using rule 98 (h -> h POTENCIA i .)
    MENOR_QUE       reduce using rule 98 (h -> h POTENCIA i .)
    MENOR_IGUAL_QUE reduce using rule 98 (h -> h POTENCIA i .)
    MAYOR_QUE       reduce using rule 98 (h -> h POTENCIA i .)
    MAYOR_IGUAL_QUE reduce using rule 98 (h -> h POTENCIA i .)
    TRIPLE_IGUAL    reduce using rule 98 (h -> h POTENCIA i .)
    AND             reduce using rule 98 (h -> h POTENCIA i .)
    OR              reduce using rule 98 (h -> h POTENCIA i .)
    SEMI_COLON      reduce using rule 98 (h -> h POTENCIA i .)
    CONSOLE         reduce using rule 98 (h -> h POTENCIA i .)
    LET             reduce using rule 98 (h -> h POTENCIA i .)
    LITERAL         reduce using rule 98 (h -> h POTENCIA i .)
    IF              reduce using rule 98 (h -> h POTENCIA i .)
    WHILE           reduce using rule 98 (h -> h POTENCIA i .)
    FOR             reduce using rule 98 (h -> h POTENCIA i .)
    INTERFACE       reduce using rule 98 (h -> h POTENCIA i .)
    CONTINUE        reduce using rule 98 (h -> h POTENCIA i .)
    BREAK           reduce using rule 98 (h -> h POTENCIA i .)
    RETURN          reduce using rule 98 (h -> h POTENCIA i .)
    FUNCTION        reduce using rule 98 (h -> h POTENCIA i .)
    TOSTRING        reduce using rule 98 (h -> h POTENCIA i .)
    ENTERO          reduce using rule 98 (h -> h POTENCIA i .)
    DECIMAL         reduce using rule 98 (h -> h POTENCIA i .)
    CADENA          reduce using rule 98 (h -> h POTENCIA i .)
    TRUE            reduce using rule 98 (h -> h POTENCIA i .)
    FALSE           reduce using rule 98 (h -> h POTENCIA i .)
    L_PAREN         reduce using rule 98 (h -> h POTENCIA i .)
    L_CORCHETE      reduce using rule 98 (h -> h POTENCIA i .)
    L_LLAVE         reduce using rule 98 (h -> h POTENCIA i .)
    NOT             reduce using rule 98 (h -> h POTENCIA i .)
    $end            reduce using rule 98 (h -> h POTENCIA i .)
    R_PAREN         reduce using rule 98 (h -> h POTENCIA i .)
    R_LLAVE         reduce using rule 98 (h -> h POTENCIA i .)
    R_CORCHETE      reduce using rule 98 (h -> h POTENCIA i .)
    COMA            reduce using rule 98 (h -> h POTENCIA i .)
    PUNTO           shift and go to state 120


state 171

    (72) console_pro -> CONSOLE PUNTO LOG L_PAREN . expresion R_PAREN
    (73) expresion -> . expresion COMA a
    (74) expresion -> . a
    (75) a -> . a OR b
    (76) a -> . b
    (77) b -> . b AND c
    (78) b -> . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    expresion                      shift and go to state 202
    a                              shift and go to state 203
    b                              shift and go to state 36
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 172

    (111) i -> i PUNTO LITERAL .

    PUNTO           reduce using rule 111 (i -> i PUNTO LITERAL .)
    POTENCIA        reduce using rule 111 (i -> i PUNTO LITERAL .)
    TIMES           reduce using rule 111 (i -> i PUNTO LITERAL .)
    DIVIDE          reduce using rule 111 (i -> i PUNTO LITERAL .)
    MOD             reduce using rule 111 (i -> i PUNTO LITERAL .)
    MAS             reduce using rule 111 (i -> i PUNTO LITERAL .)
    MENOS           reduce using rule 111 (i -> i PUNTO LITERAL .)
    DISTINTO_QUE    reduce using rule 111 (i -> i PUNTO LITERAL .)
    MENOR_QUE       reduce using rule 111 (i -> i PUNTO LITERAL .)
    MENOR_IGUAL_QUE reduce using rule 111 (i -> i PUNTO LITERAL .)
    MAYOR_QUE       reduce using rule 111 (i -> i PUNTO LITERAL .)
    MAYOR_IGUAL_QUE reduce using rule 111 (i -> i PUNTO LITERAL .)
    TRIPLE_IGUAL    reduce using rule 111 (i -> i PUNTO LITERAL .)
    AND             reduce using rule 111 (i -> i PUNTO LITERAL .)
    R_PAREN         reduce using rule 111 (i -> i PUNTO LITERAL .)
    OR              reduce using rule 111 (i -> i PUNTO LITERAL .)
    SEMI_COLON      reduce using rule 111 (i -> i PUNTO LITERAL .)
    CONSOLE         reduce using rule 111 (i -> i PUNTO LITERAL .)
    LET             reduce using rule 111 (i -> i PUNTO LITERAL .)
    LITERAL         reduce using rule 111 (i -> i PUNTO LITERAL .)
    IF              reduce using rule 111 (i -> i PUNTO LITERAL .)
    WHILE           reduce using rule 111 (i -> i PUNTO LITERAL .)
    FOR             reduce using rule 111 (i -> i PUNTO LITERAL .)
    INTERFACE       reduce using rule 111 (i -> i PUNTO LITERAL .)
    CONTINUE        reduce using rule 111 (i -> i PUNTO LITERAL .)
    BREAK           reduce using rule 111 (i -> i PUNTO LITERAL .)
    RETURN          reduce using rule 111 (i -> i PUNTO LITERAL .)
    FUNCTION        reduce using rule 111 (i -> i PUNTO LITERAL .)
    TOSTRING        reduce using rule 111 (i -> i PUNTO LITERAL .)
    ENTERO          reduce using rule 111 (i -> i PUNTO LITERAL .)
    DECIMAL         reduce using rule 111 (i -> i PUNTO LITERAL .)
    CADENA          reduce using rule 111 (i -> i PUNTO LITERAL .)
    TRUE            reduce using rule 111 (i -> i PUNTO LITERAL .)
    FALSE           reduce using rule 111 (i -> i PUNTO LITERAL .)
    L_PAREN         reduce using rule 111 (i -> i PUNTO LITERAL .)
    L_CORCHETE      reduce using rule 111 (i -> i PUNTO LITERAL .)
    L_LLAVE         reduce using rule 111 (i -> i PUNTO LITERAL .)
    NOT             reduce using rule 111 (i -> i PUNTO LITERAL .)
    $end            reduce using rule 111 (i -> i PUNTO LITERAL .)
    R_LLAVE         reduce using rule 111 (i -> i PUNTO LITERAL .)
    R_CORCHETE      reduce using rule 111 (i -> i PUNTO LITERAL .)
    COMA            reduce using rule 111 (i -> i PUNTO LITERAL .)


state 173

    (49) declaracion_list -> declaracion_list COMA assignacion_instruction .

    COMA            reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    SEMI_COLON      reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    CONSOLE         reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    LET             reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    LITERAL         reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    IF              reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    WHILE           reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    FOR             reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    INTERFACE       reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    CONTINUE        reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    BREAK           reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    RETURN          reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    FUNCTION        reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    TOSTRING        reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    ENTERO          reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    DECIMAL         reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    CADENA          reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    TRUE            reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    FALSE           reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    L_PAREN         reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    L_CORCHETE      reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    L_LLAVE         reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    NOT             reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    MENOS           reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    MAS             reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    $end            reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)
    R_LLAVE         reduce using rule 49 (declaracion_list -> declaracion_list COMA assignacion_instruction .)


state 174

    (59) type -> LITERAL .

    IGUAL           reduce using rule 59 (type -> LITERAL .)
    COMA            reduce using rule 59 (type -> LITERAL .)
    SEMI_COLON      reduce using rule 59 (type -> LITERAL .)
    CONSOLE         reduce using rule 59 (type -> LITERAL .)
    LET             reduce using rule 59 (type -> LITERAL .)
    LITERAL         reduce using rule 59 (type -> LITERAL .)
    IF              reduce using rule 59 (type -> LITERAL .)
    WHILE           reduce using rule 59 (type -> LITERAL .)
    FOR             reduce using rule 59 (type -> LITERAL .)
    INTERFACE       reduce using rule 59 (type -> LITERAL .)
    CONTINUE        reduce using rule 59 (type -> LITERAL .)
    BREAK           reduce using rule 59 (type -> LITERAL .)
    RETURN          reduce using rule 59 (type -> LITERAL .)
    FUNCTION        reduce using rule 59 (type -> LITERAL .)
    TOSTRING        reduce using rule 59 (type -> LITERAL .)
    ENTERO          reduce using rule 59 (type -> LITERAL .)
    DECIMAL         reduce using rule 59 (type -> LITERAL .)
    CADENA          reduce using rule 59 (type -> LITERAL .)
    TRUE            reduce using rule 59 (type -> LITERAL .)
    FALSE           reduce using rule 59 (type -> LITERAL .)
    L_PAREN         reduce using rule 59 (type -> LITERAL .)
    L_CORCHETE      reduce using rule 59 (type -> LITERAL .)
    L_LLAVE         reduce using rule 59 (type -> LITERAL .)
    NOT             reduce using rule 59 (type -> LITERAL .)
    MENOS           reduce using rule 59 (type -> LITERAL .)
    MAS             reduce using rule 59 (type -> LITERAL .)
    $end            reduce using rule 59 (type -> LITERAL .)
    R_LLAVE         reduce using rule 59 (type -> LITERAL .)
    R_PAREN         reduce using rule 59 (type -> LITERAL .)


state 175

    (51) assignacion_instruction -> LITERAL COLON type . IGUAL a
    (52) assignacion_instruction -> LITERAL COLON type .

    IGUAL           shift and go to state 204
    COMA            reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    SEMI_COLON      reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    CONSOLE         reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    LET             reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    LITERAL         reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    IF              reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    WHILE           reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    FOR             reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    INTERFACE       reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    CONTINUE        reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    BREAK           reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    RETURN          reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    FUNCTION        reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    TOSTRING        reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    ENTERO          reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    DECIMAL         reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    CADENA          reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    TRUE            reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    FALSE           reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    L_PAREN         reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    L_CORCHETE      reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    L_LLAVE         reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    NOT             reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    MENOS           reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    MAS             reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    $end            reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)
    R_LLAVE         reduce using rule 52 (assignacion_instruction -> LITERAL COLON type .)


state 176

    (55) type -> NUMBER .

    IGUAL           reduce using rule 55 (type -> NUMBER .)
    COMA            reduce using rule 55 (type -> NUMBER .)
    SEMI_COLON      reduce using rule 55 (type -> NUMBER .)
    CONSOLE         reduce using rule 55 (type -> NUMBER .)
    LET             reduce using rule 55 (type -> NUMBER .)
    LITERAL         reduce using rule 55 (type -> NUMBER .)
    IF              reduce using rule 55 (type -> NUMBER .)
    WHILE           reduce using rule 55 (type -> NUMBER .)
    FOR             reduce using rule 55 (type -> NUMBER .)
    INTERFACE       reduce using rule 55 (type -> NUMBER .)
    CONTINUE        reduce using rule 55 (type -> NUMBER .)
    BREAK           reduce using rule 55 (type -> NUMBER .)
    RETURN          reduce using rule 55 (type -> NUMBER .)
    FUNCTION        reduce using rule 55 (type -> NUMBER .)
    TOSTRING        reduce using rule 55 (type -> NUMBER .)
    ENTERO          reduce using rule 55 (type -> NUMBER .)
    DECIMAL         reduce using rule 55 (type -> NUMBER .)
    CADENA          reduce using rule 55 (type -> NUMBER .)
    TRUE            reduce using rule 55 (type -> NUMBER .)
    FALSE           reduce using rule 55 (type -> NUMBER .)
    L_PAREN         reduce using rule 55 (type -> NUMBER .)
    L_CORCHETE      reduce using rule 55 (type -> NUMBER .)
    L_LLAVE         reduce using rule 55 (type -> NUMBER .)
    NOT             reduce using rule 55 (type -> NUMBER .)
    MENOS           reduce using rule 55 (type -> NUMBER .)
    MAS             reduce using rule 55 (type -> NUMBER .)
    $end            reduce using rule 55 (type -> NUMBER .)
    R_LLAVE         reduce using rule 55 (type -> NUMBER .)
    R_PAREN         reduce using rule 55 (type -> NUMBER .)


state 177

    (56) type -> STRING .

    IGUAL           reduce using rule 56 (type -> STRING .)
    COMA            reduce using rule 56 (type -> STRING .)
    SEMI_COLON      reduce using rule 56 (type -> STRING .)
    CONSOLE         reduce using rule 56 (type -> STRING .)
    LET             reduce using rule 56 (type -> STRING .)
    LITERAL         reduce using rule 56 (type -> STRING .)
    IF              reduce using rule 56 (type -> STRING .)
    WHILE           reduce using rule 56 (type -> STRING .)
    FOR             reduce using rule 56 (type -> STRING .)
    INTERFACE       reduce using rule 56 (type -> STRING .)
    CONTINUE        reduce using rule 56 (type -> STRING .)
    BREAK           reduce using rule 56 (type -> STRING .)
    RETURN          reduce using rule 56 (type -> STRING .)
    FUNCTION        reduce using rule 56 (type -> STRING .)
    TOSTRING        reduce using rule 56 (type -> STRING .)
    ENTERO          reduce using rule 56 (type -> STRING .)
    DECIMAL         reduce using rule 56 (type -> STRING .)
    CADENA          reduce using rule 56 (type -> STRING .)
    TRUE            reduce using rule 56 (type -> STRING .)
    FALSE           reduce using rule 56 (type -> STRING .)
    L_PAREN         reduce using rule 56 (type -> STRING .)
    L_CORCHETE      reduce using rule 56 (type -> STRING .)
    L_LLAVE         reduce using rule 56 (type -> STRING .)
    NOT             reduce using rule 56 (type -> STRING .)
    MENOS           reduce using rule 56 (type -> STRING .)
    MAS             reduce using rule 56 (type -> STRING .)
    $end            reduce using rule 56 (type -> STRING .)
    R_LLAVE         reduce using rule 56 (type -> STRING .)
    R_PAREN         reduce using rule 56 (type -> STRING .)


state 178

    (57) type -> BOOLEAN .

    IGUAL           reduce using rule 57 (type -> BOOLEAN .)
    COMA            reduce using rule 57 (type -> BOOLEAN .)
    SEMI_COLON      reduce using rule 57 (type -> BOOLEAN .)
    CONSOLE         reduce using rule 57 (type -> BOOLEAN .)
    LET             reduce using rule 57 (type -> BOOLEAN .)
    LITERAL         reduce using rule 57 (type -> BOOLEAN .)
    IF              reduce using rule 57 (type -> BOOLEAN .)
    WHILE           reduce using rule 57 (type -> BOOLEAN .)
    FOR             reduce using rule 57 (type -> BOOLEAN .)
    INTERFACE       reduce using rule 57 (type -> BOOLEAN .)
    CONTINUE        reduce using rule 57 (type -> BOOLEAN .)
    BREAK           reduce using rule 57 (type -> BOOLEAN .)
    RETURN          reduce using rule 57 (type -> BOOLEAN .)
    FUNCTION        reduce using rule 57 (type -> BOOLEAN .)
    TOSTRING        reduce using rule 57 (type -> BOOLEAN .)
    ENTERO          reduce using rule 57 (type -> BOOLEAN .)
    DECIMAL         reduce using rule 57 (type -> BOOLEAN .)
    CADENA          reduce using rule 57 (type -> BOOLEAN .)
    TRUE            reduce using rule 57 (type -> BOOLEAN .)
    FALSE           reduce using rule 57 (type -> BOOLEAN .)
    L_PAREN         reduce using rule 57 (type -> BOOLEAN .)
    L_CORCHETE      reduce using rule 57 (type -> BOOLEAN .)
    L_LLAVE         reduce using rule 57 (type -> BOOLEAN .)
    NOT             reduce using rule 57 (type -> BOOLEAN .)
    MENOS           reduce using rule 57 (type -> BOOLEAN .)
    MAS             reduce using rule 57 (type -> BOOLEAN .)
    $end            reduce using rule 57 (type -> BOOLEAN .)
    R_LLAVE         reduce using rule 57 (type -> BOOLEAN .)
    R_PAREN         reduce using rule 57 (type -> BOOLEAN .)


state 179

    (58) type -> ANY .

    IGUAL           reduce using rule 58 (type -> ANY .)
    COMA            reduce using rule 58 (type -> ANY .)
    SEMI_COLON      reduce using rule 58 (type -> ANY .)
    CONSOLE         reduce using rule 58 (type -> ANY .)
    LET             reduce using rule 58 (type -> ANY .)
    LITERAL         reduce using rule 58 (type -> ANY .)
    IF              reduce using rule 58 (type -> ANY .)
    WHILE           reduce using rule 58 (type -> ANY .)
    FOR             reduce using rule 58 (type -> ANY .)
    INTERFACE       reduce using rule 58 (type -> ANY .)
    CONTINUE        reduce using rule 58 (type -> ANY .)
    BREAK           reduce using rule 58 (type -> ANY .)
    RETURN          reduce using rule 58 (type -> ANY .)
    FUNCTION        reduce using rule 58 (type -> ANY .)
    TOSTRING        reduce using rule 58 (type -> ANY .)
    ENTERO          reduce using rule 58 (type -> ANY .)
    DECIMAL         reduce using rule 58 (type -> ANY .)
    CADENA          reduce using rule 58 (type -> ANY .)
    TRUE            reduce using rule 58 (type -> ANY .)
    FALSE           reduce using rule 58 (type -> ANY .)
    L_PAREN         reduce using rule 58 (type -> ANY .)
    L_CORCHETE      reduce using rule 58 (type -> ANY .)
    L_LLAVE         reduce using rule 58 (type -> ANY .)
    NOT             reduce using rule 58 (type -> ANY .)
    MENOS           reduce using rule 58 (type -> ANY .)
    MAS             reduce using rule 58 (type -> ANY .)
    $end            reduce using rule 58 (type -> ANY .)
    R_LLAVE         reduce using rule 58 (type -> ANY .)
    R_PAREN         reduce using rule 58 (type -> ANY .)


state 180

    (60) type -> NULL .

    IGUAL           reduce using rule 60 (type -> NULL .)
    COMA            reduce using rule 60 (type -> NULL .)
    SEMI_COLON      reduce using rule 60 (type -> NULL .)
    CONSOLE         reduce using rule 60 (type -> NULL .)
    LET             reduce using rule 60 (type -> NULL .)
    LITERAL         reduce using rule 60 (type -> NULL .)
    IF              reduce using rule 60 (type -> NULL .)
    WHILE           reduce using rule 60 (type -> NULL .)
    FOR             reduce using rule 60 (type -> NULL .)
    INTERFACE       reduce using rule 60 (type -> NULL .)
    CONTINUE        reduce using rule 60 (type -> NULL .)
    BREAK           reduce using rule 60 (type -> NULL .)
    RETURN          reduce using rule 60 (type -> NULL .)
    FUNCTION        reduce using rule 60 (type -> NULL .)
    TOSTRING        reduce using rule 60 (type -> NULL .)
    ENTERO          reduce using rule 60 (type -> NULL .)
    DECIMAL         reduce using rule 60 (type -> NULL .)
    CADENA          reduce using rule 60 (type -> NULL .)
    TRUE            reduce using rule 60 (type -> NULL .)
    FALSE           reduce using rule 60 (type -> NULL .)
    L_PAREN         reduce using rule 60 (type -> NULL .)
    L_CORCHETE      reduce using rule 60 (type -> NULL .)
    L_LLAVE         reduce using rule 60 (type -> NULL .)
    NOT             reduce using rule 60 (type -> NULL .)
    MENOS           reduce using rule 60 (type -> NULL .)
    MAS             reduce using rule 60 (type -> NULL .)
    $end            reduce using rule 60 (type -> NULL .)
    R_LLAVE         reduce using rule 60 (type -> NULL .)
    R_PAREN         reduce using rule 60 (type -> NULL .)


state 181

    (53) assignacion_instruction -> LITERAL IGUAL a .
    (75) a -> a . OR b

    COMA            reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    SEMI_COLON      reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    CONSOLE         reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    LET             reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    LITERAL         reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    IF              reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    WHILE           reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    FOR             reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    INTERFACE       reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    CONTINUE        reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    BREAK           reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    RETURN          reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    FUNCTION        reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    TOSTRING        reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    ENTERO          reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    DECIMAL         reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    CADENA          reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    TRUE            reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    FALSE           reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    L_PAREN         reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    L_CORCHETE      reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    L_LLAVE         reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    NOT             reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    MENOS           reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    MAS             reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    $end            reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    R_LLAVE         reduce using rule 53 (assignacion_instruction -> LITERAL IGUAL a .)
    OR              shift and go to state 73


state 182

    (123) array_assign_pro -> LITERAL dimensions IGUAL a .
    (75) a -> a . OR b

    SEMI_COLON      reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    CONSOLE         reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    LET             reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    LITERAL         reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    IF              reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    WHILE           reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    FOR             reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    INTERFACE       reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    CONTINUE        reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    BREAK           reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    RETURN          reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    FUNCTION        reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    TOSTRING        reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    ENTERO          reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    DECIMAL         reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    CADENA          reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    TRUE            reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    FALSE           reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    L_PAREN         reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    L_CORCHETE      reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    L_LLAVE         reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    NOT             reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    MENOS           reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    MAS             reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    $end            reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    R_LLAVE         reduce using rule 123 (array_assign_pro -> LITERAL dimensions IGUAL a .)
    OR              shift and go to state 73


state 183

    (115) dimensions -> dimensions L_CORCHETE a . R_CORCHETE
    (75) a -> a . OR b

    R_CORCHETE      shift and go to state 205
    OR              shift and go to state 73


state 184

    (29) call_function_pro -> LITERAL L_PAREN values R_PAREN .

    SEMI_COLON      reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    CONSOLE         reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    LET             reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    LITERAL         reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    IF              reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    WHILE           reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    FOR             reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    INTERFACE       reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    CONTINUE        reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    BREAK           reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    RETURN          reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    FUNCTION        reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    TOSTRING        reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    ENTERO          reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    DECIMAL         reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    CADENA          reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    TRUE            reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    FALSE           reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    L_PAREN         reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    L_CORCHETE      reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    L_LLAVE         reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    NOT             reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    MENOS           reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    MAS             reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    $end            reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    PUNTO           reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    POTENCIA        reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    TIMES           reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    DIVIDE          reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    MOD             reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    DISTINTO_QUE    reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    MENOR_QUE       reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    MENOR_IGUAL_QUE reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    MAYOR_QUE       reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    MAYOR_IGUAL_QUE reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    TRIPLE_IGUAL    reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    AND             reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    OR              reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    R_PAREN         reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    R_LLAVE         reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    R_CORCHETE      reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)
    COMA            reduce using rule 29 (call_function_pro -> LITERAL L_PAREN values R_PAREN .)


state 185

    (116) dimensions -> L_CORCHETE a R_CORCHETE .

    IGUAL           reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    L_CORCHETE      reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    PUNTO           reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    POTENCIA        reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    TIMES           reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    DIVIDE          reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    MOD             reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    MAS             reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    MENOS           reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    DISTINTO_QUE    reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    MENOR_QUE       reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    MENOR_IGUAL_QUE reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    MAYOR_QUE       reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    MAYOR_IGUAL_QUE reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    TRIPLE_IGUAL    reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    AND             reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    OR              reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    SEMI_COLON      reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    CONSOLE         reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    LET             reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    LITERAL         reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    IF              reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    WHILE           reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    FOR             reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    INTERFACE       reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    CONTINUE        reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    BREAK           reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    RETURN          reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    FUNCTION        reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    TOSTRING        reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    ENTERO          reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    DECIMAL         reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    CADENA          reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    TRUE            reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    FALSE           reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    L_PAREN         reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    L_LLAVE         reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    NOT             reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    $end            reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    R_LLAVE         reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    R_PAREN         reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    R_CORCHETE      reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)
    COMA            reduce using rule 116 (dimensions -> L_CORCHETE a R_CORCHETE .)


state 186

    (47) interface_assign_pro -> i PUNTO LITERAL IGUAL . a
    (75) a -> . a OR b
    (76) a -> . b
    (77) b -> . b AND c
    (78) b -> . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    i                              shift and go to state 77
    a                              shift and go to state 206
    b                              shift and go to state 36
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 187

    (112) i -> i PUNTO nativeFun L_PAREN . expresion R_PAREN
    (113) i -> i PUNTO nativeFun L_PAREN . R_PAREN
    (73) expresion -> . expresion COMA a
    (74) expresion -> . a
    (75) a -> . a OR b
    (76) a -> . b
    (77) b -> . b AND c
    (78) b -> . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    R_PAREN         shift and go to state 208
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    i                              shift and go to state 77
    expresion                      shift and go to state 207
    a                              shift and go to state 203
    b                              shift and go to state 36
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 188

    (62) if_pro -> IF L_PAREN a R_PAREN . L_LLAVE instrucciones R_LLAVE else_pro

    L_LLAVE         shift and go to state 209


state 189

    (120) atributos_assi -> atributos_assi COMA LITERAL . COLON a

    COLON           shift and go to state 210


state 190

    (121) atributos_assi -> LITERAL COLON a .
    (75) a -> a . OR b

    R_LLAVE         reduce using rule 121 (atributos_assi -> LITERAL COLON a .)
    COMA            reduce using rule 121 (atributos_assi -> LITERAL COLON a .)
    OR              shift and go to state 73


state 191

    (66) while_pro -> WHILE L_PAREN a R_PAREN . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 211


state 192

    (67) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON . a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (75) a -> . a OR b
    (76) a -> . b
    (77) b -> . b AND c
    (78) b -> . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    a                              shift and go to state 212
    b                              shift and go to state 36
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 193

    (68) for_pro -> FOR L_PAREN assig_pro SEMI_COLON . a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (75) a -> . a OR b
    (76) a -> . b
    (77) b -> . b AND c
    (78) b -> . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    a                              shift and go to state 213
    b                              shift and go to state 36
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 194

    (71) for_each_pro -> FOR L_PAREN LET LITERAL . OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (51) assignacion_instruction -> LITERAL . COLON type IGUAL a
    (52) assignacion_instruction -> LITERAL . COLON type
    (53) assignacion_instruction -> LITERAL . IGUAL a
    (54) assignacion_instruction -> LITERAL .

    OF              shift and go to state 214
    COLON           shift and go to state 123
    IGUAL           shift and go to state 124
    COMA            reduce using rule 54 (assignacion_instruction -> LITERAL .)
    SEMI_COLON      reduce using rule 54 (assignacion_instruction -> LITERAL .)


state 195

    (42) interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos . R_LLAVE
    (43) interface_atributos -> interface_atributos . interface_atributo sc
    (45) interface_atributo -> . LITERAL COLON type
    (46) interface_atributo -> . LITERAL

    R_LLAVE         shift and go to state 216
    LITERAL         shift and go to state 215

    interface_atributo             shift and go to state 217

state 196

    (36) parameter_pro -> LITERAL . COLON type
    (37) parameter_pro -> LITERAL .

    COLON           shift and go to state 218
    R_PAREN         reduce using rule 37 (parameter_pro -> LITERAL .)
    COMA            reduce using rule 37 (parameter_pro -> LITERAL .)


state 197

    (23) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro . R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro . R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro . R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (34) parameters_pro -> parameters_pro . COMA parameter_pro

    R_PAREN         shift and go to state 219
    COMA            shift and go to state 220


state 198

    (24) function_pro -> FUNCTION LITERAL L_PAREN R_PAREN . L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> FUNCTION LITERAL L_PAREN R_PAREN . COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> FUNCTION LITERAL L_PAREN R_PAREN . COLON LITERAL L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 221
    COLON           shift and go to state 222


state 199

    (35) parameters_pro -> parameter_pro .

    R_PAREN         reduce using rule 35 (parameters_pro -> parameter_pro .)
    COMA            reduce using rule 35 (parameters_pro -> parameter_pro .)


state 200

    (31) call_function_pro -> TOSTRING L_PAREN values R_PAREN .

    SEMI_COLON      reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    CONSOLE         reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    LET             reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    LITERAL         reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    IF              reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    WHILE           reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    FOR             reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    INTERFACE       reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    CONTINUE        reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    BREAK           reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    RETURN          reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    FUNCTION        reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    TOSTRING        reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    ENTERO          reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    DECIMAL         reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    CADENA          reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    TRUE            reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    FALSE           reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    L_PAREN         reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    L_CORCHETE      reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    L_LLAVE         reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    NOT             reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    MENOS           reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    MAS             reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    $end            reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    PUNTO           reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    POTENCIA        reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    TIMES           reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    DIVIDE          reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    MOD             reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    DISTINTO_QUE    reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    MENOR_QUE       reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    MENOR_IGUAL_QUE reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    MAYOR_QUE       reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    MAYOR_IGUAL_QUE reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    TRIPLE_IGUAL    reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    AND             reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    OR              reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    R_PAREN         reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    R_LLAVE         reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    R_CORCHETE      reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)
    COMA            reduce using rule 31 (call_function_pro -> TOSTRING L_PAREN values R_PAREN .)


state 201

    (32) values -> values COMA a .
    (75) a -> a . OR b

    R_CORCHETE      reduce using rule 32 (values -> values COMA a .)
    COMA            reduce using rule 32 (values -> values COMA a .)
    R_PAREN         reduce using rule 32 (values -> values COMA a .)
    OR              shift and go to state 73


state 202

    (72) console_pro -> CONSOLE PUNTO LOG L_PAREN expresion . R_PAREN
    (73) expresion -> expresion . COMA a

    R_PAREN         shift and go to state 223
    COMA            shift and go to state 224


state 203

    (74) expresion -> a .
    (75) a -> a . OR b

    R_PAREN         reduce using rule 74 (expresion -> a .)
    COMA            reduce using rule 74 (expresion -> a .)
    OR              shift and go to state 73


state 204

    (51) assignacion_instruction -> LITERAL COLON type IGUAL . a
    (75) a -> . a OR b
    (76) a -> . b
    (77) b -> . b AND c
    (78) b -> . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    a                              shift and go to state 225
    b                              shift and go to state 36
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 205

    (115) dimensions -> dimensions L_CORCHETE a R_CORCHETE .

    IGUAL           reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    L_CORCHETE      reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    PUNTO           reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    POTENCIA        reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    TIMES           reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    DIVIDE          reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    MOD             reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    MAS             reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    MENOS           reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    DISTINTO_QUE    reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    MENOR_QUE       reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    MENOR_IGUAL_QUE reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    MAYOR_QUE       reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    MAYOR_IGUAL_QUE reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    TRIPLE_IGUAL    reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    AND             reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    OR              reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    SEMI_COLON      reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    CONSOLE         reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    LET             reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    LITERAL         reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    IF              reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    WHILE           reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    FOR             reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    INTERFACE       reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    CONTINUE        reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    BREAK           reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    RETURN          reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    FUNCTION        reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    TOSTRING        reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    ENTERO          reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    DECIMAL         reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    CADENA          reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    TRUE            reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    FALSE           reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    L_PAREN         reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    L_LLAVE         reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    NOT             reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    $end            reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    R_LLAVE         reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    R_PAREN         reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    R_CORCHETE      reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)
    COMA            reduce using rule 115 (dimensions -> dimensions L_CORCHETE a R_CORCHETE .)


state 206

    (47) interface_assign_pro -> i PUNTO LITERAL IGUAL a .
    (75) a -> a . OR b

    SEMI_COLON      reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    CONSOLE         reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    LET             reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    LITERAL         reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    IF              reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    WHILE           reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    FOR             reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    INTERFACE       reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    CONTINUE        reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    BREAK           reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    RETURN          reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    FUNCTION        reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    TOSTRING        reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    ENTERO          reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    DECIMAL         reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    CADENA          reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    TRUE            reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    FALSE           reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    L_PAREN         reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    L_CORCHETE      reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    L_LLAVE         reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    NOT             reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    MENOS           reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    MAS             reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    $end            reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    R_LLAVE         reduce using rule 47 (interface_assign_pro -> i PUNTO LITERAL IGUAL a .)
    OR              shift and go to state 73


state 207

    (112) i -> i PUNTO nativeFun L_PAREN expresion . R_PAREN
    (73) expresion -> expresion . COMA a

    R_PAREN         shift and go to state 226
    COMA            shift and go to state 224


state 208

    (113) i -> i PUNTO nativeFun L_PAREN R_PAREN .

    PUNTO           reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    POTENCIA        reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    TIMES           reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    DIVIDE          reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    MOD             reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    MAS             reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    MENOS           reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    DISTINTO_QUE    reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    MENOR_QUE       reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    MENOR_IGUAL_QUE reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    MAYOR_QUE       reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    MAYOR_IGUAL_QUE reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    TRIPLE_IGUAL    reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    AND             reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    OR              reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    SEMI_COLON      reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    CONSOLE         reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    LET             reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    LITERAL         reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    IF              reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    WHILE           reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    FOR             reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    INTERFACE       reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    CONTINUE        reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    BREAK           reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    RETURN          reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    FUNCTION        reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    TOSTRING        reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    ENTERO          reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    DECIMAL         reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    CADENA          reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    TRUE            reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    FALSE           reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    L_PAREN         reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    L_CORCHETE      reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    L_LLAVE         reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    NOT             reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    $end            reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    R_PAREN         reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    R_LLAVE         reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    R_CORCHETE      reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)
    COMA            reduce using rule 113 (i -> i PUNTO nativeFun L_PAREN R_PAREN .)


state 209

    (62) if_pro -> IF L_PAREN a R_PAREN L_LLAVE . instrucciones R_LLAVE else_pro
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    a                              shift and go to state 19
    instrucciones                  shift and go to state 227
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 210

    (120) atributos_assi -> atributos_assi COMA LITERAL COLON . a
    (75) a -> . a OR b
    (76) a -> . b
    (77) b -> . b AND c
    (78) b -> . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    a                              shift and go to state 228
    b                              shift and go to state 36
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 211

    (66) while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    a                              shift and go to state 19
    instrucciones                  shift and go to state 229
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 212

    (67) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a . SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (75) a -> a . OR b

    SEMI_COLON      shift and go to state 230
    OR              shift and go to state 73


state 213

    (68) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a . SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (75) a -> a . OR b

    SEMI_COLON      shift and go to state 231
    OR              shift and go to state 73


state 214

    (71) for_each_pro -> FOR L_PAREN LET LITERAL OF . a R_PAREN L_LLAVE instrucciones R_LLAVE
    (75) a -> . a OR b
    (76) a -> . b
    (77) b -> . b AND c
    (78) b -> . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    a                              shift and go to state 232
    b                              shift and go to state 36
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 215

    (45) interface_atributo -> LITERAL . COLON type
    (46) interface_atributo -> LITERAL .

    COLON           shift and go to state 233
    SEMI_COLON      reduce using rule 46 (interface_atributo -> LITERAL .)
    R_LLAVE         reduce using rule 46 (interface_atributo -> LITERAL .)
    LITERAL         reduce using rule 46 (interface_atributo -> LITERAL .)


state 216

    (42) interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .

    SEMI_COLON      reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    CONSOLE         reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    LET             reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    LITERAL         reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    IF              reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    WHILE           reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    FOR             reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    INTERFACE       reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    CONTINUE        reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    BREAK           reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    RETURN          reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    FUNCTION        reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    TOSTRING        reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    ENTERO          reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    DECIMAL         reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    CADENA          reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    TRUE            reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    FALSE           reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    L_PAREN         reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    L_CORCHETE      reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    L_LLAVE         reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    NOT             reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    MENOS           reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    MAS             reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    $end            reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)
    R_LLAVE         reduce using rule 42 (interface_pro -> INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE .)


state 217

    (43) interface_atributos -> interface_atributos interface_atributo . sc
    (21) sc -> . SEMI_COLON
    (22) sc -> .

    SEMI_COLON      shift and go to state 57
    R_LLAVE         reduce using rule 22 (sc -> .)
    LITERAL         reduce using rule 22 (sc -> .)

    sc                             shift and go to state 234

state 218

    (36) parameter_pro -> LITERAL COLON . type
    (55) type -> . NUMBER
    (56) type -> . STRING
    (57) type -> . BOOLEAN
    (58) type -> . ANY
    (59) type -> . LITERAL
    (60) type -> . NULL

    NUMBER          shift and go to state 176
    STRING          shift and go to state 177
    BOOLEAN         shift and go to state 178
    ANY             shift and go to state 179
    LITERAL         shift and go to state 174
    NULL            shift and go to state 180

    type                           shift and go to state 235

state 219

    (23) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN . L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN . COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN . COLON LITERAL L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 236
    COLON           shift and go to state 237


state 220

    (34) parameters_pro -> parameters_pro COMA . parameter_pro
    (36) parameter_pro -> . LITERAL COLON type
    (37) parameter_pro -> . LITERAL

    LITERAL         shift and go to state 196

    parameter_pro                  shift and go to state 238

state 221

    (24) function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    instrucciones                  shift and go to state 239
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    a                              shift and go to state 19
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 222

    (27) function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON . type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON . LITERAL L_LLAVE instrucciones R_LLAVE
    (55) type -> . NUMBER
    (56) type -> . STRING
    (57) type -> . BOOLEAN
    (58) type -> . ANY
    (59) type -> . LITERAL
    (60) type -> . NULL

    LITERAL         shift and go to state 240
    NUMBER          shift and go to state 176
    STRING          shift and go to state 177
    BOOLEAN         shift and go to state 178
    ANY             shift and go to state 179
    NULL            shift and go to state 180

    type                           shift and go to state 241

state 223

    (72) console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .

    SEMI_COLON      reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    CONSOLE         reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    LET             reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    LITERAL         reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    IF              reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    WHILE           reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    FOR             reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    INTERFACE       reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    CONTINUE        reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    BREAK           reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    RETURN          reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    FUNCTION        reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    TOSTRING        reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    ENTERO          reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    DECIMAL         reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    CADENA          reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    TRUE            reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    FALSE           reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    L_PAREN         reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    L_CORCHETE      reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    L_LLAVE         reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    NOT             reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    MENOS           reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    MAS             reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    $end            reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)
    R_LLAVE         reduce using rule 72 (console_pro -> CONSOLE PUNTO LOG L_PAREN expresion R_PAREN .)


state 224

    (73) expresion -> expresion COMA . a
    (75) a -> . a OR b
    (76) a -> . b
    (77) b -> . b AND c
    (78) b -> . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    a                              shift and go to state 242
    b                              shift and go to state 36
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 225

    (51) assignacion_instruction -> LITERAL COLON type IGUAL a .
    (75) a -> a . OR b

    COMA            reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    SEMI_COLON      reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    CONSOLE         reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    LET             reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    LITERAL         reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    IF              reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    WHILE           reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    FOR             reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    INTERFACE       reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    CONTINUE        reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    BREAK           reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    RETURN          reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    FUNCTION        reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    TOSTRING        reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    ENTERO          reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    DECIMAL         reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    CADENA          reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    TRUE            reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    FALSE           reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    L_PAREN         reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    L_CORCHETE      reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    L_LLAVE         reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    NOT             reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    MENOS           reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    MAS             reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    $end            reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    R_LLAVE         reduce using rule 51 (assignacion_instruction -> LITERAL COLON type IGUAL a .)
    OR              shift and go to state 73


state 226

    (112) i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .

    PUNTO           reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    POTENCIA        reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    TIMES           reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    DIVIDE          reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MOD             reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MAS             reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MENOS           reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    DISTINTO_QUE    reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MENOR_QUE       reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MENOR_IGUAL_QUE reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MAYOR_QUE       reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    MAYOR_IGUAL_QUE reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    TRIPLE_IGUAL    reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    AND             reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    OR              reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    SEMI_COLON      reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    CONSOLE         reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    LET             reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    LITERAL         reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    IF              reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    WHILE           reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    FOR             reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    INTERFACE       reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    CONTINUE        reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    BREAK           reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    RETURN          reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    FUNCTION        reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    TOSTRING        reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    ENTERO          reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    DECIMAL         reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    CADENA          reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    TRUE            reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    FALSE           reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    L_PAREN         reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    L_CORCHETE      reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    L_LLAVE         reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    NOT             reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    $end            reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    R_PAREN         reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    R_LLAVE         reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    R_CORCHETE      reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)
    COMA            reduce using rule 112 (i -> i PUNTO nativeFun L_PAREN expresion R_PAREN .)


state 227

    (62) if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones . R_LLAVE else_pro
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    R_LLAVE         shift and go to state 243
    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    a                              shift and go to state 19
    instruccion                    shift and go to state 55
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 228

    (120) atributos_assi -> atributos_assi COMA LITERAL COLON a .
    (75) a -> a . OR b

    R_LLAVE         reduce using rule 120 (atributos_assi -> atributos_assi COMA LITERAL COLON a .)
    COMA            reduce using rule 120 (atributos_assi -> atributos_assi COMA LITERAL COLON a .)
    OR              shift and go to state 73


state 229

    (66) while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    R_LLAVE         shift and go to state 244
    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    a                              shift and go to state 19
    instruccion                    shift and go to state 55
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 230

    (67) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON . inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (69) inDec_pro -> . assig_pro
    (70) inDec_pro -> . sumadores
    (61) assig_pro -> . LITERAL IGUAL a
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS

    LITERAL         shift and go to state 248

    inDec_pro                      shift and go to state 245
    assig_pro                      shift and go to state 246
    sumadores                      shift and go to state 247

state 231

    (68) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON . inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (69) inDec_pro -> . assig_pro
    (70) inDec_pro -> . sumadores
    (61) assig_pro -> . LITERAL IGUAL a
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS

    LITERAL         shift and go to state 248

    assig_pro                      shift and go to state 246
    inDec_pro                      shift and go to state 249
    sumadores                      shift and go to state 247

state 232

    (71) for_each_pro -> FOR L_PAREN LET LITERAL OF a . R_PAREN L_LLAVE instrucciones R_LLAVE
    (75) a -> a . OR b

    R_PAREN         shift and go to state 250
    OR              shift and go to state 73


state 233

    (45) interface_atributo -> LITERAL COLON . type
    (55) type -> . NUMBER
    (56) type -> . STRING
    (57) type -> . BOOLEAN
    (58) type -> . ANY
    (59) type -> . LITERAL
    (60) type -> . NULL

    NUMBER          shift and go to state 176
    STRING          shift and go to state 177
    BOOLEAN         shift and go to state 178
    ANY             shift and go to state 179
    LITERAL         shift and go to state 174
    NULL            shift and go to state 180

    type                           shift and go to state 251

state 234

    (43) interface_atributos -> interface_atributos interface_atributo sc .

    R_LLAVE         reduce using rule 43 (interface_atributos -> interface_atributos interface_atributo sc .)
    LITERAL         reduce using rule 43 (interface_atributos -> interface_atributos interface_atributo sc .)


state 235

    (36) parameter_pro -> LITERAL COLON type .

    R_PAREN         reduce using rule 36 (parameter_pro -> LITERAL COLON type .)
    COMA            reduce using rule 36 (parameter_pro -> LITERAL COLON type .)


state 236

    (23) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    instrucciones                  shift and go to state 252
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    a                              shift and go to state 19
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 237

    (25) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON . type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON . LITERAL L_LLAVE instrucciones R_LLAVE
    (55) type -> . NUMBER
    (56) type -> . STRING
    (57) type -> . BOOLEAN
    (58) type -> . ANY
    (59) type -> . LITERAL
    (60) type -> . NULL

    LITERAL         shift and go to state 253
    NUMBER          shift and go to state 176
    STRING          shift and go to state 177
    BOOLEAN         shift and go to state 178
    ANY             shift and go to state 179
    NULL            shift and go to state 180

    type                           shift and go to state 254

state 238

    (34) parameters_pro -> parameters_pro COMA parameter_pro .

    R_PAREN         reduce using rule 34 (parameters_pro -> parameters_pro COMA parameter_pro .)
    COMA            reduce using rule 34 (parameters_pro -> parameters_pro COMA parameter_pro .)


state 239

    (24) function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    R_LLAVE         shift and go to state 255
    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    instruccion                    shift and go to state 55
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    a                              shift and go to state 19
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 240

    (28) function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL . L_LLAVE instrucciones R_LLAVE
    (59) type -> LITERAL .

  ! shift/reduce conflict for L_LLAVE resolved as shift
    L_LLAVE         shift and go to state 256

  ! L_LLAVE         [ reduce using rule 59 (type -> LITERAL .) ]


state 241

    (27) function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 257


state 242

    (73) expresion -> expresion COMA a .
    (75) a -> a . OR b

    R_PAREN         reduce using rule 73 (expresion -> expresion COMA a .)
    COMA            reduce using rule 73 (expresion -> expresion COMA a .)
    OR              shift and go to state 73


state 243

    (62) if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE . else_pro
    (63) else_pro -> . ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (64) else_pro -> . ELSE L_LLAVE instrucciones R_LLAVE
    (65) else_pro -> .

    ELSE            shift and go to state 259
    SEMI_COLON      reduce using rule 65 (else_pro -> .)
    CONSOLE         reduce using rule 65 (else_pro -> .)
    LET             reduce using rule 65 (else_pro -> .)
    LITERAL         reduce using rule 65 (else_pro -> .)
    IF              reduce using rule 65 (else_pro -> .)
    WHILE           reduce using rule 65 (else_pro -> .)
    FOR             reduce using rule 65 (else_pro -> .)
    INTERFACE       reduce using rule 65 (else_pro -> .)
    CONTINUE        reduce using rule 65 (else_pro -> .)
    BREAK           reduce using rule 65 (else_pro -> .)
    RETURN          reduce using rule 65 (else_pro -> .)
    FUNCTION        reduce using rule 65 (else_pro -> .)
    TOSTRING        reduce using rule 65 (else_pro -> .)
    ENTERO          reduce using rule 65 (else_pro -> .)
    DECIMAL         reduce using rule 65 (else_pro -> .)
    CADENA          reduce using rule 65 (else_pro -> .)
    TRUE            reduce using rule 65 (else_pro -> .)
    FALSE           reduce using rule 65 (else_pro -> .)
    L_PAREN         reduce using rule 65 (else_pro -> .)
    L_CORCHETE      reduce using rule 65 (else_pro -> .)
    L_LLAVE         reduce using rule 65 (else_pro -> .)
    NOT             reduce using rule 65 (else_pro -> .)
    MENOS           reduce using rule 65 (else_pro -> .)
    MAS             reduce using rule 65 (else_pro -> .)
    $end            reduce using rule 65 (else_pro -> .)
    R_LLAVE         reduce using rule 65 (else_pro -> .)

    else_pro                       shift and go to state 258

state 244

    (66) while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONTINUE        reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    BREAK           reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    RETURN          reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FUNCTION        reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    TOSTRING        reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    ENTERO          reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    DECIMAL         reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CADENA          reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    TRUE            reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FALSE           reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    L_PAREN         reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    L_CORCHETE      reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    L_LLAVE         reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    NOT             reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    MENOS           reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    MAS             reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 66 (while_pro -> WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 245

    (67) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro . R_PAREN L_LLAVE instrucciones R_LLAVE

    R_PAREN         shift and go to state 260


state 246

    (69) inDec_pro -> assig_pro .

    R_PAREN         reduce using rule 69 (inDec_pro -> assig_pro .)


state 247

    (70) inDec_pro -> sumadores .

    R_PAREN         reduce using rule 70 (inDec_pro -> sumadores .)


state 248

    (61) assig_pro -> LITERAL . IGUAL a
    (117) sumadores -> LITERAL . MAS MAS
    (118) sumadores -> LITERAL . MENOS MENOS

    IGUAL           shift and go to state 83
    MAS             shift and go to state 86
    MENOS           shift and go to state 87


state 249

    (68) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro . R_PAREN L_LLAVE instrucciones R_LLAVE

    R_PAREN         shift and go to state 261


state 250

    (71) for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 262


state 251

    (45) interface_atributo -> LITERAL COLON type .

    SEMI_COLON      reduce using rule 45 (interface_atributo -> LITERAL COLON type .)
    R_LLAVE         reduce using rule 45 (interface_atributo -> LITERAL COLON type .)
    LITERAL         reduce using rule 45 (interface_atributo -> LITERAL COLON type .)


state 252

    (23) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    R_LLAVE         shift and go to state 263
    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    instruccion                    shift and go to state 55
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    a                              shift and go to state 19
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 253

    (26) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL . L_LLAVE instrucciones R_LLAVE
    (59) type -> LITERAL .

  ! shift/reduce conflict for L_LLAVE resolved as shift
    L_LLAVE         shift and go to state 264

  ! L_LLAVE         [ reduce using rule 59 (type -> LITERAL .) ]


state 254

    (25) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 265


state 255

    (24) function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONTINUE        reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    BREAK           reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    RETURN          reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FUNCTION        reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    TOSTRING        reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    ENTERO          reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    DECIMAL         reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CADENA          reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    TRUE            reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FALSE           reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    L_PAREN         reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    L_CORCHETE      reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    L_LLAVE         reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    NOT             reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    MENOS           reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    MAS             reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 24 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 256

    (28) function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    instrucciones                  shift and go to state 266
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    a                              shift and go to state 19
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 257

    (27) function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    instrucciones                  shift and go to state 267
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    a                              shift and go to state 19
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 258

    (62) if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .

    SEMI_COLON      reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    CONSOLE         reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    LET             reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    LITERAL         reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    IF              reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    WHILE           reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    FOR             reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    INTERFACE       reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    CONTINUE        reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    BREAK           reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    RETURN          reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    FUNCTION        reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    TOSTRING        reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    ENTERO          reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    DECIMAL         reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    CADENA          reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    TRUE            reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    FALSE           reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    L_PAREN         reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    L_CORCHETE      reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    L_LLAVE         reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    NOT             reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    MENOS           reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    MAS             reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    $end            reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    R_LLAVE         reduce using rule 62 (if_pro -> IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)


state 259

    (63) else_pro -> ELSE . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (64) else_pro -> ELSE . L_LLAVE instrucciones R_LLAVE

    IF              shift and go to state 268
    L_LLAVE         shift and go to state 269


state 260

    (67) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 270


state 261

    (68) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN . L_LLAVE instrucciones R_LLAVE

    L_LLAVE         shift and go to state 271


state 262

    (71) for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    a                              shift and go to state 19
    instrucciones                  shift and go to state 272
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 263

    (23) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONTINUE        reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    BREAK           reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    RETURN          reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FUNCTION        reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    TOSTRING        reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    ENTERO          reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    DECIMAL         reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CADENA          reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    TRUE            reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FALSE           reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    L_PAREN         reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    L_CORCHETE      reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    L_LLAVE         reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    NOT             reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    MENOS           reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    MAS             reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 23 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 264

    (26) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    instrucciones                  shift and go to state 273
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    a                              shift and go to state 19
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 265

    (25) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    instrucciones                  shift and go to state 274
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    a                              shift and go to state 19
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 266

    (28) function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    R_LLAVE         shift and go to state 275
    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    instruccion                    shift and go to state 55
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    a                              shift and go to state 19
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 267

    (27) function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    R_LLAVE         shift and go to state 276
    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    instruccion                    shift and go to state 55
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    a                              shift and go to state 19
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 268

    (63) else_pro -> ELSE IF . L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro

    L_PAREN         shift and go to state 277


state 269

    (64) else_pro -> ELSE L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    instrucciones                  shift and go to state 278
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    a                              shift and go to state 19
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 270

    (67) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    declaration_instruction        shift and go to state 5
    a                              shift and go to state 19
    instrucciones                  shift and go to state 279
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 271

    (68) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE . instrucciones R_LLAVE
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    assig_pro                      shift and go to state 6
    a                              shift and go to state 19
    instrucciones                  shift and go to state 280
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 272

    (71) for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    R_LLAVE         shift and go to state 281
    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    a                              shift and go to state 19
    instruccion                    shift and go to state 55
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 273

    (26) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    R_LLAVE         shift and go to state 282
    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    instruccion                    shift and go to state 55
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    a                              shift and go to state 19
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 274

    (25) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    R_LLAVE         shift and go to state 283
    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    instruccion                    shift and go to state 55
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    a                              shift and go to state 19
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 275

    (28) function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    CONTINUE        reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    BREAK           reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    RETURN          reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    FUNCTION        reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    TOSTRING        reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    ENTERO          reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    DECIMAL         reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    CADENA          reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    TRUE            reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    FALSE           reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    L_PAREN         reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    L_CORCHETE      reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    L_LLAVE         reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    NOT             reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    MENOS           reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    MAS             reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 28 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)


state 276

    (27) function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    CONTINUE        reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    BREAK           reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    RETURN          reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    FUNCTION        reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    TOSTRING        reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    ENTERO          reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    DECIMAL         reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    CADENA          reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    TRUE            reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    FALSE           reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    L_PAREN         reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    L_CORCHETE      reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    L_LLAVE         reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    NOT             reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    MENOS           reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    MAS             reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 27 (function_pro -> FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)


state 277

    (63) else_pro -> ELSE IF L_PAREN . a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (75) a -> . a OR b
    (76) a -> . b
    (77) b -> . b AND c
    (78) b -> . c
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions

    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    LITERAL         shift and go to state 78
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    TOSTRING        shift and go to state 35
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27

    a                              shift and go to state 284
    b                              shift and go to state 36
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54
    i                              shift and go to state 77
    call_function_pro              shift and go to state 79
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46

state 278

    (64) else_pro -> ELSE L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    R_LLAVE         shift and go to state 285
    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    instruccion                    shift and go to state 55
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    a                              shift and go to state 19
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 279

    (67) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    R_LLAVE         shift and go to state 286
    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    declaration_instruction        shift and go to state 5
    a                              shift and go to state 19
    instruccion                    shift and go to state 55
    console_pro                    shift and go to state 4
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 280

    (68) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones . R_LLAVE
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    R_LLAVE         shift and go to state 287
    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    assig_pro                      shift and go to state 6
    a                              shift and go to state 19
    instruccion                    shift and go to state 55
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 281

    (71) for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONTINUE        reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    BREAK           reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    RETURN          reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FUNCTION        reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    TOSTRING        reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    ENTERO          reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    DECIMAL         reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CADENA          reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    TRUE            reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FALSE           reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    L_PAREN         reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    L_CORCHETE      reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    L_LLAVE         reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    NOT             reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    MENOS           reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    MAS             reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 71 (for_each_pro -> FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 282

    (26) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    CONTINUE        reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    BREAK           reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    RETURN          reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    FUNCTION        reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    TOSTRING        reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    ENTERO          reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    DECIMAL         reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    CADENA          reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    TRUE            reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    FALSE           reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    L_PAREN         reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    L_CORCHETE      reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    L_LLAVE         reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    NOT             reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    MENOS           reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    MAS             reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 26 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE .)


state 283

    (25) function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    CONTINUE        reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    BREAK           reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    RETURN          reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    FUNCTION        reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    TOSTRING        reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    ENTERO          reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    DECIMAL         reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    CADENA          reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    TRUE            reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    FALSE           reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    L_PAREN         reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    L_CORCHETE      reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    L_LLAVE         reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    NOT             reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    MENOS           reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    MAS             reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 25 (function_pro -> FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE .)


state 284

    (63) else_pro -> ELSE IF L_PAREN a . R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (75) a -> a . OR b

    R_PAREN         shift and go to state 288
    OR              shift and go to state 73


state 285

    (64) else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    CONTINUE        reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    BREAK           reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    RETURN          reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    FUNCTION        reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    TOSTRING        reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    ENTERO          reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    DECIMAL         reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    CADENA          reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    TRUE            reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    FALSE           reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    L_PAREN         reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    L_CORCHETE      reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    L_LLAVE         reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    NOT             reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    MENOS           reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    MAS             reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 64 (else_pro -> ELSE L_LLAVE instrucciones R_LLAVE .)


state 286

    (67) for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONTINUE        reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    BREAK           reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    RETURN          reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FUNCTION        reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    TOSTRING        reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    ENTERO          reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    DECIMAL         reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CADENA          reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    TRUE            reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FALSE           reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    L_PAREN         reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    L_CORCHETE      reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    L_LLAVE         reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    NOT             reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    MENOS           reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    MAS             reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 67 (for_pro -> FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 287

    (68) for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .

    SEMI_COLON      reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONSOLE         reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LET             reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    LITERAL         reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    IF              reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    WHILE           reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FOR             reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    INTERFACE       reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CONTINUE        reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    BREAK           reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    RETURN          reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FUNCTION        reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    TOSTRING        reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    ENTERO          reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    DECIMAL         reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    CADENA          reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    TRUE            reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    FALSE           reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    L_PAREN         reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    L_CORCHETE      reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    L_LLAVE         reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    NOT             reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    MENOS           reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    MAS             reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    $end            reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)
    R_LLAVE         reduce using rule 68 (for_pro -> FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE .)


state 288

    (63) else_pro -> ELSE IF L_PAREN a R_PAREN . L_LLAVE instrucciones R_LLAVE else_pro

    L_LLAVE         shift and go to state 289


state 289

    (63) else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE . instrucciones R_LLAVE else_pro
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    a                              shift and go to state 19
    instrucciones                  shift and go to state 290
    instruccion                    shift and go to state 3
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 290

    (63) else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones . R_LLAVE else_pro
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . console_pro sc
    (5) instruccion -> . declaration_instruction sc
    (6) instruccion -> . assig_pro sc
    (7) instruccion -> . interface_assign_pro sc
    (8) instruccion -> . array_assign_pro sc
    (9) instruccion -> . if_pro sc
    (10) instruccion -> . while_pro sc
    (11) instruccion -> . for_pro sc
    (12) instruccion -> . for_each_pro sc
    (13) instruccion -> . interface_pro sc
    (14) instruccion -> . continue_pro sc
    (15) instruccion -> . break_pro sc
    (16) instruccion -> . return_pro sc
    (17) instruccion -> . function_pro sc
    (18) instruccion -> . call_function_pro sc
    (19) instruccion -> . a sc
    (20) instruccion -> . sumadores sc
    (72) console_pro -> . CONSOLE PUNTO LOG L_PAREN expresion R_PAREN
    (48) declaration_instruction -> . LET declaracion_list
    (61) assig_pro -> . LITERAL IGUAL a
    (47) interface_assign_pro -> . i PUNTO LITERAL IGUAL a
    (123) array_assign_pro -> . LITERAL dimensions IGUAL a
    (62) if_pro -> . IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (66) while_pro -> . WHILE L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE
    (67) for_pro -> . FOR L_PAREN declaration_instruction SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (68) for_pro -> . FOR L_PAREN assig_pro SEMI_COLON a SEMI_COLON inDec_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (71) for_each_pro -> . FOR L_PAREN LET LITERAL OF a R_PAREN L_LLAVE instrucciones R_LLAVE
    (42) interface_pro -> . INTERFACE LITERAL L_LLAVE interface_atributos R_LLAVE
    (38) continue_pro -> . CONTINUE
    (39) break_pro -> . BREAK
    (40) return_pro -> . RETURN
    (41) return_pro -> . RETURN a
    (23) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN L_LLAVE instrucciones R_LLAVE
    (24) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN L_LLAVE instrucciones R_LLAVE
    (25) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (26) function_pro -> . FUNCTION LITERAL L_PAREN parameters_pro R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (27) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON type L_LLAVE instrucciones R_LLAVE
    (28) function_pro -> . FUNCTION LITERAL L_PAREN R_PAREN COLON LITERAL L_LLAVE instrucciones R_LLAVE
    (29) call_function_pro -> . LITERAL L_PAREN values R_PAREN
    (30) call_function_pro -> . LITERAL L_PAREN R_PAREN
    (31) call_function_pro -> . TOSTRING L_PAREN values R_PAREN
    (75) a -> . a OR b
    (76) a -> . b
    (117) sumadores -> . LITERAL MAS MAS
    (118) sumadores -> . LITERAL MENOS MENOS
    (100) i -> . ENTERO
    (101) i -> . DECIMAL
    (102) i -> . CADENA
    (103) i -> . LITERAL
    (104) i -> . TRUE
    (105) i -> . FALSE
    (106) i -> . call_function_pro
    (107) i -> . array_pro
    (108) i -> . interface_assi
    (109) i -> . L_PAREN a R_PAREN
    (110) i -> . array_val_pro
    (111) i -> . i PUNTO LITERAL
    (112) i -> . i PUNTO nativeFun L_PAREN expresion R_PAREN
    (113) i -> . i PUNTO nativeFun L_PAREN R_PAREN
    (77) b -> . b AND c
    (78) b -> . c
    (122) array_pro -> . L_CORCHETE values R_CORCHETE
    (119) interface_assi -> . L_LLAVE atributos_assi R_LLAVE
    (114) array_val_pro -> . LITERAL dimensions
    (79) c -> . NOT d
    (80) c -> . d
    (81) d -> . d DISTINTO_QUE e
    (82) d -> . d MENOR_QUE e
    (83) d -> . d MENOR_IGUAL_QUE e
    (84) d -> . d MAYOR_QUE e
    (85) d -> . d MAYOR_IGUAL_QUE e
    (86) d -> . d TRIPLE_IGUAL e
    (87) d -> . e
    (88) e -> . e MAS f
    (89) e -> . e MENOS f
    (90) e -> . f
    (91) f -> . MENOS g
    (92) f -> . MAS g
    (93) f -> . g
    (94) g -> . g TIMES h
    (95) g -> . g DIVIDE h
    (96) g -> . g MOD h
    (97) g -> . h
    (98) h -> . h POTENCIA i
    (99) h -> . i

    R_LLAVE         shift and go to state 291
    CONSOLE         shift and go to state 21
    LET             shift and go to state 23
    LITERAL         shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    INTERFACE       shift and go to state 30
    CONTINUE        shift and go to state 31
    BREAK           shift and go to state 32
    RETURN          shift and go to state 33
    FUNCTION        shift and go to state 34
    TOSTRING        shift and go to state 35
    ENTERO          shift and go to state 39
    DECIMAL         shift and go to state 40
    CADENA          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    L_PAREN         shift and go to state 22
    L_CORCHETE      shift and go to state 48
    L_LLAVE         shift and go to state 27
    NOT             shift and go to state 49
    MENOS           shift and go to state 38
    MAS             shift and go to state 37

    a                              shift and go to state 19
    instruccion                    shift and go to state 55
    console_pro                    shift and go to state 4
    declaration_instruction        shift and go to state 5
    assig_pro                      shift and go to state 6
    interface_assign_pro           shift and go to state 7
    array_assign_pro               shift and go to state 8
    if_pro                         shift and go to state 9
    while_pro                      shift and go to state 10
    for_pro                        shift and go to state 11
    for_each_pro                   shift and go to state 12
    interface_pro                  shift and go to state 13
    continue_pro                   shift and go to state 14
    break_pro                      shift and go to state 15
    return_pro                     shift and go to state 16
    function_pro                   shift and go to state 17
    call_function_pro              shift and go to state 18
    sumadores                      shift and go to state 20
    i                              shift and go to state 25
    b                              shift and go to state 36
    array_pro                      shift and go to state 44
    interface_assi                 shift and go to state 45
    array_val_pro                  shift and go to state 46
    c                              shift and go to state 47
    d                              shift and go to state 50
    e                              shift and go to state 51
    f                              shift and go to state 52
    g                              shift and go to state 53
    h                              shift and go to state 54

state 291

    (63) else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE . else_pro
    (63) else_pro -> . ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro
    (64) else_pro -> . ELSE L_LLAVE instrucciones R_LLAVE
    (65) else_pro -> .

    ELSE            shift and go to state 259
    SEMI_COLON      reduce using rule 65 (else_pro -> .)
    CONSOLE         reduce using rule 65 (else_pro -> .)
    LET             reduce using rule 65 (else_pro -> .)
    LITERAL         reduce using rule 65 (else_pro -> .)
    IF              reduce using rule 65 (else_pro -> .)
    WHILE           reduce using rule 65 (else_pro -> .)
    FOR             reduce using rule 65 (else_pro -> .)
    INTERFACE       reduce using rule 65 (else_pro -> .)
    CONTINUE        reduce using rule 65 (else_pro -> .)
    BREAK           reduce using rule 65 (else_pro -> .)
    RETURN          reduce using rule 65 (else_pro -> .)
    FUNCTION        reduce using rule 65 (else_pro -> .)
    TOSTRING        reduce using rule 65 (else_pro -> .)
    ENTERO          reduce using rule 65 (else_pro -> .)
    DECIMAL         reduce using rule 65 (else_pro -> .)
    CADENA          reduce using rule 65 (else_pro -> .)
    TRUE            reduce using rule 65 (else_pro -> .)
    FALSE           reduce using rule 65 (else_pro -> .)
    L_PAREN         reduce using rule 65 (else_pro -> .)
    L_CORCHETE      reduce using rule 65 (else_pro -> .)
    L_LLAVE         reduce using rule 65 (else_pro -> .)
    NOT             reduce using rule 65 (else_pro -> .)
    MENOS           reduce using rule 65 (else_pro -> .)
    MAS             reduce using rule 65 (else_pro -> .)
    $end            reduce using rule 65 (else_pro -> .)
    R_LLAVE         reduce using rule 65 (else_pro -> .)

    else_pro                       shift and go to state 292

state 292

    (63) else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .

    SEMI_COLON      reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    CONSOLE         reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    LET             reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    LITERAL         reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    IF              reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    WHILE           reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    FOR             reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    INTERFACE       reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    CONTINUE        reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    BREAK           reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    RETURN          reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    FUNCTION        reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    TOSTRING        reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    ENTERO          reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    DECIMAL         reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    CADENA          reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    TRUE            reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    FALSE           reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    L_PAREN         reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    L_CORCHETE      reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    L_LLAVE         reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    NOT             reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    MENOS           reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    MAS             reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    $end            reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)
    R_LLAVE         reduce using rule 63 (else_pro -> ELSE IF L_PAREN a R_PAREN L_LLAVE instrucciones R_LLAVE else_pro .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for SEMI_COLON in state 18 resolved as shift
WARNING: shift/reduce conflict for MAS in state 24 resolved as shift
WARNING: shift/reduce conflict for MENOS in state 24 resolved as shift
WARNING: shift/reduce conflict for L_PAREN in state 24 resolved as shift
WARNING: shift/reduce conflict for L_CORCHETE in state 24 resolved as shift
WARNING: shift/reduce conflict for NOT in state 33 resolved as shift
WARNING: shift/reduce conflict for MENOS in state 33 resolved as shift
WARNING: shift/reduce conflict for MAS in state 33 resolved as shift
WARNING: shift/reduce conflict for ENTERO in state 33 resolved as shift
WARNING: shift/reduce conflict for DECIMAL in state 33 resolved as shift
WARNING: shift/reduce conflict for CADENA in state 33 resolved as shift
WARNING: shift/reduce conflict for LITERAL in state 33 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 33 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 33 resolved as shift
WARNING: shift/reduce conflict for L_PAREN in state 33 resolved as shift
WARNING: shift/reduce conflict for TOSTRING in state 33 resolved as shift
WARNING: shift/reduce conflict for L_CORCHETE in state 33 resolved as shift
WARNING: shift/reduce conflict for L_LLAVE in state 33 resolved as shift
WARNING: shift/reduce conflict for MAS in state 51 resolved as shift
WARNING: shift/reduce conflict for MENOS in state 51 resolved as shift
WARNING: shift/reduce conflict for L_PAREN in state 78 resolved as shift
WARNING: shift/reduce conflict for L_CORCHETE in state 78 resolved as shift
WARNING: shift/reduce conflict for L_CORCHETE in state 84 resolved as shift
WARNING: shift/reduce conflict for L_CORCHETE in state 121 resolved as shift
WARNING: shift/reduce conflict for MAS in state 159 resolved as shift
WARNING: shift/reduce conflict for MENOS in state 159 resolved as shift
WARNING: shift/reduce conflict for MAS in state 160 resolved as shift
WARNING: shift/reduce conflict for MENOS in state 160 resolved as shift
WARNING: shift/reduce conflict for MAS in state 161 resolved as shift
WARNING: shift/reduce conflict for MENOS in state 161 resolved as shift
WARNING: shift/reduce conflict for MAS in state 162 resolved as shift
WARNING: shift/reduce conflict for MENOS in state 162 resolved as shift
WARNING: shift/reduce conflict for MAS in state 163 resolved as shift
WARNING: shift/reduce conflict for MENOS in state 163 resolved as shift
WARNING: shift/reduce conflict for MAS in state 164 resolved as shift
WARNING: shift/reduce conflict for MENOS in state 164 resolved as shift
WARNING: shift/reduce conflict for L_LLAVE in state 240 resolved as shift
WARNING: shift/reduce conflict for L_LLAVE in state 253 resolved as shift
WARNING: reduce/reduce conflict in state 18 resolved using rule (sc -> <empty>)
WARNING: rejected rule (i -> call_function_pro) in state 18
